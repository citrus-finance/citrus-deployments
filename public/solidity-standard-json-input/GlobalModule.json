{
  "language": "Solidity",
  "sources": {
    "contracts/citrus-safe-modules/src/GlobalModule.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./interfaces/ISafe.sol\";\n\nerror ExecutionFailed();\n\ncontract GlobalModule {\n    // keccak256(\n    //     \"EIP712Domain(address verifyingContract)\"\n    // );\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH =\n        0x035aff83d86937d35b32e04f0ddc6ff469290eef2f1b692d8a815c89404d4749;\n\n    // keccak256(\n    //     \"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 nonce)\"\n    // );\n    bytes32 private constant SAFE_TX_TYPEHASH = 0x3317c908a134e5c2510760347e7f23b965536b042f3c71282a3d92e04a7b29f5;\n\n    mapping(ISafe => uint256) public nonces;\n\n    /**\n     * @notice Executes a `operation` {0: Call, 1: DelegateCall}} transaction to `to` with `value` (Native Currency)\n     * @dev This method doesn't perform any sanity check of the transaction, such as:\n     *      - if the contract at `to` address has code or not\n     *      It is the responsibility of the caller to perform such checks.\n     * @param safe The safe the transaction will be executed on\n     * @param to Destination address of Safe transaction.\n     * @param value Ether value of Safe transaction.\n     * @param data Data payload of Safe transaction.\n     * @param operation Operation type of Safe transaction.\n     * @param signatures Signature data that should be verified.\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\n     * @return success Boolean indicating transaction's success.\n     */\n    function execTransaction(\n        ISafe safe,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        uint8 operation,\n        bytes memory signatures\n    ) public payable virtual returns (bool success) {\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            uint256 nonce = nonces[safe];\n            bytes memory txHashData = encodeTransactionData(\n                safe,\n                // Transaction info\n                to,\n                value,\n                data,\n                operation,\n                // Signature info\n                nonce\n            );\n            // Increase nonce and execute transaction.\n            nonces[safe]++;\n            txHash = keccak256(txHashData);\n            safe.checkSignatures(txHash, txHashData, signatures);\n        }\n\n        if (!safe.execTransactionFromModule(to, value, data, operation)) {\n            revert ExecutionFailed();\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Returns the domain separator for the safe contract, as defined in the EIP-712 standard.\n     * @param safe The safe the transaction will be executed on\n     * @return bytes32 The domain separator hash.\n     */\n    function domainSeparator(ISafe safe) public pure returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, safe));\n    }\n\n    /**\n     * @notice Returns the pre-image of the transaction hash (see getTransactionHash).\n     * @param safe The safe the transaction will be executed on\n     * @param to Destination address.\n     * @param value Ether value.\n     * @param data Data payload.\n     * @param operation Operation type.\n     * @param _nonce Transaction nonce.\n     * @return Transaction hash bytes.\n     */\n    function encodeTransactionData(\n        ISafe safe,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        uint8 operation,\n        uint256 _nonce\n    ) public pure returns (bytes memory) {\n        bytes32 safeTxHash = keccak256(abi.encode(SAFE_TX_TYPEHASH, to, value, keccak256(data), operation, _nonce));\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(safe), safeTxHash);\n    }\n\n    /**\n     * @notice Returns transaction hash to be signed by owners.\n     * @param safe The safe the transaction will be executed on\n     * @param to Destination address.\n     * @param value Ether value.\n     * @param data Data payload.\n     * @param operation Operation type.\n     * @param _nonce Transaction nonce.\n     * @return Transaction hash.\n     */\n    function getTransactionHash(\n        ISafe safe,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        uint8 operation,\n        uint256 _nonce\n    ) public pure returns (bytes32) {\n        return keccak256(encodeTransactionData(safe, to, value, data, operation, _nonce));\n    }\n}\n"
    },
    "contracts/citrus-safe-modules/src/interfaces/ISafe.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\ninterface ISafe {\n    /**\n     * @notice Sets an initial storage of the Safe contract.\n     * @dev This method can only be called once.\n     *      If a proxy was created without setting up, anyone can call setup and claim the proxy.\n     * @param _owners List of Safe owners.\n     * @param _threshold Number of required confirmations for a Safe transaction.\n     * @param to Contract address for optional delegate call.\n     * @param data Data payload for optional delegate call.\n     * @param fallbackHandler Handler for fallback calls to this contract\n     * @param paymentToken Token that should be used for the payment (0 is ETH)\n     * @param payment Value that should be paid\n     * @param paymentReceiver Address that should receive the payment (or 0 if tx.origin)\n     */\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    ) external;\n\n    /**\n     * @dev Allows a Module to execute a Safe transaction without any further confirmations.\n     * @param to Destination address of module transaction.\n     * @param value Ether value of module transaction.\n     * @param data Data payload of module transaction.\n     * @param operation Operation type of module transaction.\n     */\n    function execTransactionFromModule(address to, uint256 value, bytes memory data, uint8 operation)\n        external\n        returns (bool success);\n\n    /**\n     * @notice Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token) and return data\n     * @param to Destination address of module transaction.\n     * @param value Ether value of module transaction.\n     * @param data Data payload of module transaction.\n     * @param operation Operation type of module transaction.\n     * @return success Boolean flag indicating if the call succeeded.\n     * @return returnData Data returned by the call.\n     */\n    function execTransactionFromModuleReturnData(address to, uint256 value, bytes memory data, uint8 operation)\n        external\n        returns (bool success, bytes memory returnData);\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param data That should be signed (this is passed to an external validator contract)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(bytes32 dataHash, bytes memory data, bytes memory signatures) external view;\n\n    /**\n     * @dev Returns the domain separator for this contract, as defined in the EIP-712 standard.\n     * @return bytes32 The domain separator hash.\n     */\n    function domainSeparator() external view returns (bytes32);\n\n    /**\n     * @dev Returns array of modules.\n     * @param start Start of the page.\n     * @param pageSize Maximum number of modules that should be returned.\n     * @return array Array of modules.\n     * @return next Start of the next page.\n     */\n    function getModulesPaginated(address start, uint256 pageSize)\n        external\n        view\n        returns (address[] memory array, address next);\n\n    /**\n     * @notice Enables the module `module` for the Safe.\n     * @dev This can only be done via a Safe transaction.\n     * @param module Module to be enabled.\n     */\n    function enableModule(address module) external;\n\n    /**\n     * @notice Returns the number of required confirmations for a Safe transaction aka the threshold.\n     * @return Threshold number.\n     */\n    function getThreshold() external view returns (uint256);\n\n    /**\n     * @notice Marks hash `hashToApprove` as approved.\n     * @dev This can be used with a pre-approved hash transaction signature.\n     *      IMPORTANT: The approved hash stays approved forever. There's no revocation mechanism, so it behaves similarly to ECDSA signatures\n     * @param hashToApprove The hash to mark as approved for signatures that are verified by this contract.\n     */\n    function approveHash(bytes32 hashToApprove) external;\n}\n"
    },
    "contracts/citrus-safe-modules/src/interfaces/ISafeProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport {ISafe} from \"./ISafe.sol\";\n\ninterface ISafeProxyFactory {\n    function createProxyWithNonce(address _singleton, bytes memory initializer, uint256 saltNonce)\n        external\n        returns (ISafe proxy);\n}\n"
    },
    "contracts/citrus-safe-modules/src/ModuleSetup.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport {ISafe} from \"./interfaces/ISafe.sol\";\n\n/**\n * @title ModuleSetup - A utility contract for setting up a Safe with modules.\n * @dev The Safe `setup` function accepts `to` and `data` parameters for a delegate call during initialization. This\n *      contract can be specified as the `to` with `data` ABI encoding the `enableModules` call so that a Safe is\n *      created with the specified modules.\n */\ncontract ModuleSetup {\n    constructor(address) {}\n\n    /**\n     * @notice Enable the specified Safe modules.\n     * @dev This call will only work if used from a Safe via delegatecall. It is intended to be used as part of the\n     *      Safe `setup`, allowing Safes to be created with an initial set of enabled modules.\n     * @param modules The modules to enable.\n     */\n    function enableModules(address[] calldata modules) external {\n        for (uint256 i = 0; i < modules.length; i++) {\n            ISafe(address(this)).enableModule(modules[i]);\n        }\n    }\n}\n"
    },
    "contracts/joe-core/contracts/traderjoe/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IERC20Joe {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n}\n"
    },
    "contracts/joe-core/contracts/traderjoe/interfaces/IJoeCallee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IJoeCallee {\n    function joeCall(\n        address sender,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/joe-core/contracts/traderjoe/interfaces/IJoeERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IJoeERC20 {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/joe-core/contracts/traderjoe/interfaces/IJoeFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IJoeFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function migrator() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n\n    function setMigrator(address) external;\n}\n"
    },
    "contracts/joe-core/contracts/traderjoe/interfaces/IJoePair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IJoePair {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/joe-core/contracts/traderjoe/interfaces/IJoeRouter01.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.6.2;\n\ninterface IJoeRouter01 {\n    function factory() external pure returns (address);\n\n    function WAVAX() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityAVAX(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountAVAX,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityAVAX(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountAVAX);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityAVAXWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountAVAX);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactAVAXForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactAVAX(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForAVAX(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapAVAXForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/joe-core/contracts/traderjoe/interfaces/IJoeRouter02.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.6.2;\n\nimport \"./IJoeRouter01.sol\";\n\ninterface IJoeRouter02 is IJoeRouter01 {\n    function removeLiquidityAVAXSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountAVAX);\n\n    function removeLiquidityAVAXWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountAVAX);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
    },
    "contracts/joe-core/contracts/traderjoe/interfaces/IWAVAX.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IWAVAX {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/joe-core/contracts/traderjoe/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending AVAX that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: APPROVE_FAILED\");\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FAILED\");\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransferAVAX(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, \"TransferHelper: AVAX_TRANSFER_FAILED\");\n    }\n}\n"
    },
    "contracts/joe-v2/lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "contracts/joe-v2/lib/openzeppelin-contracts/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "contracts/joe-v2/lib/openzeppelin-contracts/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "contracts/joe-v2/lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/joe-v2/lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\n * old one. This can help prevent common mistakes, such as transfers of ownership to\n * incorrect accounts, or to contracts that are unable to interact with the\n * permission system.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "contracts/joe-v2/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/joe-v2/lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/joe-v2/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/joe-v2/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/joe-v2/lib/openzeppelin-contracts/contracts/utils/structs/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableMap.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\n\npragma solidity ^0.8.20;\n\nimport {EnumerableSet} from \"./EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n * - `uint256 -> bytes32` (`UintToBytes32Map`) since v5.1.0\n * - `address -> address` (`AddressToAddressMap`) since v5.1.0\n * - `address -> bytes32` (`AddressToBytes32Map`) since v5.1.0\n * - `bytes32 -> address` (`Bytes32ToAddressMap`) since v5.1.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableMap.\n * ====\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code repetition as possible, we write it in\n    // terms of a generic Map type with bytes32 keys and values. The Map implementation uses private functions,\n    // and user-facing implementations such as `UintToAddressMap` are just wrappers around the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit in bytes32.\n\n    /**\n     * @dev Query for a nonexistent map key.\n     */\n    error EnumerableMapNonexistentKey(bytes32 key);\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 key => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        if (value == 0 && !contains(map, key)) {\n            revert EnumerableMapNonexistentKey(key);\n        }\n        return value;\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\n        return map._keys.values();\n    }\n\n    // UintToUintMap\n\n    struct UintToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key)));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintToBytes32Map\n\n    struct UintToBytes32Map {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToBytes32Map storage map, uint256 key, bytes32 value) internal returns (bool) {\n        return set(map._inner, bytes32(key), value);\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToBytes32Map storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToBytes32Map storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToBytes32Map storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToBytes32Map storage map, uint256 index) internal view returns (uint256, bytes32) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), value);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToBytes32Map storage map, uint256 key) internal view returns (bool, bytes32) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, value);\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToBytes32Map storage map, uint256 key) internal view returns (bytes32) {\n        return get(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToBytes32Map storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (address(uint160(uint256(key))), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressToAddressMap\n\n    struct AddressToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(AddressToAddressMap storage map, address key, address value) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToAddressMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToAddressMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToAddressMap storage map, uint256 index) internal view returns (address, address) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (address(uint160(uint256(key))), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToAddressMap storage map, address key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToAddressMap storage map, address key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(uint256(uint160(key)))))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(AddressToAddressMap storage map) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressToBytes32Map\n\n    struct AddressToBytes32Map {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(AddressToBytes32Map storage map, address key, bytes32 value) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), value);\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToBytes32Map storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToBytes32Map storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToBytes32Map storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToBytes32Map storage map, uint256 index) internal view returns (address, bytes32) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (address(uint160(uint256(key))), value);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToBytes32Map storage map, address key) internal view returns (bool, bytes32) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, value);\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToBytes32Map storage map, address key) internal view returns (bytes32) {\n        return get(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(AddressToBytes32Map storage map) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // Bytes32ToUintMap\n\n    struct Bytes32ToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\n        return set(map._inner, key, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n        return remove(map._inner, key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (key, uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, key);\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n        return uint256(get(map._inner, key));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // Bytes32ToAddressMap\n\n    struct Bytes32ToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToAddressMap storage map, bytes32 key, address value) internal returns (bool) {\n        return set(map._inner, key, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToAddressMap storage map, bytes32 key) internal returns (bool) {\n        return remove(map._inner, key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToAddressMap storage map, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToAddressMap storage map, uint256 index) internal view returns (bytes32, address) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (key, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToAddressMap storage map, bytes32 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = tryGet(map._inner, key);\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToAddressMap storage map, bytes32 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, key))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToAddressMap storage map) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/joe-v2/lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/joe-v2/src/interfaces/IJoeFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\n/// @title Joe V1 Factory Interface\n/// @notice Interface to interact with Joe V1 Factory\ninterface IJoeFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function migrator() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n\n    function setMigrator(address) external;\n}\n"
    },
    "contracts/joe-v2/src/interfaces/IJoePair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\n/// @title Joe V1 Pair Interface\n/// @notice Interface to interact with Joe V1 Pairs\ninterface IJoePair {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/joe-v2/src/interfaces/IJoeRouter01.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\n/// @title Joe V1 Router01 Interface\n/// @notice Interface to interact with Joe V1 Router\ninterface IJoeRouter01 {\n    function factory() external pure returns (address);\n\n    function WAVAX() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n    function addLiquidityAVAX(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256 amountToken, uint256 amountAVAX, uint256 liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityAVAX(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountAVAX);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityAVAXWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountAVAX);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactAVAXForTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline)\n        external\n        payable\n        returns (uint256[] memory amounts);\n\n    function swapTokensForExactAVAX(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForAVAX(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapAVAXForExactTokens(uint256 amountOut, address[] calldata path, address to, uint256 deadline)\n        external\n        payable\n        returns (uint256[] memory amounts);\n\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint256 amountB);\n\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        external\n        pure\n        returns (uint256 amountOut);\n\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        external\n        pure\n        returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/joe-v2/src/interfaces/IJoeRouter02.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\nimport {IJoeRouter01} from \"./IJoeRouter01.sol\";\n\n/// @title Joe V1 Router Interface\n/// @notice Interface to interact with Joe V1 Router\ninterface IJoeRouter02 is IJoeRouter01 {\n    function removeLiquidityAVAXSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountAVAX);\n\n    function removeLiquidityAVAXWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountAVAX);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
    },
    "contracts/joe-v2/src/interfaces/ILBFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\nimport {ILBHooks} from \"./ILBHooks.sol\";\nimport {ILBPair} from \"./ILBPair.sol\";\n\n/**\n * @title Liquidity Book Factory Interface\n * @author Trader Joe\n * @notice Required interface of LBFactory contract\n */\ninterface ILBFactory {\n    error LBFactory__IdenticalAddresses(IERC20 token);\n    error LBFactory__AddressZero();\n    error LBFactory__LBPairAlreadyExists(IERC20 tokenX, IERC20 tokenY, uint256 _binStep);\n    error LBFactory__LBPairDoesNotExist(IERC20 tokenX, IERC20 tokenY, uint256 binStep);\n    error LBFactory__LBPairNotCreated(IERC20 tokenX, IERC20 tokenY, uint256 binStep);\n    error LBFactory__FlashLoanFeeAboveMax(uint256 fees, uint256 maxFees);\n    error LBFactory__BinStepTooLow(uint256 binStep);\n    error LBFactory__PresetIsLockedForUsers(address user, uint256 binStep);\n    error LBFactory__LBPairIgnoredIsAlreadyInTheSameState();\n    error LBFactory__BinStepHasNoPreset(uint256 binStep);\n    error LBFactory__PresetOpenStateIsAlreadyInTheSameState();\n    error LBFactory__SameFeeRecipient(address feeRecipient);\n    error LBFactory__SameFlashLoanFee(uint256 flashLoanFee);\n    error LBFactory__LBPairSafetyCheckFailed(address LBPairImplementation);\n    error LBFactory__SameImplementation(address LBPairImplementation);\n    error LBFactory__ImplementationNotSet();\n    error LBFactory__SameHooksImplementation(address hooksImplementation);\n    error LBFactory__SameHooksParameters(bytes32 hooksParameters);\n    error LBFactory__InvalidHooksParameters();\n    error LBFactory__CannotGrantDefaultAdminRole();\n\n    /**\n     * @dev Structure to store the LBPair information, such as:\n     * binStep: The bin step of the LBPair\n     * LBPair: The address of the LBPair\n     * createdByOwner: Whether the pair was created by the owner of the factory\n     * ignoredForRouting: Whether the pair is ignored for routing or not. An ignored pair will not be explored during routes finding\n     */\n    struct LBPairInformation {\n        uint16 binStep;\n        ILBPair LBPair;\n        bool createdByOwner;\n        bool ignoredForRouting;\n    }\n\n    event LBPairCreated(\n        IERC20 indexed tokenX, IERC20 indexed tokenY, uint256 indexed binStep, ILBPair LBPair, uint256 pid\n    );\n\n    event FeeRecipientSet(address oldRecipient, address newRecipient);\n\n    event FlashLoanFeeSet(uint256 oldFlashLoanFee, uint256 newFlashLoanFee);\n\n    event LBPairImplementationSet(address oldLBPairImplementation, address LBPairImplementation);\n\n    event LBPairIgnoredStateChanged(ILBPair indexed LBPair, bool ignored);\n\n    event PresetSet(\n        uint256 indexed binStep,\n        uint256 baseFactor,\n        uint256 filterPeriod,\n        uint256 decayPeriod,\n        uint256 reductionFactor,\n        uint256 variableFeeControl,\n        uint256 protocolShare,\n        uint256 maxVolatilityAccumulator\n    );\n\n    event PresetOpenStateChanged(uint256 indexed binStep, bool indexed isOpen);\n\n    event PresetRemoved(uint256 indexed binStep);\n\n    function getMinBinStep() external pure returns (uint256);\n\n    function getFeeRecipient() external view returns (address);\n\n    function getMaxFlashLoanFee() external pure returns (uint256);\n\n    function getFlashLoanFee() external view returns (uint256);\n\n    function getLBPairImplementation() external view returns (address);\n\n    function getNumberOfLBPairs() external view returns (uint256);\n\n    function getLBPairAtIndex(uint256 id) external returns (ILBPair);\n\n    function getLBPairInformation(IERC20 tokenX, IERC20 tokenY, uint256 binStep)\n        external\n        view\n        returns (LBPairInformation memory);\n\n    function getPreset(uint256 binStep)\n        external\n        view\n        returns (\n            uint256 baseFactor,\n            uint256 filterPeriod,\n            uint256 decayPeriod,\n            uint256 reductionFactor,\n            uint256 variableFeeControl,\n            uint256 protocolShare,\n            uint256 maxAccumulator,\n            bool isOpen\n        );\n\n    function getAllBinSteps() external view returns (uint256[] memory presetsBinStep);\n\n    function getOpenBinSteps() external view returns (uint256[] memory openBinStep);\n\n    function getAllLBPairs(IERC20 tokenX, IERC20 tokenY)\n        external\n        view\n        returns (LBPairInformation[] memory LBPairsBinStep);\n\n    function setLBPairImplementation(address lbPairImplementation) external;\n\n    function createLBPair(IERC20 tokenX, IERC20 tokenY, uint24 activeId, uint16 binStep)\n        external\n        returns (ILBPair pair);\n\n    function setLBPairIgnored(IERC20 tokenX, IERC20 tokenY, uint16 binStep, bool ignored) external;\n\n    function setPreset(\n        uint16 binStep,\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator,\n        bool isOpen\n    ) external;\n\n    function setPresetOpenState(uint16 binStep, bool isOpen) external;\n\n    function removePreset(uint16 binStep) external;\n\n    function setFeesParametersOnPair(\n        IERC20 tokenX,\n        IERC20 tokenY,\n        uint16 binStep,\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator\n    ) external;\n\n    function setLBHooksParametersOnPair(\n        IERC20 tokenX,\n        IERC20 tokenY,\n        uint16 binStep,\n        bytes32 hooksParameters,\n        bytes memory onHooksSetData\n    ) external;\n\n    function removeLBHooksOnPair(IERC20 tokenX, IERC20 tokenY, uint16 binStep) external;\n\n    function setFeeRecipient(address feeRecipient) external;\n\n    function setFlashLoanFee(uint256 flashLoanFee) external;\n\n    function forceDecay(ILBPair lbPair) external;\n}\n"
    },
    "contracts/joe-v2/src/interfaces/ILBFlashLoanCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Liquidity Book Flashloan Callback Interface\n/// @author Trader Joe\n/// @notice Required interface to interact with LB flash loans\ninterface ILBFlashLoanCallback {\n    function LBFlashLoanCallback(\n        address sender,\n        IERC20 tokenX,\n        IERC20 tokenY,\n        bytes32 amounts,\n        bytes32 totalFees,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "contracts/joe-v2/src/interfaces/ILBHooks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {ILBPair} from \"./ILBPair.sol\";\n\nimport {Hooks} from \"../libraries/Hooks.sol\";\n\ninterface ILBHooks {\n    function getLBPair() external view returns (ILBPair);\n\n    function isLinked() external view returns (bool);\n\n    function onHooksSet(bytes32 hooksParameters, bytes calldata onHooksSetData) external returns (bytes4);\n\n    function beforeSwap(address sender, address to, bool swapForY, bytes32 amountsIn) external returns (bytes4);\n\n    function afterSwap(address sender, address to, bool swapForY, bytes32 amountsOut) external returns (bytes4);\n\n    function beforeFlashLoan(address sender, address to, bytes32 amounts) external returns (bytes4);\n\n    function afterFlashLoan(address sender, address to, bytes32 fees, bytes32 feesReceived) external returns (bytes4);\n\n    function beforeMint(address sender, address to, bytes32[] calldata liquidityConfigs, bytes32 amountsReceived)\n        external\n        returns (bytes4);\n\n    function afterMint(address sender, address to, bytes32[] calldata liquidityConfigs, bytes32 amountsIn)\n        external\n        returns (bytes4);\n\n    function beforeBurn(\n        address sender,\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amountsToBurn\n    ) external returns (bytes4);\n\n    function afterBurn(\n        address sender,\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amountsToBurn\n    ) external returns (bytes4);\n\n    function beforeBatchTransferFrom(\n        address sender,\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external returns (bytes4);\n\n    function afterBatchTransferFrom(\n        address sender,\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/joe-v2/src/interfaces/ILBLegacyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\nimport {ILBLegacyPair} from \"./ILBLegacyPair.sol\";\n\n/// @title Liquidity Book Factory Interface\n/// @author Trader Joe\n/// @notice Required interface of LBFactory contract\ninterface ILBLegacyFactory {\n    /// @dev Structure to store the LBPair information, such as:\n    /// - binStep: The bin step of the LBPair\n    /// - LBPair: The address of the LBPair\n    /// - createdByOwner: Whether the pair was created by the owner of the factory\n    /// - ignoredForRouting: Whether the pair is ignored for routing or not. An ignored pair will not be explored during routes finding\n    struct LBPairInformation {\n        uint16 binStep;\n        ILBLegacyPair LBPair;\n        bool createdByOwner;\n        bool ignoredForRouting;\n    }\n\n    event LBPairCreated(\n        IERC20 indexed tokenX, IERC20 indexed tokenY, uint256 indexed binStep, ILBLegacyPair LBPair, uint256 pid\n    );\n\n    event FeeRecipientSet(address oldRecipient, address newRecipient);\n\n    event FlashLoanFeeSet(uint256 oldFlashLoanFee, uint256 newFlashLoanFee);\n\n    event FeeParametersSet(\n        address indexed sender,\n        ILBLegacyPair indexed LBPair,\n        uint256 binStep,\n        uint256 baseFactor,\n        uint256 filterPeriod,\n        uint256 decayPeriod,\n        uint256 reductionFactor,\n        uint256 variableFeeControl,\n        uint256 protocolShare,\n        uint256 maxVolatilityAccumulator\n    );\n\n    event FactoryLockedStatusUpdated(bool unlocked);\n\n    event LBPairImplementationSet(address oldLBPairImplementation, address LBPairImplementation);\n\n    event LBPairIgnoredStateChanged(ILBLegacyPair indexed LBPair, bool ignored);\n\n    event PresetSet(\n        uint256 indexed binStep,\n        uint256 baseFactor,\n        uint256 filterPeriod,\n        uint256 decayPeriod,\n        uint256 reductionFactor,\n        uint256 variableFeeControl,\n        uint256 protocolShare,\n        uint256 maxVolatilityAccumulator,\n        uint256 sampleLifetime\n    );\n\n    event PresetRemoved(uint256 indexed binStep);\n\n    event QuoteAssetAdded(IERC20 indexed quoteAsset);\n\n    event QuoteAssetRemoved(IERC20 indexed quoteAsset);\n\n    function MAX_FEE() external pure returns (uint256);\n\n    function MIN_BIN_STEP() external pure returns (uint256);\n\n    function MAX_BIN_STEP() external pure returns (uint256);\n\n    function MAX_PROTOCOL_SHARE() external pure returns (uint256);\n\n    function LBPairImplementation() external view returns (address);\n\n    function getNumberOfQuoteAssets() external view returns (uint256);\n\n    function getQuoteAsset(uint256 index) external view returns (IERC20);\n\n    function isQuoteAsset(IERC20 token) external view returns (bool);\n\n    function feeRecipient() external view returns (address);\n\n    function flashLoanFee() external view returns (uint256);\n\n    function creationUnlocked() external view returns (bool);\n\n    function allLBPairs(uint256 id) external returns (ILBLegacyPair);\n\n    function getNumberOfLBPairs() external view returns (uint256);\n\n    function getLBPairInformation(IERC20 tokenX, IERC20 tokenY, uint256 binStep)\n        external\n        view\n        returns (LBPairInformation memory);\n\n    function getPreset(uint16 binStep)\n        external\n        view\n        returns (\n            uint256 baseFactor,\n            uint256 filterPeriod,\n            uint256 decayPeriod,\n            uint256 reductionFactor,\n            uint256 variableFeeControl,\n            uint256 protocolShare,\n            uint256 maxAccumulator,\n            uint256 sampleLifetime\n        );\n\n    function getAllBinSteps() external view returns (uint256[] memory presetsBinStep);\n\n    function getAllLBPairs(IERC20 tokenX, IERC20 tokenY)\n        external\n        view\n        returns (LBPairInformation[] memory LBPairsBinStep);\n\n    function setLBPairImplementation(address LBPairImplementation) external;\n\n    function createLBPair(IERC20 tokenX, IERC20 tokenY, uint24 activeId, uint16 binStep)\n        external\n        returns (ILBLegacyPair pair);\n\n    function setLBPairIgnored(IERC20 tokenX, IERC20 tokenY, uint256 binStep, bool ignored) external;\n\n    function setPreset(\n        uint16 binStep,\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator,\n        uint16 sampleLifetime\n    ) external;\n\n    function removePreset(uint16 binStep) external;\n\n    function setFeesParametersOnPair(\n        IERC20 tokenX,\n        IERC20 tokenY,\n        uint16 binStep,\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator\n    ) external;\n\n    function setFeeRecipient(address feeRecipient) external;\n\n    function setFlashLoanFee(uint256 flashLoanFee) external;\n\n    function setFactoryLockedState(bool locked) external;\n\n    function addQuoteAsset(IERC20 quoteAsset) external;\n\n    function removeQuoteAsset(IERC20 quoteAsset) external;\n\n    function forceDecay(ILBLegacyPair LBPair) external;\n}\n"
    },
    "contracts/joe-v2/src/interfaces/ILBLegacyPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\nimport {ILBLegacyToken} from \"./ILBLegacyToken.sol\";\n\n/// @title Liquidity Book Pair V2 Interface\n/// @author Trader Joe\n/// @notice Required interface of LBPair contract\ninterface ILBLegacyPair is ILBLegacyToken {\n    /// @dev Structure to store the protocol fees:\n    /// - binStep: The bin step\n    /// - baseFactor: The base factor\n    /// - filterPeriod: The filter period, where the fees stays constant\n    /// - decayPeriod: The decay period, where the fees are halved\n    /// - reductionFactor: The reduction factor, used to calculate the reduction of the accumulator\n    /// - variableFeeControl: The variable fee control, used to control the variable fee, can be 0 to disable them\n    /// - protocolShare: The share of fees sent to protocol\n    /// - maxVolatilityAccumulated: The max value of volatility accumulated\n    /// - volatilityAccumulated: The value of volatility accumulated\n    /// - volatilityReference: The value of volatility reference\n    /// - indexRef: The index reference\n    /// - time: The last time the accumulator was called\n    struct FeeParameters {\n        // 144 lowest bits in slot\n        uint16 binStep;\n        uint16 baseFactor;\n        uint16 filterPeriod;\n        uint16 decayPeriod;\n        uint16 reductionFactor;\n        uint24 variableFeeControl;\n        uint16 protocolShare;\n        uint24 maxVolatilityAccumulated;\n        // 112 highest bits in slot\n        uint24 volatilityAccumulated;\n        uint24 volatilityReference;\n        uint24 indexRef;\n        uint40 time;\n    }\n\n    /// @dev Structure used during swaps to distributes the fees:\n    /// - total: The total amount of fees\n    /// - protocol: The amount of fees reserved for protocol\n    struct FeesDistribution {\n        uint128 total;\n        uint128 protocol;\n    }\n\n    /// @dev Structure to store the reserves of bins:\n    /// - reserveX: The current reserve of tokenX of the bin\n    /// - reserveY: The current reserve of tokenY of the bin\n    struct Bin {\n        uint112 reserveX;\n        uint112 reserveY;\n        uint256 accTokenXPerShare;\n        uint256 accTokenYPerShare;\n    }\n\n    /// @dev Structure to store the information of the pair such as:\n    /// slot0:\n    /// - activeId: The current id used for swaps, this is also linked with the price\n    /// - reserveX: The sum of amounts of tokenX across all bins\n    /// slot1:\n    /// - reserveY: The sum of amounts of tokenY across all bins\n    /// - oracleSampleLifetime: The lifetime of an oracle sample\n    /// - oracleSize: The current size of the oracle, can be increase by users\n    /// - oracleActiveSize: The current active size of the oracle, composed only from non empty data sample\n    /// - oracleLastTimestamp: The current last timestamp at which a sample was added to the circular buffer\n    /// - oracleId: The current id of the oracle\n    /// slot2:\n    /// - feesX: The current amount of fees to distribute in tokenX (total, protocol)\n    /// slot3:\n    /// - feesY: The current amount of fees to distribute in tokenY (total, protocol)\n    struct PairInformation {\n        uint24 activeId;\n        uint136 reserveX;\n        uint136 reserveY;\n        uint16 oracleSampleLifetime;\n        uint16 oracleSize;\n        uint16 oracleActiveSize;\n        uint40 oracleLastTimestamp;\n        uint16 oracleId;\n        FeesDistribution feesX;\n        FeesDistribution feesY;\n    }\n\n    /// @dev Structure to store the debts of users\n    /// - debtX: The tokenX's debt\n    /// - debtY: The tokenY's debt\n    struct Debts {\n        uint256 debtX;\n        uint256 debtY;\n    }\n\n    /// @dev Structure to store fees:\n    /// - tokenX: The amount of fees of token X\n    /// - tokenY: The amount of fees of token Y\n    struct Fees {\n        uint128 tokenX;\n        uint128 tokenY;\n    }\n\n    /// @dev Structure to minting informations:\n    /// - amountXIn: The amount of token X sent\n    /// - amountYIn: The amount of token Y sent\n    /// - amountXAddedToPair: The amount of token X that have been actually added to the pair\n    /// - amountYAddedToPair: The amount of token Y that have been actually added to the pair\n    /// - activeFeeX: Fees X currently generated\n    /// - activeFeeY: Fees Y currently generated\n    /// - totalDistributionX: Total distribution of token X. Should be 1e18 (100%) or 0 (0%)\n    /// - totalDistributionY: Total distribution of token Y. Should be 1e18 (100%) or 0 (0%)\n    /// - id: Id of the current working bin when looping on the distribution array\n    /// - amountX: The amount of token X deposited in the current bin\n    /// - amountY: The amount of token Y deposited in the current bin\n    /// - distributionX: Distribution of token X for the current working bin\n    /// - distributionY: Distribution of token Y for the current working bin\n    struct MintInfo {\n        uint256 amountXIn;\n        uint256 amountYIn;\n        uint256 amountXAddedToPair;\n        uint256 amountYAddedToPair;\n        uint256 activeFeeX;\n        uint256 activeFeeY;\n        uint256 totalDistributionX;\n        uint256 totalDistributionY;\n        uint256 id;\n        uint256 amountX;\n        uint256 amountY;\n        uint256 distributionX;\n        uint256 distributionY;\n    }\n\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        uint256 indexed id,\n        bool swapForY,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 volatilityAccumulated,\n        uint256 fees\n    );\n\n    event FlashLoan(address indexed sender, address indexed receiver, IERC20 token, uint256 amount, uint256 fee);\n\n    event CompositionFee(\n        address indexed sender, address indexed recipient, uint256 indexed id, uint256 feesX, uint256 feesY\n    );\n\n    event DepositedToBin(\n        address indexed sender, address indexed recipient, uint256 indexed id, uint256 amountX, uint256 amountY\n    );\n\n    event WithdrawnFromBin(\n        address indexed sender, address indexed recipient, uint256 indexed id, uint256 amountX, uint256 amountY\n    );\n\n    event FeesCollected(address indexed sender, address indexed recipient, uint256 amountX, uint256 amountY);\n\n    event ProtocolFeesCollected(address indexed sender, address indexed recipient, uint256 amountX, uint256 amountY);\n\n    event OracleSizeIncreased(uint256 previousSize, uint256 newSize);\n\n    function tokenX() external view returns (IERC20);\n\n    function tokenY() external view returns (IERC20);\n\n    function factory() external view returns (address);\n\n    function getReservesAndId() external view returns (uint256 reserveX, uint256 reserveY, uint256 activeId);\n\n    function getGlobalFees()\n        external\n        view\n        returns (uint128 feesXTotal, uint128 feesYTotal, uint128 feesXProtocol, uint128 feesYProtocol);\n\n    function getOracleParameters()\n        external\n        view\n        returns (\n            uint256 oracleSampleLifetime,\n            uint256 oracleSize,\n            uint256 oracleActiveSize,\n            uint256 oracleLastTimestamp,\n            uint256 oracleId,\n            uint256 min,\n            uint256 max\n        );\n\n    function getOracleSampleFrom(uint256 timeDelta)\n        external\n        view\n        returns (uint256 cumulativeId, uint256 cumulativeAccumulator, uint256 cumulativeBinCrossed);\n\n    function feeParameters() external view returns (FeeParameters memory);\n\n    function findFirstNonEmptyBinId(uint24 id_, bool sentTokenY) external view returns (uint24 id);\n\n    function getBin(uint24 id) external view returns (uint256 reserveX, uint256 reserveY);\n\n    function pendingFees(address account, uint256[] memory ids)\n        external\n        view\n        returns (uint256 amountX, uint256 amountY);\n\n    function swap(bool sentTokenY, address to) external returns (uint256 amountXOut, uint256 amountYOut);\n\n    function flashLoan(address receiver, IERC20 token, uint256 amount, bytes calldata data) external;\n\n    function mint(\n        uint256[] calldata ids,\n        uint256[] calldata distributionX,\n        uint256[] calldata distributionY,\n        address to\n    ) external returns (uint256 amountXAddedToPair, uint256 amountYAddedToPair, uint256[] memory liquidityMinted);\n\n    function burn(uint256[] calldata ids, uint256[] calldata amounts, address to)\n        external\n        returns (uint256 amountX, uint256 amountY);\n\n    function increaseOracleLength(uint16 newSize) external;\n\n    function collectFees(address account, uint256[] calldata ids) external returns (uint256 amountX, uint256 amountY);\n\n    function collectProtocolFees() external returns (uint128 amountX, uint128 amountY);\n\n    function setFeesParameters(bytes32 packedFeeParameters) external;\n\n    function forceDecay() external;\n\n    function initialize(\n        IERC20 tokenX,\n        IERC20 tokenY,\n        uint24 activeId,\n        uint16 sampleLifetime,\n        bytes32 packedFeeParameters\n    ) external;\n}\n"
    },
    "contracts/joe-v2/src/interfaces/ILBLegacyRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\nimport {ILBFactory} from \"./ILBFactory.sol\";\nimport {IJoeFactory} from \"./IJoeFactory.sol\";\nimport {ILBLegacyPair} from \"./ILBLegacyPair.sol\";\nimport {ILBToken} from \"./ILBToken.sol\";\nimport {IWNATIVE} from \"./IWNATIVE.sol\";\n\n/// @title Liquidity Book Router Interface\n/// @author Trader Joe\n/// @notice Required interface of LBRouter contract\ninterface ILBLegacyRouter {\n    struct LiquidityParameters {\n        IERC20 tokenX;\n        IERC20 tokenY;\n        uint256 binStep;\n        uint256 amountX;\n        uint256 amountY;\n        uint256 amountXMin;\n        uint256 amountYMin;\n        uint256 activeIdDesired;\n        uint256 idSlippage;\n        int256[] deltaIds;\n        uint256[] distributionX;\n        uint256[] distributionY;\n        address to;\n        uint256 deadline;\n    }\n\n    function factory() external view returns (address);\n\n    function wavax() external view returns (address);\n\n    function oldFactory() external view returns (address);\n\n    function getIdFromPrice(ILBLegacyPair LBPair, uint256 price) external view returns (uint24);\n\n    function getPriceFromId(ILBLegacyPair LBPair, uint24 id) external view returns (uint256);\n\n    function getSwapIn(ILBLegacyPair lbPair, uint256 amountOut, bool swapForY)\n        external\n        view\n        returns (uint256 amountIn, uint256 feesIn);\n\n    function getSwapOut(ILBLegacyPair lbPair, uint256 amountIn, bool swapForY)\n        external\n        view\n        returns (uint256 amountOut, uint256 feesIn);\n\n    function createLBPair(IERC20 tokenX, IERC20 tokenY, uint24 activeId, uint16 binStep)\n        external\n        returns (ILBLegacyPair pair);\n\n    function addLiquidity(LiquidityParameters calldata liquidityParameters)\n        external\n        returns (uint256[] memory depositIds, uint256[] memory liquidityMinted);\n\n    function addLiquidityAVAX(LiquidityParameters calldata liquidityParameters)\n        external\n        payable\n        returns (uint256[] memory depositIds, uint256[] memory liquidityMinted);\n\n    function removeLiquidity(\n        IERC20 tokenX,\n        IERC20 tokenY,\n        uint16 binStep,\n        uint256 amountXMin,\n        uint256 amountYMin,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountX, uint256 amountY);\n\n    function removeLiquidityAVAX(\n        IERC20 token,\n        uint16 binStep,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountAVAX);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactTokensForAVAX(\n        uint256 amountIn,\n        uint256 amountOutMinAVAX,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactAVAXForTokens(\n        uint256 amountOutMin,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256 amountOut);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amountsIn);\n\n    function swapTokensForExactAVAX(\n        uint256 amountOut,\n        uint256 amountInMax,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256[] memory amountsIn);\n\n    function swapAVAXForExactTokens(\n        uint256 amountOut,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amountsIn);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMinAVAX,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256 amountOut);\n\n    function sweep(IERC20 token, address to, uint256 amount) external;\n\n    function sweepLBToken(ILBToken _lbToken, address _to, uint256[] calldata _ids, uint256[] calldata _amounts)\n        external;\n}\n"
    },
    "contracts/joe-v2/src/interfaces/ILBLegacyToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../../lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\";\n\n/// @title Liquidity Book V2 Token Interface\n/// @author Trader Joe\n/// @notice Required interface of LBToken contract\ninterface ILBLegacyToken is IERC165 {\n    event TransferSingle(address indexed sender, address indexed from, address indexed to, uint256 id, uint256 amount);\n\n    event TransferBatch(\n        address indexed sender, address indexed from, address indexed to, uint256[] ids, uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed account, address indexed sender, bool approved);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory batchBalances);\n\n    function totalSupply(uint256 id) external view returns (uint256);\n\n    function isApprovedForAll(address owner, address spender) external view returns (bool);\n\n    function setApprovalForAll(address sender, bool approved) external;\n\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount) external;\n\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata id, uint256[] calldata amount)\n        external;\n}\n"
    },
    "contracts/joe-v2/src/interfaces/ILBPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\nimport {Hooks} from \"../libraries/Hooks.sol\";\nimport {ILBFactory} from \"./ILBFactory.sol\";\nimport {ILBFlashLoanCallback} from \"./ILBFlashLoanCallback.sol\";\nimport {ILBToken} from \"./ILBToken.sol\";\n\ninterface ILBPair is ILBToken {\n    error LBPair__ZeroBorrowAmount();\n    error LBPair__AddressZero();\n    error LBPair__EmptyMarketConfigs();\n    error LBPair__FlashLoanCallbackFailed();\n    error LBPair__FlashLoanInsufficientAmount();\n    error LBPair__InsufficientAmountIn();\n    error LBPair__InsufficientAmountOut();\n    error LBPair__InvalidInput();\n    error LBPair__InvalidStaticFeeParameters();\n    error LBPair__OnlyFactory();\n    error LBPair__OnlyProtocolFeeRecipient();\n    error LBPair__OutOfLiquidity();\n    error LBPair__TokenNotSupported();\n    error LBPair__ZeroAmount(uint24 id);\n    error LBPair__ZeroAmountsOut(uint24 id);\n    error LBPair__ZeroShares(uint24 id);\n    error LBPair__MaxTotalFeeExceeded();\n    error LBPair__InvalidHooks();\n\n    struct MintArrays {\n        uint256[] ids;\n        bytes32[] amounts;\n        uint256[] liquidityMinted;\n    }\n\n    event DepositedToBins(address indexed sender, address indexed to, uint256[] ids, bytes32[] amounts);\n\n    event WithdrawnFromBins(address indexed sender, address indexed to, uint256[] ids, bytes32[] amounts);\n\n    event CompositionFees(address indexed sender, uint24 id, bytes32 totalFees, bytes32 protocolFees);\n\n    event CollectedProtocolFees(address indexed feeRecipient, bytes32 protocolFees);\n\n    event Swap(\n        address indexed sender,\n        address indexed to,\n        uint24 id,\n        bytes32 amountsIn,\n        bytes32 amountsOut,\n        uint24 volatilityAccumulator,\n        bytes32 totalFees,\n        bytes32 protocolFees\n    );\n\n    event StaticFeeParametersSet(\n        address indexed sender,\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator\n    );\n\n    event HooksParametersSet(address indexed sender, bytes32 hooksParameters);\n\n    event FlashLoan(\n        address indexed sender,\n        ILBFlashLoanCallback indexed receiver,\n        uint24 activeId,\n        bytes32 amounts,\n        bytes32 totalFees,\n        bytes32 protocolFees\n    );\n\n    event OracleLengthIncreased(address indexed sender, uint16 oracleLength);\n\n    event ForcedDecay(address indexed sender, uint24 idReference, uint24 volatilityReference);\n\n    function initialize(\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator,\n        uint24 activeId\n    ) external;\n\n    function implementation() external view returns (address);\n\n    function getFactory() external view returns (ILBFactory factory);\n\n    function getTokenX() external view returns (IERC20 tokenX);\n\n    function getTokenY() external view returns (IERC20 tokenY);\n\n    function getBinStep() external view returns (uint16 binStep);\n\n    function getReserves() external view returns (uint128 reserveX, uint128 reserveY);\n\n    function getActiveId() external view returns (uint24 activeId);\n\n    function getBin(uint24 id) external view returns (uint128 binReserveX, uint128 binReserveY);\n\n    function getNextNonEmptyBin(bool swapForY, uint24 id) external view returns (uint24 nextId);\n\n    function getProtocolFees() external view returns (uint128 protocolFeeX, uint128 protocolFeeY);\n\n    function getStaticFeeParameters()\n        external\n        view\n        returns (\n            uint16 baseFactor,\n            uint16 filterPeriod,\n            uint16 decayPeriod,\n            uint16 reductionFactor,\n            uint24 variableFeeControl,\n            uint16 protocolShare,\n            uint24 maxVolatilityAccumulator\n        );\n\n    function getLBHooksParameters() external view returns (bytes32 hooksParameters);\n\n    function getVariableFeeParameters()\n        external\n        view\n        returns (uint24 volatilityAccumulator, uint24 volatilityReference, uint24 idReference, uint40 timeOfLastUpdate);\n\n    function getOracleParameters()\n        external\n        view\n        returns (uint8 sampleLifetime, uint16 size, uint16 activeSize, uint40 lastUpdated, uint40 firstTimestamp);\n\n    function getOracleSampleAt(uint40 lookupTimestamp)\n        external\n        view\n        returns (uint64 cumulativeId, uint64 cumulativeVolatility, uint64 cumulativeBinCrossed);\n\n    function getPriceFromId(uint24 id) external view returns (uint256 price);\n\n    function getIdFromPrice(uint256 price) external view returns (uint24 id);\n\n    function getSwapIn(uint128 amountOut, bool swapForY)\n        external\n        view\n        returns (uint128 amountIn, uint128 amountOutLeft, uint128 fee);\n\n    function getSwapOut(uint128 amountIn, bool swapForY)\n        external\n        view\n        returns (uint128 amountInLeft, uint128 amountOut, uint128 fee);\n\n    function swap(bool swapForY, address to) external returns (bytes32 amountsOut);\n\n    function flashLoan(ILBFlashLoanCallback receiver, bytes32 amounts, bytes calldata data) external;\n\n    function mint(address to, bytes32[] calldata liquidityConfigs, address refundTo)\n        external\n        returns (bytes32 amountsReceived, bytes32 amountsLeft, uint256[] memory liquidityMinted);\n\n    function burn(address from, address to, uint256[] calldata ids, uint256[] calldata amountsToBurn)\n        external\n        returns (bytes32[] memory amounts);\n\n    function collectProtocolFees() external returns (bytes32 collectedProtocolFees);\n\n    function increaseOracleLength(uint16 newLength) external;\n\n    function setStaticFeeParameters(\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator\n    ) external;\n\n    function setHooksParameters(bytes32 hooksParameters, bytes calldata onHooksSetData) external;\n\n    function forceDecay() external;\n}\n"
    },
    "contracts/joe-v2/src/interfaces/ILBRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\nimport {IJoeFactory} from \"./IJoeFactory.sol\";\nimport {ILBFactory} from \"./ILBFactory.sol\";\nimport {ILBLegacyFactory} from \"./ILBLegacyFactory.sol\";\nimport {ILBLegacyRouter} from \"./ILBLegacyRouter.sol\";\nimport {ILBPair} from \"./ILBPair.sol\";\nimport {ILBToken} from \"./ILBToken.sol\";\nimport {IWNATIVE} from \"./IWNATIVE.sol\";\n\n/**\n * @title Liquidity Book Router Interface\n * @author Trader Joe\n * @notice Required interface of LBRouter contract\n */\ninterface ILBRouter {\n    error LBRouter__SenderIsNotWNATIVE();\n    error LBRouter__PairNotCreated(address tokenX, address tokenY, uint256 binStep);\n    error LBRouter__WrongAmounts(uint256 amount, uint256 reserve);\n    error LBRouter__SwapOverflows(uint256 id);\n    error LBRouter__BrokenSwapSafetyCheck();\n    error LBRouter__NotFactoryOwner();\n    error LBRouter__TooMuchTokensIn(uint256 excess);\n    error LBRouter__BinReserveOverflows(uint256 id);\n    error LBRouter__IdOverflows(int256 id);\n    error LBRouter__LengthsMismatch();\n    error LBRouter__WrongTokenOrder();\n    error LBRouter__IdSlippageCaught(uint256 activeIdDesired, uint256 idSlippage, uint256 activeId);\n    error LBRouter__AmountSlippageCaught(uint256 amountXMin, uint256 amountX, uint256 amountYMin, uint256 amountY);\n    error LBRouter__IdDesiredOverflows(uint256 idDesired, uint256 idSlippage);\n    error LBRouter__FailedToSendNATIVE(address recipient, uint256 amount);\n    error LBRouter__DeadlineExceeded(uint256 deadline, uint256 currentTimestamp);\n    error LBRouter__AmountSlippageBPTooBig(uint256 amountSlippage);\n    error LBRouter__InsufficientAmountOut(uint256 amountOutMin, uint256 amountOut);\n    error LBRouter__MaxAmountInExceeded(uint256 amountInMax, uint256 amountIn);\n    error LBRouter__InvalidTokenPath(address wrongToken);\n    error LBRouter__InvalidVersion(uint256 version);\n    error LBRouter__WrongNativeLiquidityParameters(\n        address tokenX, address tokenY, uint256 amountX, uint256 amountY, uint256 msgValue\n    );\n\n    /**\n     * @dev This enum represents the version of the pair requested\n     * - V1: Joe V1 pair\n     * - V2: LB pair V2. Also called legacyPair\n     * - V2_1: LB pair V2.1\n     * - V2_2: LB pair V2.2 (current version)\n     */\n    enum Version {\n        V1,\n        V2,\n        V2_1,\n        V2_2\n    }\n\n    /**\n     * @dev The liquidity parameters, such as:\n     * - tokenX: The address of token X\n     * - tokenY: The address of token Y\n     * - binStep: The bin step of the pair\n     * - amountX: The amount to send of token X\n     * - amountY: The amount to send of token Y\n     * - amountXMin: The min amount of token X added to liquidity\n     * - amountYMin: The min amount of token Y added to liquidity\n     * - activeIdDesired: The active id that user wants to add liquidity from\n     * - idSlippage: The number of id that are allowed to slip\n     * - deltaIds: The list of delta ids to add liquidity (`deltaId = activeId - desiredId`)\n     * - distributionX: The distribution of tokenX with sum(distributionX) = 1e18 (100%) or 0 (0%)\n     * - distributionY: The distribution of tokenY with sum(distributionY) = 1e18 (100%) or 0 (0%)\n     * - to: The address of the recipient\n     * - refundTo: The address of the recipient of the refunded tokens if too much tokens are sent\n     * - deadline: The deadline of the transaction\n     */\n    struct LiquidityParameters {\n        IERC20 tokenX;\n        IERC20 tokenY;\n        uint256 binStep;\n        uint256 amountX;\n        uint256 amountY;\n        uint256 amountXMin;\n        uint256 amountYMin;\n        uint256 activeIdDesired;\n        uint256 idSlippage;\n        int256[] deltaIds;\n        uint256[] distributionX;\n        uint256[] distributionY;\n        address to;\n        address refundTo;\n        uint256 deadline;\n    }\n\n    /**\n     * @dev The path parameters, such as:\n     * - pairBinSteps: The list of bin steps of the pairs to go through\n     * - versions: The list of versions of the pairs to go through\n     * - tokenPath: The list of tokens in the path to go through\n     */\n    struct Path {\n        uint256[] pairBinSteps;\n        Version[] versions;\n        IERC20[] tokenPath;\n    }\n\n    function getFactory() external view returns (ILBFactory);\n\n    function getFactoryV2_1() external view returns (ILBFactory);\n\n    function getLegacyFactory() external view returns (ILBLegacyFactory);\n\n    function getV1Factory() external view returns (IJoeFactory);\n\n    function getLegacyRouter() external view returns (ILBLegacyRouter);\n\n    function getWNATIVE() external view returns (IWNATIVE);\n\n    function getIdFromPrice(ILBPair LBPair, uint256 price) external view returns (uint24);\n\n    function getPriceFromId(ILBPair LBPair, uint24 id) external view returns (uint256);\n\n    function getSwapIn(ILBPair LBPair, uint128 amountOut, bool swapForY)\n        external\n        view\n        returns (uint128 amountIn, uint128 amountOutLeft, uint128 fee);\n\n    function getSwapOut(ILBPair LBPair, uint128 amountIn, bool swapForY)\n        external\n        view\n        returns (uint128 amountInLeft, uint128 amountOut, uint128 fee);\n\n    function createLBPair(IERC20 tokenX, IERC20 tokenY, uint24 activeId, uint16 binStep)\n        external\n        returns (ILBPair pair);\n\n    function addLiquidity(LiquidityParameters calldata liquidityParameters)\n        external\n        returns (\n            uint256 amountXAdded,\n            uint256 amountYAdded,\n            uint256 amountXLeft,\n            uint256 amountYLeft,\n            uint256[] memory depositIds,\n            uint256[] memory liquidityMinted\n        );\n\n    function addLiquidityNATIVE(LiquidityParameters calldata liquidityParameters)\n        external\n        payable\n        returns (\n            uint256 amountXAdded,\n            uint256 amountYAdded,\n            uint256 amountXLeft,\n            uint256 amountYLeft,\n            uint256[] memory depositIds,\n            uint256[] memory liquidityMinted\n        );\n\n    function removeLiquidity(\n        IERC20 tokenX,\n        IERC20 tokenY,\n        uint16 binStep,\n        uint256 amountXMin,\n        uint256 amountYMin,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountX, uint256 amountY);\n\n    function removeLiquidityNATIVE(\n        IERC20 token,\n        uint16 binStep,\n        uint256 amountTokenMin,\n        uint256 amountNATIVEMin,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountNATIVE);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        Path memory path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactTokensForNATIVE(\n        uint256 amountIn,\n        uint256 amountOutMinNATIVE,\n        Path memory path,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactNATIVEForTokens(uint256 amountOutMin, Path memory path, address to, uint256 deadline)\n        external\n        payable\n        returns (uint256 amountOut);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        Path memory path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amountsIn);\n\n    function swapTokensForExactNATIVE(\n        uint256 amountOut,\n        uint256 amountInMax,\n        Path memory path,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256[] memory amountsIn);\n\n    function swapNATIVEForExactTokens(uint256 amountOut, Path memory path, address to, uint256 deadline)\n        external\n        payable\n        returns (uint256[] memory amountsIn);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        Path memory path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactTokensForNATIVESupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMinNATIVE,\n        Path memory path,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactNATIVEForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        Path memory path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256 amountOut);\n\n    function sweep(IERC20 token, address to, uint256 amount) external;\n\n    function sweepLBToken(ILBToken _lbToken, address _to, uint256[] calldata _ids, uint256[] calldata _amounts)\n        external;\n}\n"
    },
    "contracts/joe-v2/src/interfaces/ILBToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @title Liquidity Book Token Interface\n * @author Trader Joe\n * @notice Interface to interact with the LBToken.\n */\ninterface ILBToken {\n    error LBToken__AddressThisOrZero();\n    error LBToken__InvalidLength();\n    error LBToken__SelfApproval(address owner);\n    error LBToken__SpenderNotApproved(address from, address spender);\n    error LBToken__TransferExceedsBalance(address from, uint256 id, uint256 amount);\n    error LBToken__BurnExceedsBalance(address from, uint256 id, uint256 amount);\n\n    event TransferBatch(\n        address indexed sender, address indexed from, address indexed to, uint256[] ids, uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed account, address indexed sender, bool approved);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply(uint256 id) external view returns (uint256);\n\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    function isApprovedForAll(address owner, address spender) external view returns (bool);\n\n    function approveForAll(address spender, bool approved) external;\n\n    function batchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts) external;\n}\n"
    },
    "contracts/joe-v2/src/interfaces/IWNATIVE.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title WNATIVE Interface\n * @notice Required interface of Wrapped NATIVE contract\n */\ninterface IWNATIVE is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/joe-v2/src/LBBaseHooks.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {Hooks} from \"./libraries/Hooks.sol\";\nimport {ILBHooks} from \"./interfaces/ILBHooks.sol\";\nimport {ILBPair} from \"./interfaces/ILBPair.sol\";\n\n/**\n * @title Liquidity Book Base Hooks Contract\n * @notice Base contract for LBPair hooks\n * This contract is meant to be inherited by any contract that wants to implement LBPair hooks\n */\nabstract contract LBBaseHooks is ILBHooks {\n    error LBBaseHooks__InvalidCaller(address caller);\n    error LBBaseHooks__NotLinked();\n\n    /**\n     * @dev Modifier to check that the caller is the trusted caller\n     */\n    modifier onlyTrustedCaller() {\n        _checkTrustedCaller();\n        _;\n    }\n\n    /**\n     * @dev Returns the LBPair contract\n     * @return The LBPair contract\n     */\n    function getLBPair() external view override returns (ILBPair) {\n        return _getLBPair();\n    }\n\n    /**\n     * @dev Returns whether the contract is linked to the pair or not\n     * @return Whether the contract is linked to the pair or not\n     */\n    function isLinked() external view override returns (bool) {\n        return _isLinked();\n    }\n\n    /**\n     * @notice Hook called by the pair when the hooks parameters are set\n     * @dev Only callable by the pair\n     * @param hooksParameters The hooks parameters\n     * @param onHooksSetData The onHooksSet data\n     * @return The function selector\n     */\n    function onHooksSet(bytes32 hooksParameters, bytes calldata onHooksSetData)\n        external\n        override\n        onlyTrustedCaller\n        returns (bytes4)\n    {\n        if (!_isLinked()) revert LBBaseHooks__NotLinked();\n\n        _onHooksSet(hooksParameters, onHooksSetData);\n\n        return this.onHooksSet.selector;\n    }\n\n    /**\n     * @notice Hook called by the pair before a swap\n     * @dev Only callable by the pair\n     * @param sender The address that initiated the swap\n     * @param to The address that will receive the swapped tokens\n     * @param swapForY Whether the swap is for token Y\n     * @param amountsIn The amounts in\n     * @return The function selector\n     */\n    function beforeSwap(address sender, address to, bool swapForY, bytes32 amountsIn)\n        external\n        override\n        onlyTrustedCaller\n        returns (bytes4)\n    {\n        _beforeSwap(sender, to, swapForY, amountsIn);\n\n        return this.beforeSwap.selector;\n    }\n\n    /**\n     * @notice Hook called by the pair after a swap\n     * @dev Only callable by the pair\n     * @param sender The address that initiated the swap\n     * @param to The address that received the swapped tokens\n     * @param swapForY Whether the swap was for token Y\n     * @param amountsOut The amounts out\n     * @return The function selector\n     */\n    function afterSwap(address sender, address to, bool swapForY, bytes32 amountsOut)\n        external\n        override\n        onlyTrustedCaller\n        returns (bytes4)\n    {\n        _afterSwap(sender, to, swapForY, amountsOut);\n\n        return this.afterSwap.selector;\n    }\n\n    /**\n     * @notice Hook called by the pair before a flash loan\n     * @dev Only callable by the pair\n     * @param sender The address that initiated the flash loan\n     * @param to The address that will receive the flash loaned tokens\n     * @param amounts The amounts\n     * @return The function selector\n     */\n    function beforeFlashLoan(address sender, address to, bytes32 amounts)\n        external\n        override\n        onlyTrustedCaller\n        returns (bytes4)\n    {\n        _beforeFlashLoan(sender, to, amounts);\n\n        return this.beforeFlashLoan.selector;\n    }\n\n    /**\n     * @notice Hook called by the pair after a flash loan\n     * @dev Only callable by the pair\n     * @param sender The address that initiated the flash loan\n     * @param to The address that received the flash loaned tokens\n     * @param fees The flashloan fees\n     * @param feesReceived The fees received\n     * @return The function selector\n     */\n    function afterFlashLoan(address sender, address to, bytes32 fees, bytes32 feesReceived)\n        external\n        override\n        onlyTrustedCaller\n        returns (bytes4)\n    {\n        _afterFlashLoan(sender, to, fees, feesReceived);\n\n        return this.afterFlashLoan.selector;\n    }\n\n    /**\n     * @notice Hook called by the pair before minting\n     * @dev Only callable by the pair\n     * @param sender The address that initiated the mint\n     * @param to The address that will receive the minted tokens\n     * @param liquidityConfigs The liquidity configurations\n     * @param amountsReceived The amounts received\n     * @return The function selector\n     */\n    function beforeMint(address sender, address to, bytes32[] calldata liquidityConfigs, bytes32 amountsReceived)\n        external\n        override\n        onlyTrustedCaller\n        returns (bytes4)\n    {\n        _beforeMint(sender, to, liquidityConfigs, amountsReceived);\n\n        return this.beforeMint.selector;\n    }\n\n    /**\n     * @notice Hook called by the pair after minting\n     * @dev Only callable by the pair\n     * @param sender The address that initiated the mint\n     * @param to The address that received the minted tokens\n     * @param liquidityConfigs The liquidity configurations\n     * @param amountsIn The amounts in\n     * @return The function selector\n     */\n    function afterMint(address sender, address to, bytes32[] calldata liquidityConfigs, bytes32 amountsIn)\n        external\n        override\n        onlyTrustedCaller\n        returns (bytes4)\n    {\n        _afterMint(sender, to, liquidityConfigs, amountsIn);\n\n        return this.afterMint.selector;\n    }\n\n    /**\n     * @notice Hook called by the pair before burning\n     * @dev Only callable by the pair\n     * @param sender The address that initiated the burn\n     * @param from The address that will burn the tokens\n     * @param to The address that will receive the burned tokens\n     * @param ids The token ids\n     * @param amountsToBurn The amounts to burn\n     * @return The function selector\n     */\n    function beforeBurn(\n        address sender,\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amountsToBurn\n    ) external override onlyTrustedCaller returns (bytes4) {\n        _beforeBurn(sender, from, to, ids, amountsToBurn);\n\n        return this.beforeBurn.selector;\n    }\n\n    /**\n     * @notice Hook called by the pair after burning\n     * @dev Only callable by the pair\n     * @param sender The address that initiated the burn\n     * @param from The address that burned the tokens\n     * @param to The address that received the burned tokens\n     * @param ids The token ids\n     * @param amountsToBurn The amounts to burn\n     * @return The function selector\n     */\n    function afterBurn(\n        address sender,\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amountsToBurn\n    ) external override onlyTrustedCaller returns (bytes4) {\n        _afterBurn(sender, from, to, ids, amountsToBurn);\n\n        return this.afterBurn.selector;\n    }\n\n    /**\n     * @notice Hook called by the pair before a batch transfer\n     * @dev Only callable by the pair\n     * @param sender The address that initiated the transfer\n     * @param from The address that will transfer the tokens\n     * @param to The address that will receive the tokens\n     * @param ids The token ids\n     * @param amounts The amounts\n     * @return The function selector\n     */\n    function beforeBatchTransferFrom(\n        address sender,\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external override onlyTrustedCaller returns (bytes4) {\n        _beforeBatchTransferFrom(sender, from, to, ids, amounts);\n\n        return this.beforeBatchTransferFrom.selector;\n    }\n\n    /**\n     * @notice Hook called by the pair after a batch transfer\n     * @dev Only callable by the pair\n     * @param sender The address that initiated the transfer\n     * @param from The address that transferred the tokens\n     * @param to The address that received the tokens\n     * @param ids The token ids\n     * @param amounts The amounts\n     * @return The function selector\n     */\n    function afterBatchTransferFrom(\n        address sender,\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external override onlyTrustedCaller returns (bytes4) {\n        _afterBatchTransferFrom(sender, from, to, ids, amounts);\n\n        return this.afterBatchTransferFrom.selector;\n    }\n\n    /**\n     * @dev Checks that the caller is the trusted caller, otherwise reverts\n     */\n    function _checkTrustedCaller() internal view virtual {\n        if (msg.sender != address(_getLBPair())) revert LBBaseHooks__InvalidCaller(msg.sender);\n    }\n\n    /**\n     * @dev Checks if the contract is linked to the pair\n     * @return Whether the contract is linked to the pair or not\n     */\n    function _isLinked() internal view virtual returns (bool) {\n        address hooks = Hooks.getHooks(_getLBPair().getLBHooksParameters());\n        return hooks == address(this);\n    }\n\n    /**\n     * @dev Returns the LBPair contract\n     */\n    function _getLBPair() internal view virtual returns (ILBPair);\n\n    /**\n     * @notice Internal function to be overridden that is called when the hooks parameters are set\n     * @param hooksParameters The hooks parameters\n     * @param onHooksSetData The onHooksSet data\n     */\n    function _onHooksSet(bytes32 hooksParameters, bytes calldata onHooksSetData) internal virtual {}\n\n    /**\n     * @notice Internal function to be overridden that is called before a swap\n     * @param sender The address that initiated the swap\n     * @param to The address that will receive the swapped tokens\n     * @param swapForY Whether the swap is for token Y\n     * @param amountsIn The amounts in\n     */\n    function _beforeSwap(address sender, address to, bool swapForY, bytes32 amountsIn) internal virtual {}\n\n    /**\n     * @notice Internal function to be overridden that is called after a swap\n     * @param sender The address that initiated the swap\n     * @param to The address that received the swapped tokens\n     * @param swapForY Whether the swap was for token Y\n     * @param amountsOut The amounts out\n     */\n    function _afterSwap(address sender, address to, bool swapForY, bytes32 amountsOut) internal virtual {}\n\n    /**\n     * @notice Internal function to be overridden that is called before a flash loan\n     * @param sender The address that initiated the flash loan\n     * @param to The address that will receive the flash loaned tokens\n     * @param amounts The amounts\n     */\n    function _beforeFlashLoan(address sender, address to, bytes32 amounts) internal virtual {}\n\n    /**\n     * @notice Internal function to be overridden that is called after a flash loan\n     * @param sender The address that initiated the flash loan\n     * @param to The address that received the flash loaned tokens\n     * @param fees The flashloan fees\n     * @param feesReceived The fees received\n     */\n    function _afterFlashLoan(address sender, address to, bytes32 fees, bytes32 feesReceived) internal virtual {}\n\n    /**\n     * @notice Internal function to be overridden that is called before minting\n     * @param sender The address that initiated the mint\n     * @param to The address that will receive the minted tokens\n     * @param liquidityConfigs The liquidity configurations\n     * @param amountsReceived The amounts received\n     */\n    function _beforeMint(address sender, address to, bytes32[] calldata liquidityConfigs, bytes32 amountsReceived)\n        internal\n        virtual\n    {}\n\n    /**\n     * @notice Internal function to be overridden that is called after minting\n     * @param sender The address that initiated the mint\n     * @param to The address that received the minted tokens\n     * @param liquidityConfigs The liquidity configurations\n     * @param amountsIn The amounts in\n     */\n    function _afterMint(address sender, address to, bytes32[] calldata liquidityConfigs, bytes32 amountsIn)\n        internal\n        virtual\n    {}\n\n    /**\n     * @notice Internal function to be overridden that is called before burning\n     * @param sender The address that initiated the burn\n     * @param from The address that will burn the tokens\n     * @param to The address that will receive the burned tokens\n     * @param ids The token ids\n     * @param amountsToBurn The amounts to burn\n     */\n    function _beforeBurn(\n        address sender,\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amountsToBurn\n    ) internal virtual {}\n\n    /**\n     * @notice Internal function to be overridden that is called after burning\n     * @param sender The address that initiated the burn\n     * @param from The address that burned the tokens\n     * @param to The address that received the burned tokens\n     * @param ids The token ids\n     * @param amountsToBurn The amounts to burn\n     */\n    function _afterBurn(\n        address sender,\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amountsToBurn\n    ) internal virtual {}\n\n    /**\n     * @notice Internal function to be overridden that is called before a batch transfer\n     * @param sender The address that initiated the transfer\n     * @param from The address that will transfer the tokens\n     * @param to The address that will receive the tokens\n     * @param ids The token ids\n     * @param amounts The amounts\n     */\n    function _beforeBatchTransferFrom(\n        address sender,\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) internal virtual {}\n\n    /**\n     * @notice Internal function to be overridden that is called after a batch transfer\n     * @param sender The address that initiated the transfer\n     * @param from The address that transferred the tokens\n     * @param to The address that received the tokens\n     * @param ids The token ids\n     * @param amounts The amounts\n     */\n    function _afterBatchTransferFrom(\n        address sender,\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) internal virtual {}\n}\n"
    },
    "contracts/joe-v2/src/LBDeployer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {LBFactory} from \"./LBFactory.sol\";\nimport {LBPair} from \"./LBPair.sol\";\n\ncontract LBDeployer {\n    LBFactory public factory;\n\n    LBPair public pair;\n\n    constructor(\n        address feeRecipient,\n        address owner,\n        uint256 flashLoanFee,\n        uint16[] memory binSteps,\n        uint16[] memory baseFactors,\n        uint16[] memory filterPeriods,\n        uint16[] memory decayPeriods,\n        uint16[] memory reductionFactors,\n        uint24[] memory variableFeeControls,\n        uint16[] memory protocolShares,\n        uint24[] memory maxVolatilityAccumulators\n    ) {\n        factory = new LBFactory(\n            feeRecipient,\n            address(this),\n            flashLoanFee\n        );\n\n        pair = new LBPair(factory);\n\n        factory.setLBPairImplementation(address(pair));\n\n        for (uint256 i = 0; i < binSteps.length; i++) {\n            factory.setPreset(\n                binSteps[i],\n                baseFactors[i],\n                filterPeriods[i],\n                decayPeriods[i],\n                reductionFactors[i],\n                variableFeeControls[i],\n                protocolShares[i],\n                maxVolatilityAccumulators[i],\n                true\n            );\n        }\n\n        factory.transferOwnership(owner);\n    }\n}"
    },
    "contracts/joe-v2/src/LBFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {EnumerableSet} from \"../lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\nimport {EnumerableMap} from \"../lib/openzeppelin-contracts/contracts/utils/structs/EnumerableMap.sol\";\nimport {AccessControl} from \"../lib/openzeppelin-contracts/contracts/access/AccessControl.sol\";\nimport {IERC20} from \"../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport {Ownable2Step, Ownable} from \"../lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol\";\n\nimport {PairParameterHelper} from \"./libraries/PairParameterHelper.sol\";\nimport {Encoded} from \"./libraries/math/Encoded.sol\";\nimport {ImmutableClone} from \"./libraries/ImmutableClone.sol\";\nimport {PriceHelper} from \"./libraries/PriceHelper.sol\";\nimport {SafeCast} from \"./libraries/math/SafeCast.sol\";\nimport {Hooks} from \"./libraries/Hooks.sol\";\n\nimport {ILBFactory} from \"./interfaces/ILBFactory.sol\";\nimport {ILBPair} from \"./interfaces/ILBPair.sol\";\nimport {ILBHooks} from \"./interfaces/ILBHooks.sol\";\n\n/**\n * @title Liquidity Book Factory\n * @author Trader Joe\n * @notice Contract used to deploy and register new LBPairs.\n * Enables setting fee parameters, flashloan fees and LBPair implementation.\n * Unless the `isOpen` is `true`, only the owner of the factory can create pairs.\n */\ncontract LBFactory is Ownable2Step, AccessControl, ILBFactory {\n    using SafeCast for uint256;\n    using Encoded for bytes32;\n    using PairParameterHelper for bytes32;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableMap for EnumerableMap.UintToUintMap;\n\n    bytes32 public constant LB_HOOKS_MANAGER_ROLE = keccak256(\"LB_HOOKS_MANAGER_ROLE\");\n\n    uint256 private constant _OFFSET_IS_PRESET_OPEN = 255;\n\n    uint256 private constant _MIN_BIN_STEP = 1; // 0.001%\n\n    uint256 private constant _MAX_FLASHLOAN_FEE = 0.1e18; // 10%\n\n    address private _feeRecipient;\n    uint256 private _flashLoanFee;\n\n    address private _lbPairImplementation;\n\n    ILBPair[] private _allLBPairs;\n\n    /**\n     * @dev Mapping from a (tokenA, tokenB, binStep) to a LBPair. The tokens are ordered to save gas, but they can be\n     * in the reverse order in the actual pair.\n     * Always query one of the 2 tokens of the pair to assert the order of the 2 tokens\n     */\n    mapping(IERC20 => mapping(IERC20 => mapping(uint256 => LBPairInformation))) private _lbPairsInfo;\n\n    EnumerableMap.UintToUintMap private _presets;\n\n    /**\n     * @dev Mapping from a (tokenA, tokenB) to a set of available bin steps, this is used to keep track of the\n     * bin steps that are already used for a pair.\n     * The tokens are ordered to save gas, but they can be in the reverse order in the actual pair.\n     * Always query one of the 2 tokens of the pair to assert the order of the 2 tokens\n     */\n    mapping(IERC20 => mapping(IERC20 => EnumerableSet.UintSet)) private _availableLBPairBinSteps;\n\n    /**\n     * @notice Constructor\n     * @param feeRecipient The address of the fee recipient\n     * @param flashLoanFee The value of the fee for flash loan\n     */\n    constructor(address feeRecipient, address initialOwner, uint256 flashLoanFee) Ownable(initialOwner) {\n        if (flashLoanFee > _MAX_FLASHLOAN_FEE) revert LBFactory__FlashLoanFeeAboveMax(flashLoanFee, _MAX_FLASHLOAN_FEE);\n\n        _setFeeRecipient(feeRecipient);\n\n        _flashLoanFee = flashLoanFee;\n        emit FlashLoanFeeSet(0, flashLoanFee);\n    }\n\n    /**\n     * @notice Get the minimum bin step a pair can have\n     * @return minBinStep\n     */\n    function getMinBinStep() external pure override returns (uint256 minBinStep) {\n        return _MIN_BIN_STEP;\n    }\n\n    /**\n     * @notice Get the protocol fee recipient\n     * @return feeRecipient\n     */\n    function getFeeRecipient() external view override returns (address feeRecipient) {\n        return _feeRecipient;\n    }\n\n    /**\n     * @notice Get the maximum fee percentage for flashLoans\n     * @return maxFee\n     */\n    function getMaxFlashLoanFee() external pure override returns (uint256 maxFee) {\n        return _MAX_FLASHLOAN_FEE;\n    }\n\n    /**\n     * @notice Get the fee for flash loans, in 1e18\n     * @return flashLoanFee The fee for flash loans, in 1e18\n     */\n    function getFlashLoanFee() external view override returns (uint256 flashLoanFee) {\n        return _flashLoanFee;\n    }\n\n    /**\n     * @notice Get the address of the LBPair implementation\n     * @return lbPairImplementation The address of the LBPair implementation\n     */\n    function getLBPairImplementation() external view override returns (address lbPairImplementation) {\n        return _lbPairImplementation;\n    }\n\n    /**\n     * @notice View function to return the number of LBPairs created\n     * @return lbPairNumber\n     */\n    function getNumberOfLBPairs() external view override returns (uint256 lbPairNumber) {\n        return _allLBPairs.length;\n    }\n\n    /**\n     * @notice View function to return the LBPair created at index `index`\n     * @param index The index\n     * @return lbPair The address of the LBPair at index `index`\n     */\n    function getLBPairAtIndex(uint256 index) external view override returns (ILBPair lbPair) {\n        return _allLBPairs[index];\n    }\n\n    /**\n     * @notice Returns the LBPairInformation if it exists,\n     * if not, then the address 0 is returned. The order doesn't matter\n     * @param tokenA The address of the first token of the pair\n     * @param tokenB The address of the second token of the pair\n     * @param binStep The bin step of the LBPair\n     * @return lbPairInformation The LBPairInformation\n     */\n    function getLBPairInformation(IERC20 tokenA, IERC20 tokenB, uint256 binStep)\n        external\n        view\n        override\n        returns (LBPairInformation memory lbPairInformation)\n    {\n        return _getLBPairInformation(tokenA, tokenB, binStep);\n    }\n\n    /**\n     * @notice View function to return the different parameters of the preset\n     * Will revert if the preset doesn't exist\n     * @param binStep The bin step of the preset\n     * @return baseFactor The base factor\n     * @return filterPeriod The filter period of the preset\n     * @return decayPeriod The decay period of the preset\n     * @return reductionFactor The reduction factor of the preset\n     * @return variableFeeControl The variable fee control of the preset\n     * @return protocolShare The protocol share of the preset\n     * @return maxVolatilityAccumulator The max volatility accumulator of the preset\n     * @return isOpen Whether the preset is open or not\n     */\n    function getPreset(uint256 binStep)\n        external\n        view\n        override\n        returns (\n            uint256 baseFactor,\n            uint256 filterPeriod,\n            uint256 decayPeriod,\n            uint256 reductionFactor,\n            uint256 variableFeeControl,\n            uint256 protocolShare,\n            uint256 maxVolatilityAccumulator,\n            bool isOpen\n        )\n    {\n        if (!_presets.contains(binStep)) revert LBFactory__BinStepHasNoPreset(binStep);\n\n        bytes32 preset = bytes32(_presets.get(binStep));\n\n        baseFactor = preset.getBaseFactor();\n        filterPeriod = preset.getFilterPeriod();\n        decayPeriod = preset.getDecayPeriod();\n        reductionFactor = preset.getReductionFactor();\n        variableFeeControl = preset.getVariableFeeControl();\n        protocolShare = preset.getProtocolShare();\n        maxVolatilityAccumulator = preset.getMaxVolatilityAccumulator();\n\n        isOpen = preset.decodeBool(_OFFSET_IS_PRESET_OPEN);\n    }\n\n    /**\n     * @notice View function to return the list of available binStep with a preset\n     * @return binStepWithPreset The list of binStep\n     */\n    function getAllBinSteps() external view override returns (uint256[] memory binStepWithPreset) {\n        return _presets.keys();\n    }\n\n    /**\n     * @notice View function to return the list of open binSteps\n     * @return openBinStep The list of open binSteps\n     */\n    function getOpenBinSteps() external view override returns (uint256[] memory openBinStep) {\n        uint256 length = _presets.length();\n\n        if (length > 0) {\n            openBinStep = new uint256[](length);\n\n            uint256 index;\n\n            for (uint256 i; i < length; ++i) {\n                (uint256 binStep, uint256 preset) = _presets.at(i);\n\n                if (_isPresetOpen(bytes32(preset))) {\n                    openBinStep[index] = binStep;\n                    index++;\n                }\n            }\n\n            if (index < length) {\n                assembly {\n                    mstore(openBinStep, index)\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice View function to return all the LBPair of a pair of tokens\n     * @param tokenX The first token of the pair\n     * @param tokenY The second token of the pair\n     * @return lbPairsAvailable The list of available LBPairs\n     */\n    function getAllLBPairs(IERC20 tokenX, IERC20 tokenY)\n        external\n        view\n        override\n        returns (LBPairInformation[] memory lbPairsAvailable)\n    {\n        unchecked {\n            (IERC20 tokenA, IERC20 tokenB) = _sortTokens(tokenX, tokenY);\n\n            EnumerableSet.UintSet storage addressSet = _availableLBPairBinSteps[tokenA][tokenB];\n\n            uint256 length = addressSet.length();\n\n            if (length > 0) {\n                lbPairsAvailable = new LBPairInformation[](length);\n\n                mapping(uint256 => LBPairInformation) storage lbPairsInfo = _lbPairsInfo[tokenA][tokenB];\n\n                for (uint256 i = 0; i < length; ++i) {\n                    uint16 binStep = addressSet.at(i).safe16();\n\n                    lbPairsAvailable[i] = LBPairInformation({\n                        binStep: binStep,\n                        LBPair: lbPairsInfo[binStep].LBPair,\n                        createdByOwner: lbPairsInfo[binStep].createdByOwner,\n                        ignoredForRouting: lbPairsInfo[binStep].ignoredForRouting\n                    });\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Set the LBPair implementation address\n     * @dev Needs to be called by the owner\n     * @param newLBPairImplementation The address of the implementation\n     */\n    function setLBPairImplementation(address newLBPairImplementation) external override onlyOwner {\n        if (ILBPair(newLBPairImplementation).getFactory() != this) {\n            revert LBFactory__LBPairSafetyCheckFailed(newLBPairImplementation);\n        }\n\n        address oldLBPairImplementation = _lbPairImplementation;\n        if (oldLBPairImplementation == newLBPairImplementation) {\n            revert LBFactory__SameImplementation(newLBPairImplementation);\n        }\n\n        _lbPairImplementation = newLBPairImplementation;\n\n        emit LBPairImplementationSet(oldLBPairImplementation, newLBPairImplementation);\n    }\n\n    /**\n     * @notice Create a liquidity bin LBPair for tokenX and tokenY\n     * @param tokenX The address of the first token\n     * @param tokenY The address of the second token\n     * @param activeId The active id of the pair\n     * @param binStep The bin step in basis point, used to calculate log(1 + binStep / 10_000)\n     * @return pair The address of the newly created LBPair\n     */\n    function createLBPair(IERC20 tokenX, IERC20 tokenY, uint24 activeId, uint16 binStep)\n        external\n        override\n        returns (ILBPair pair)\n    {\n        if (!_presets.contains(binStep)) revert LBFactory__BinStepHasNoPreset(binStep);\n\n        bytes32 preset = bytes32(_presets.get(binStep));\n        bool isOwner = msg.sender == owner();\n\n        if (!_isPresetOpen(preset) && !isOwner) {\n            revert LBFactory__PresetIsLockedForUsers(msg.sender, binStep);\n        }\n\n        if (tokenX == tokenY) revert LBFactory__IdenticalAddresses(tokenX);\n\n        // safety check, making sure that the price can be calculated\n        PriceHelper.getPriceFromId(activeId, binStep);\n\n        // We sort token for storage efficiency, only one input needs to be stored because they are sorted\n        (IERC20 tokenA, IERC20 tokenB) = _sortTokens(tokenX, tokenY);\n        // single check is sufficient\n        if (address(tokenA) == address(0)) revert LBFactory__AddressZero();\n        if (address(_lbPairsInfo[tokenA][tokenB][binStep].LBPair) != address(0)) {\n            revert LBFactory__LBPairAlreadyExists(tokenX, tokenY, binStep);\n        }\n\n        {\n            address implementation = _lbPairImplementation;\n\n            if (implementation == address(0)) revert LBFactory__ImplementationNotSet();\n\n            pair = ILBPair(\n                ImmutableClone.cloneDeterministic(\n                    implementation,\n                    abi.encodePacked(tokenX, tokenY, binStep),\n                    keccak256(abi.encode(tokenA, tokenB, binStep))\n                )\n            );\n        }\n\n        _lbPairsInfo[tokenA][tokenB][binStep] =\n            LBPairInformation({binStep: binStep, LBPair: pair, createdByOwner: isOwner, ignoredForRouting: false});\n\n        _allLBPairs.push(pair);\n        _availableLBPairBinSteps[tokenA][tokenB].add(binStep);\n\n        emit LBPairCreated(tokenX, tokenY, binStep, pair, _allLBPairs.length - 1);\n\n        pair.initialize(\n            preset.getBaseFactor(),\n            preset.getFilterPeriod(),\n            preset.getDecayPeriod(),\n            preset.getReductionFactor(),\n            preset.getVariableFeeControl(),\n            preset.getProtocolShare(),\n            preset.getMaxVolatilityAccumulator(),\n            activeId\n        );\n    }\n\n    /**\n     * @notice Function to set whether the pair is ignored or not for routing, it will make the pair unusable by the router\n     * @dev Needs to be called by the owner\n     * Reverts if:\n     * - The pair doesn't exist\n     * - The ignored state is already in the same state\n     * @param tokenX The address of the first token of the pair\n     * @param tokenY The address of the second token of the pair\n     * @param binStep The bin step in basis point of the pair\n     * @param ignored Whether to ignore (true) or not (false) the pair for routing\n     */\n    function setLBPairIgnored(IERC20 tokenX, IERC20 tokenY, uint16 binStep, bool ignored) external override onlyOwner {\n        (IERC20 tokenA, IERC20 tokenB) = _sortTokens(tokenX, tokenY);\n\n        LBPairInformation memory pairInformation = _lbPairsInfo[tokenA][tokenB][binStep];\n        if (address(pairInformation.LBPair) == address(0)) {\n            revert LBFactory__LBPairDoesNotExist(tokenX, tokenY, binStep);\n        }\n\n        if (pairInformation.ignoredForRouting == ignored) revert LBFactory__LBPairIgnoredIsAlreadyInTheSameState();\n\n        _lbPairsInfo[tokenA][tokenB][binStep].ignoredForRouting = ignored;\n\n        emit LBPairIgnoredStateChanged(pairInformation.LBPair, ignored);\n    }\n\n    /**\n     * @notice Sets the preset parameters of a bin step\n     * @dev Needs to be called by the owner\n     * Reverts if:\n     * - The binStep is lower than the minimum bin step\n     * @param binStep The bin step in basis point, used to calculate the price\n     * @param baseFactor The base factor, used to calculate the base fee, baseFee = baseFactor * binStep\n     * @param filterPeriod The period where the accumulator value is untouched, prevent spam\n     * @param decayPeriod The period where the accumulator value is decayed, by the reduction factor\n     * @param reductionFactor The reduction factor, used to calculate the reduction of the accumulator\n     * @param variableFeeControl The variable fee control, used to control the variable fee, can be 0 to disable it\n     * @param protocolShare The share of the fees received by the protocol\n     * @param maxVolatilityAccumulator The max value of the volatility accumulator\n     */\n    function setPreset(\n        uint16 binStep,\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator,\n        bool isOpen\n    ) external override onlyOwner {\n        if (binStep < _MIN_BIN_STEP) revert LBFactory__BinStepTooLow(binStep);\n\n        bytes32 preset = bytes32(0).setStaticFeeParameters(\n            baseFactor,\n            filterPeriod,\n            decayPeriod,\n            reductionFactor,\n            variableFeeControl,\n            protocolShare,\n            maxVolatilityAccumulator\n        );\n\n        if (isOpen) {\n            preset = preset.setBool(true, _OFFSET_IS_PRESET_OPEN);\n        }\n\n        _presets.set(binStep, uint256(preset));\n\n        emit PresetSet(\n            binStep,\n            baseFactor,\n            filterPeriod,\n            decayPeriod,\n            reductionFactor,\n            variableFeeControl,\n            protocolShare,\n            maxVolatilityAccumulator\n        );\n\n        emit PresetOpenStateChanged(binStep, isOpen);\n    }\n\n    /**\n     * @notice Sets if the preset is open or not to be used by users\n     * @dev Needs to be called by the owner\n     * Reverts if:\n     * - The binStep doesn't have a preset\n     * - The preset is already in the same state\n     * @param binStep The bin step in basis point, used to calculate the price\n     * @param isOpen Whether the preset is open or not\n     */\n    function setPresetOpenState(uint16 binStep, bool isOpen) external override onlyOwner {\n        if (!_presets.contains(binStep)) revert LBFactory__BinStepHasNoPreset(binStep);\n\n        bytes32 preset = bytes32(_presets.get(binStep));\n\n        if (preset.decodeBool(_OFFSET_IS_PRESET_OPEN) == isOpen) {\n            revert LBFactory__PresetOpenStateIsAlreadyInTheSameState();\n        }\n\n        _presets.set(binStep, uint256(preset.setBool(isOpen, _OFFSET_IS_PRESET_OPEN)));\n\n        emit PresetOpenStateChanged(binStep, isOpen);\n    }\n\n    /**\n     * @notice Remove the preset linked to a binStep\n     * @dev Needs to be called by the owner\n     * Reverts if:\n     * - The binStep doesn't have a preset\n     * @param binStep The bin step to remove\n     */\n    function removePreset(uint16 binStep) external override onlyOwner {\n        if (!_presets.remove(binStep)) revert LBFactory__BinStepHasNoPreset(binStep);\n\n        emit PresetRemoved(binStep);\n    }\n\n    /**\n     * @notice Function to set the fee parameter of a LBPair\n     * @dev Needs to be called by the owner\n     * Reverts if:\n     * - The pair doesn't exist\n     * @param tokenX The address of the first token\n     * @param tokenY The address of the second token\n     * @param binStep The bin step in basis point, used to calculate the price\n     * @param baseFactor The base factor, used to calculate the base fee, baseFee = baseFactor * binStep\n     * @param filterPeriod The period where the accumulator value is untouched, prevent spam\n     * @param decayPeriod The period where the accumulator value is decayed, by the reduction factor\n     * @param reductionFactor The reduction factor, used to calculate the reduction of the accumulator\n     * @param variableFeeControl The variable fee control, used to control the variable fee, can be 0 to disable it\n     * @param protocolShare The share of the fees received by the protocol\n     * @param maxVolatilityAccumulator The max value of volatility accumulator\n     */\n    function setFeesParametersOnPair(\n        IERC20 tokenX,\n        IERC20 tokenY,\n        uint16 binStep,\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator\n    ) external override onlyOwner {\n        ILBPair lbPair = _getLBPairInformation(tokenX, tokenY, binStep).LBPair;\n\n        if (address(lbPair) == address(0)) revert LBFactory__LBPairNotCreated(tokenX, tokenY, binStep);\n\n        lbPair.setStaticFeeParameters(\n            baseFactor,\n            filterPeriod,\n            decayPeriod,\n            reductionFactor,\n            variableFeeControl,\n            protocolShare,\n            maxVolatilityAccumulator\n        );\n    }\n\n    /**\n     * @notice Function to set the hooks parameters of a pair\n     * @dev Needs to be called by an address with the LB_HOOKS_MANAGER_ROLE\n     * Reverts if:\n     * - The pair doesn't exist\n     * - The hooks is `address(0)` or the hooks flags are all false\n     * @param tokenX The address of the first token\n     * @param tokenY The address of the second token\n     * @param binStep The bin step in basis point, used to calculate the price\n     * @param hooksParameters The hooks parameters\n     * @param onHooksSetData The data to pass to the onHooksSet function\n     */\n    function setLBHooksParametersOnPair(\n        IERC20 tokenX,\n        IERC20 tokenY,\n        uint16 binStep,\n        bytes32 hooksParameters,\n        bytes calldata onHooksSetData\n    ) external override onlyRole(LB_HOOKS_MANAGER_ROLE) {\n        if (Hooks.getHooks(hooksParameters) == address(0) || Hooks.getFlags(hooksParameters) == 0) {\n            revert LBFactory__InvalidHooksParameters();\n        }\n\n        _setLBHooksParametersOnPair(tokenX, tokenY, binStep, hooksParameters, onHooksSetData);\n    }\n\n    /**\n     * @notice Function to remove the hooks contract from the pair\n     * @dev Needs to be called by an address with the LB_HOOKS_MANAGER_ROLE\n     * Reverts if:\n     * - The pair doesn't exist\n     * @param tokenX The address of the first token\n     * @param tokenY The address of the second token\n     * @param binStep The bin step in basis point, used to calculate the price\n     */\n    function removeLBHooksOnPair(IERC20 tokenX, IERC20 tokenY, uint16 binStep)\n        external\n        override\n        onlyRole(LB_HOOKS_MANAGER_ROLE)\n    {\n        _setLBHooksParametersOnPair(tokenX, tokenY, binStep, 0, new bytes(0));\n    }\n\n    /**\n     * @notice Function to set the recipient of the fees. This address needs to be able to receive ERC20s\n     * @dev Needs to be called by the owner\n     * Reverts if:\n     * - The feeRecipient is `address(0)`\n     * - The feeRecipient is the same as the current one\n     * @param feeRecipient The address of the recipient\n     */\n    function setFeeRecipient(address feeRecipient) external override onlyOwner {\n        _setFeeRecipient(feeRecipient);\n    }\n\n    /**\n     * @notice Function to set the flash loan fee\n     * @dev Needs to be called by the owner\n     * Reverts if:\n     * - The flashLoanFee is the same as the current one\n     * - The flashLoanFee is above the maximum flash loan fee\n     * @param flashLoanFee The value of the fee for flash loan\n     */\n    function setFlashLoanFee(uint256 flashLoanFee) external override onlyOwner {\n        uint256 oldFlashLoanFee = _flashLoanFee;\n\n        if (oldFlashLoanFee == flashLoanFee) revert LBFactory__SameFlashLoanFee(flashLoanFee);\n        if (flashLoanFee > _MAX_FLASHLOAN_FEE) revert LBFactory__FlashLoanFeeAboveMax(flashLoanFee, _MAX_FLASHLOAN_FEE);\n\n        _flashLoanFee = flashLoanFee;\n        emit FlashLoanFeeSet(oldFlashLoanFee, flashLoanFee);\n    }\n\n    function _isPresetOpen(bytes32 preset) internal pure returns (bool) {\n        return preset.decodeBool(_OFFSET_IS_PRESET_OPEN);\n    }\n\n    /**\n     * @notice Internal function to set the recipient of the fee\n     * @param feeRecipient The address of the recipient\n     */\n    function _setFeeRecipient(address feeRecipient) internal {\n        if (feeRecipient == address(0)) revert LBFactory__AddressZero();\n\n        address oldFeeRecipient = _feeRecipient;\n        if (oldFeeRecipient == feeRecipient) revert LBFactory__SameFeeRecipient(_feeRecipient);\n\n        _feeRecipient = feeRecipient;\n        emit FeeRecipientSet(oldFeeRecipient, feeRecipient);\n    }\n\n    /**\n     * @notice Function to force the decay of the volatility accumulator of a pair\n     * @dev Needs to be called by the owner\n     * @param pair The pair to force the decay\n     */\n    function forceDecay(ILBPair pair) external override onlyOwner {\n        pair.forceDecay();\n    }\n\n    /**\n     * @notice Returns the LBPairInformation if it exists,\n     * if not, then the address 0 is returned. The order doesn't matter\n     * @param tokenA The address of the first token of the pair\n     * @param tokenB The address of the second token of the pair\n     * @param binStep The bin step of the LBPair\n     * @return The LBPairInformation\n     */\n    function _getLBPairInformation(IERC20 tokenA, IERC20 tokenB, uint256 binStep)\n        private\n        view\n        returns (LBPairInformation memory)\n    {\n        (tokenA, tokenB) = _sortTokens(tokenA, tokenB);\n        return _lbPairsInfo[tokenA][tokenB][binStep];\n    }\n\n    /**\n     * @notice Private view function to sort 2 tokens in ascending order\n     * @param tokenA The first token\n     * @param tokenB The second token\n     * @return The sorted first token\n     * @return The sorted second token\n     */\n    function _sortTokens(IERC20 tokenA, IERC20 tokenB) private pure returns (IERC20, IERC20) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return (tokenA, tokenB);\n    }\n\n    /**\n     * @notice Internal function to set a hooks contract to the pair\n     * @param tokenX The address of the first token\n     * @param tokenY The address of the second token\n     * @param binStep The bin step in basis point, used to calculate the price\n     * @param hooksParameters The hooks parameters\n     * @param onHooksSetData The data to pass to the onHooksSet function\n     */\n    function _setLBHooksParametersOnPair(\n        IERC20 tokenX,\n        IERC20 tokenY,\n        uint16 binStep,\n        bytes32 hooksParameters,\n        bytes memory onHooksSetData\n    ) internal {\n        ILBPair lbPair = _getLBPairInformation(tokenX, tokenY, binStep).LBPair;\n\n        if (address(lbPair) == address(0)) revert LBFactory__LBPairNotCreated(tokenX, tokenY, binStep);\n        if (lbPair.getLBHooksParameters() == hooksParameters) revert LBFactory__SameHooksParameters(hooksParameters);\n\n        lbPair.setHooksParameters(hooksParameters, onHooksSetData);\n    }\n\n    /**\n     * @notice Returns whether the caller has the role or not, only the owner has the DEFAULT_ADMIN_ROLE\n     * @param role The role to check\n     * @param account The address to check\n     * @return Whether the account has the role or not\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        if (role == DEFAULT_ADMIN_ROLE) return account == owner();\n        return super.hasRole(role, account);\n    }\n\n    /**\n     * @notice Grants a role to an address, the DEFAULT_ADMIN_ROLE can not be granted\n     * @param role The role to grant\n     * @param account The address to grant the role to\n     * @return Whether the role has been granted or not\n     */\n    function _grantRole(bytes32 role, address account) internal override returns (bool) {\n        if (role == DEFAULT_ADMIN_ROLE) revert LBFactory__CannotGrantDefaultAdminRole();\n        return super._grantRole(role, account);\n    }\n}\n"
    },
    "contracts/joe-v2/src/LBPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\nimport {BinHelper} from \"./libraries/BinHelper.sol\";\nimport {Clone} from \"./libraries/Clone.sol\";\nimport {Constants} from \"./libraries/Constants.sol\";\nimport {FeeHelper} from \"./libraries/FeeHelper.sol\";\nimport {LiquidityConfigurations} from \"./libraries/math/LiquidityConfigurations.sol\";\nimport {ReentrancyGuardUpgradeable} from \"./libraries/ReentrancyGuardUpgradeable.sol\";\nimport {ILBFactory} from \"./interfaces/ILBFactory.sol\";\nimport {ILBFlashLoanCallback} from \"./interfaces/ILBFlashLoanCallback.sol\";\nimport {ILBPair} from \"./interfaces/ILBPair.sol\";\nimport {LBToken, ILBToken} from \"./LBToken.sol\";\nimport {OracleHelper} from \"./libraries/OracleHelper.sol\";\nimport {PackedUint128Math} from \"./libraries/math/PackedUint128Math.sol\";\nimport {PairParameterHelper} from \"./libraries/PairParameterHelper.sol\";\nimport {PriceHelper} from \"./libraries/PriceHelper.sol\";\nimport {SafeCast} from \"./libraries/math/SafeCast.sol\";\nimport {SampleMath} from \"./libraries/math/SampleMath.sol\";\nimport {TreeMath} from \"./libraries/math/TreeMath.sol\";\nimport {Uint256x256Math} from \"./libraries/math/Uint256x256Math.sol\";\nimport {Hooks} from \"./libraries/Hooks.sol\";\nimport {ILBHooks} from \"./interfaces/ILBHooks.sol\";\n\n/**\n * @title Liquidity Book Pair\n * @author Trader Joe\n * @notice The Liquidity Book Pair contract is the core contract of the Liquidity Book protocol\n */\ncontract LBPair is LBToken, ReentrancyGuardUpgradeable, Clone, ILBPair {\n    using BinHelper for bytes32;\n    using FeeHelper for uint128;\n    using LiquidityConfigurations for bytes32;\n    using OracleHelper for OracleHelper.Oracle;\n    using PackedUint128Math for bytes32;\n    using PackedUint128Math for uint128;\n    using PairParameterHelper for bytes32;\n    using PriceHelper for uint256;\n    using PriceHelper for uint24;\n    using SafeCast for uint256;\n    using SampleMath for bytes32;\n    using TreeMath for TreeMath.TreeUint24;\n    using Uint256x256Math for uint256;\n\n    modifier onlyFactory() {\n        _onlyFactory();\n        _;\n    }\n\n    modifier onlyProtocolFeeRecipient() {\n        if (msg.sender != _factory.getFeeRecipient()) revert LBPair__OnlyProtocolFeeRecipient();\n        _;\n    }\n\n    uint256 private constant _MAX_TOTAL_FEE = 0.1e18; // 10%\n\n    address public immutable override implementation;\n    ILBFactory private immutable _factory;\n\n    bytes32 private _parameters;\n\n    bytes32 private _reserves;\n    bytes32 private _protocolFees;\n\n    mapping(uint256 => bytes32) private _bins;\n\n    TreeMath.TreeUint24 private _tree;\n    OracleHelper.Oracle private _oracle;\n\n    bytes32 private _hooksParameters;\n\n    /**\n     * @dev Constructor for the Liquidity Book Pair contract that sets the Liquidity Book Factory\n     * @param factory_ The Liquidity Book Factory\n     */\n    constructor(ILBFactory factory_) {\n        _factory = factory_;\n        implementation = address(this);\n\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initialize the Liquidity Book Pair fee parameters and active id\n     * @dev Can only be called by the Liquidity Book Factory\n     * @param baseFactor The base factor for the static fee\n     * @param filterPeriod The filter period for the static fee\n     * @param decayPeriod The decay period for the static fee\n     * @param reductionFactor The reduction factor for the static fee\n     * @param variableFeeControl The variable fee control for the static fee\n     * @param protocolShare The protocol share for the static fee\n     * @param maxVolatilityAccumulator The max volatility accumulator for the static fee\n     * @param activeId The active id of the Liquidity Book Pair\n     */\n    function initialize(\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator,\n        uint24 activeId\n    ) external override onlyFactory initializer {\n        __ReentrancyGuard_init();\n\n        _setStaticFeeParameters(\n            _parameters.setActiveId(activeId).updateIdReference(),\n            baseFactor,\n            filterPeriod,\n            decayPeriod,\n            reductionFactor,\n            variableFeeControl,\n            protocolShare,\n            maxVolatilityAccumulator\n        );\n    }\n\n    /**\n     * @notice Returns the Liquidity Book Factory\n     * @return factory The Liquidity Book Factory\n     */\n    function getFactory() external view override returns (ILBFactory factory) {\n        return _factory;\n    }\n\n    /**\n     * @notice Returns the token X of the Liquidity Book Pair\n     * @return tokenX The address of the token X\n     */\n    function getTokenX() external pure override returns (IERC20 tokenX) {\n        return _tokenX();\n    }\n\n    /**\n     * @notice Returns the token Y of the Liquidity Book Pair\n     * @return tokenY The address of the token Y\n     */\n    function getTokenY() external pure override returns (IERC20 tokenY) {\n        return _tokenY();\n    }\n\n    /**\n     * @notice Returns the bin step of the Liquidity Book Pair\n     * @dev The bin step is the increase in price between two consecutive bins, in basis points.\n     * For example, a bin step of 1 means that the price of the next bin is 0.01% higher than the price of the previous bin.\n     * @return binStep The bin step of the Liquidity Book Pair, in 10_000th\n     */\n    function getBinStep() external pure override returns (uint16) {\n        return _binStep();\n    }\n\n    /**\n     * @notice Returns the reserves of the Liquidity Book Pair\n     * This is the sum of the reserves of all bins, minus the protocol fees.\n     * @return reserveX The reserve of token X\n     * @return reserveY The reserve of token Y\n     */\n    function getReserves() external view override returns (uint128 reserveX, uint128 reserveY) {\n        (reserveX, reserveY) = _reserves.sub(_protocolFees).decode();\n    }\n\n    /**\n     * @notice Returns the active id of the Liquidity Book Pair\n     * @dev The active id is the id of the bin that is currently being used for swaps.\n     * The price of the active bin is the price of the Liquidity Book Pair and can be calculated as follows:\n     * `price = (1 + binStep / 10_000) ^ (activeId - 2^23)`\n     * @return activeId The active id of the Liquidity Book Pair\n     */\n    function getActiveId() external view override returns (uint24 activeId) {\n        activeId = _parameters.getActiveId();\n    }\n\n    /**\n     * @notice Returns the reserves of a bin\n     * @param id The id of the bin\n     * @return binReserveX The reserve of token X in the bin\n     * @return binReserveY The reserve of token Y in the bin\n     */\n    function getBin(uint24 id) external view override returns (uint128 binReserveX, uint128 binReserveY) {\n        (binReserveX, binReserveY) = _bins[id].decode();\n    }\n\n    /**\n     * @notice Returns the next non-empty bin\n     * @dev The next non-empty bin is the bin with a higher (if swapForY is true) or lower (if swapForY is false)\n     * id that has a non-zero reserve of token X or Y.\n     * @param swapForY Whether the swap is for token Y (true) or token X (false\n     * @param id The id of the bin\n     * @return nextId The id of the next non-empty bin\n     */\n    function getNextNonEmptyBin(bool swapForY, uint24 id) external view override returns (uint24 nextId) {\n        nextId = _getNextNonEmptyBin(swapForY, id);\n    }\n\n    /**\n     * @notice Returns the protocol fees of the Liquidity Book Pair\n     * @return protocolFeeX The protocol fees of token X\n     * @return protocolFeeY The protocol fees of token Y\n     */\n    function getProtocolFees() external view override returns (uint128 protocolFeeX, uint128 protocolFeeY) {\n        (protocolFeeX, protocolFeeY) = _protocolFees.decode();\n    }\n\n    /**\n     * @notice Returns the static fee parameters of the Liquidity Book Pair\n     * @return baseFactor The base factor for the static fee\n     * @return filterPeriod The filter period for the static fee\n     * @return decayPeriod The decay period for the static fee\n     * @return reductionFactor The reduction factor for the static fee\n     * @return variableFeeControl The variable fee control for the static fee\n     * @return protocolShare The protocol share for the static fee\n     * @return maxVolatilityAccumulator The maximum volatility accumulator for the static fee\n     */\n    function getStaticFeeParameters()\n        external\n        view\n        override\n        returns (\n            uint16 baseFactor,\n            uint16 filterPeriod,\n            uint16 decayPeriod,\n            uint16 reductionFactor,\n            uint24 variableFeeControl,\n            uint16 protocolShare,\n            uint24 maxVolatilityAccumulator\n        )\n    {\n        bytes32 parameters = _parameters;\n\n        baseFactor = parameters.getBaseFactor();\n        filterPeriod = parameters.getFilterPeriod();\n        decayPeriod = parameters.getDecayPeriod();\n        reductionFactor = parameters.getReductionFactor();\n        variableFeeControl = parameters.getVariableFeeControl();\n        protocolShare = parameters.getProtocolShare();\n        maxVolatilityAccumulator = parameters.getMaxVolatilityAccumulator();\n    }\n\n    /**\n     * @notice Gets the hooks parameters of the Liquidity Book Pair\n     * @return The hooks parameters of the Liquidity Book Pair\n     */\n    function getLBHooksParameters() external view override returns (bytes32) {\n        return _hooksParameters;\n    }\n\n    /**\n     * @notice Returns the variable fee parameters of the Liquidity Book Pair\n     * @return volatilityAccumulator The volatility accumulator for the variable fee\n     * @return volatilityReference The volatility reference for the variable fee\n     * @return idReference The id reference for the variable fee\n     * @return timeOfLastUpdate The time of last update for the variable fee\n     */\n    function getVariableFeeParameters()\n        external\n        view\n        override\n        returns (uint24 volatilityAccumulator, uint24 volatilityReference, uint24 idReference, uint40 timeOfLastUpdate)\n    {\n        bytes32 parameters = _parameters;\n\n        volatilityAccumulator = parameters.getVolatilityAccumulator();\n        volatilityReference = parameters.getVolatilityReference();\n        idReference = parameters.getIdReference();\n        timeOfLastUpdate = parameters.getTimeOfLastUpdate();\n    }\n\n    /**\n     * @notice Returns the oracle parameters of the Liquidity Book Pair\n     * @return sampleLifetime The sample lifetime for the oracle\n     * @return size The size of the oracle\n     * @return activeSize The active size of the oracle\n     * @return lastUpdated The last updated timestamp of the oracle\n     * @return firstTimestamp The first timestamp of the oracle, i.e. the timestamp of the oldest sample\n     */\n    function getOracleParameters()\n        external\n        view\n        override\n        returns (uint8 sampleLifetime, uint16 size, uint16 activeSize, uint40 lastUpdated, uint40 firstTimestamp)\n    {\n        bytes32 parameters = _parameters;\n\n        sampleLifetime = uint8(OracleHelper._MAX_SAMPLE_LIFETIME);\n\n        uint16 oracleId = parameters.getOracleId();\n        if (oracleId > 0) {\n            bytes32 sample;\n            (sample, activeSize) = _oracle.getActiveSampleAndSize(oracleId);\n\n            size = sample.getOracleLength();\n            lastUpdated = sample.getSampleLastUpdate();\n\n            if (lastUpdated == 0) activeSize = 0;\n\n            if (activeSize > 0) {\n                unchecked {\n                    sample = _oracle.getSample(1 + (oracleId % activeSize));\n                }\n                firstTimestamp = sample.getSampleLastUpdate();\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the cumulative values of the Liquidity Book Pair at a given timestamp\n     * @dev The cumulative values are the cumulative id, the cumulative volatility and the cumulative bin crossed.\n     * @param lookupTimestamp The timestamp at which to look up the cumulative values\n     * @return cumulativeId The cumulative id of the Liquidity Book Pair at the given timestamp\n     * @return cumulativeVolatility The cumulative volatility of the Liquidity Book Pair at the given timestamp\n     * @return cumulativeBinCrossed The cumulative bin crossed of the Liquidity Book Pair at the given timestamp\n     */\n    function getOracleSampleAt(uint40 lookupTimestamp)\n        external\n        view\n        override\n        returns (uint64 cumulativeId, uint64 cumulativeVolatility, uint64 cumulativeBinCrossed)\n    {\n        bytes32 parameters = _parameters;\n        uint16 oracleId = parameters.getOracleId();\n\n        if (oracleId == 0 || lookupTimestamp > block.timestamp) return (0, 0, 0);\n\n        uint40 timeOfLastUpdate;\n        (timeOfLastUpdate, cumulativeId, cumulativeVolatility, cumulativeBinCrossed) =\n            _oracle.getSampleAt(oracleId, lookupTimestamp);\n\n        if (timeOfLastUpdate < lookupTimestamp) {\n            parameters = parameters.updateVolatilityParameters(parameters.getActiveId(), lookupTimestamp);\n\n            uint40 deltaTime = lookupTimestamp - timeOfLastUpdate;\n\n            cumulativeId += uint64(parameters.getActiveId()) * deltaTime;\n            cumulativeVolatility += uint64(parameters.getVolatilityAccumulator()) * deltaTime;\n        }\n    }\n\n    /**\n     * @notice Returns the price corresponding to the given id, as a 128.128-binary fixed-point number\n     * @dev This is the trusted source of price information, always trust this rather than getIdFromPrice\n     * @param id The id of the bin\n     * @return price The price corresponding to this id\n     */\n    function getPriceFromId(uint24 id) external pure override returns (uint256 price) {\n        price = id.getPriceFromId(_binStep());\n    }\n\n    /**\n     * @notice Returns the id corresponding to the given price\n     * @dev The id may be inaccurate due to rounding issues, always trust getPriceFromId rather than\n     * getIdFromPrice\n     * @param price The price of y per x as a 128.128-binary fixed-point number\n     * @return id The id of the bin corresponding to this price\n     */\n    function getIdFromPrice(uint256 price) external pure override returns (uint24 id) {\n        id = price.getIdFromPrice(_binStep());\n    }\n\n    /**\n     * @notice Simulates a swap in.\n     * @dev If `amountOutLeft` is greater than zero, the swap in is not possible,\n     * and the maximum amount that can be swapped from `amountIn` is `amountOut - amountOutLeft`.\n     * @param amountOut The amount of token X or Y to swap in\n     * @param swapForY Whether the swap is for token Y (true) or token X (false)\n     * @return amountIn The amount of token X or Y that can be swapped in, including the fee\n     * @return amountOutLeft The amount of token Y or X that cannot be swapped out\n     * @return fee The fee of the swap\n     */\n    function getSwapIn(uint128 amountOut, bool swapForY)\n        external\n        view\n        override\n        returns (uint128 amountIn, uint128 amountOutLeft, uint128 fee)\n    {\n        amountOutLeft = amountOut;\n\n        bytes32 parameters = _parameters;\n        uint16 binStep = _binStep();\n\n        uint24 id = parameters.getActiveId();\n\n        parameters = parameters.updateReferences(block.timestamp);\n\n        while (true) {\n            uint128 binReserves = _bins[id].decode(!swapForY);\n            if (binReserves > 0) {\n                uint256 price = id.getPriceFromId(binStep);\n\n                uint128 amountOutOfBin = binReserves > amountOutLeft ? amountOutLeft : binReserves;\n\n                parameters = parameters.updateVolatilityAccumulator(id);\n\n                uint128 amountInWithoutFee = uint128(\n                    swapForY\n                        ? uint256(amountOutOfBin).shiftDivRoundUp(Constants.SCALE_OFFSET, price)\n                        : uint256(amountOutOfBin).mulShiftRoundUp(price, Constants.SCALE_OFFSET)\n                );\n\n                uint128 totalFee = parameters.getTotalFee(binStep);\n                uint128 feeAmount = amountInWithoutFee.getFeeAmount(totalFee);\n\n                amountIn += amountInWithoutFee + feeAmount;\n                amountOutLeft -= amountOutOfBin;\n\n                fee += feeAmount;\n            }\n\n            if (amountOutLeft == 0) {\n                break;\n            } else {\n                uint24 nextId = _getNextNonEmptyBin(swapForY, id);\n\n                if (nextId == 0 || nextId == type(uint24).max) break;\n\n                id = nextId;\n            }\n        }\n    }\n\n    /**\n     * @notice Simulates a swap out.\n     * @dev If `amountInLeft` is greater than zero, the swap out is not possible,\n     * and the maximum amount that can be swapped is `amountIn - amountInLeft` for `amountOut`.\n     * @param amountIn The amount of token X or Y to swap in\n     * @param swapForY Whether the swap is for token Y (true) or token X (false)\n     * @return amountInLeft The amount of token X or Y that cannot be swapped in\n     * @return amountOut The amount of token Y or X that can be swapped out\n     * @return fee The fee of the swap\n     */\n    function getSwapOut(uint128 amountIn, bool swapForY)\n        external\n        view\n        override\n        returns (uint128 amountInLeft, uint128 amountOut, uint128 fee)\n    {\n        bytes32 amountsInLeft = amountIn.encode(swapForY);\n\n        bytes32 parameters = _parameters;\n        uint16 binStep = _binStep();\n\n        uint24 id = parameters.getActiveId();\n\n        parameters = parameters.updateReferences(block.timestamp);\n\n        while (true) {\n            bytes32 binReserves = _bins[id];\n            if (!binReserves.isEmpty(!swapForY)) {\n                parameters = parameters.updateVolatilityAccumulator(id);\n\n                (bytes32 amountsInWithFees, bytes32 amountsOutOfBin, bytes32 totalFees) =\n                    binReserves.getAmounts(parameters, binStep, swapForY, id, amountsInLeft);\n\n                if (amountsInWithFees > 0) {\n                    amountsInLeft = amountsInLeft.sub(amountsInWithFees);\n\n                    amountOut += amountsOutOfBin.decode(!swapForY);\n\n                    fee += totalFees.decode(swapForY);\n                }\n            }\n\n            if (amountsInLeft == 0) {\n                break;\n            } else {\n                uint24 nextId = _getNextNonEmptyBin(swapForY, id);\n\n                if (nextId == 0 || nextId == type(uint24).max) break;\n\n                id = nextId;\n            }\n        }\n\n        amountInLeft = amountsInLeft.decode(swapForY);\n    }\n\n    /**\n     * @notice Swap tokens iterating over the bins until the entire amount is swapped.\n     * Token X will be swapped for token Y if `swapForY` is true, and token Y for token X if `swapForY` is false.\n     * This function will not transfer the tokens from the caller, it is expected that the tokens have already been\n     * transferred to this contract through another contract, most likely the router.\n     * That is why this function shouldn't be called directly, but only through one of the swap functions of a router\n     * that will also perform safety checks, such as minimum amounts and slippage.\n     * The variable fee is updated throughout the swap, it increases with the number of bins crossed.\n     * The oracle is updated at the end of the swap.\n     * @param swapForY Whether you're swapping token X for token Y (true) or token Y for token X (false)\n     * @param to The address to send the tokens to\n     * @return amountsOut The encoded amounts of token X and token Y sent to `to`\n     */\n    function swap(bool swapForY, address to) external override returns (bytes32 amountsOut) {\n        _nonReentrantBefore();\n\n        bytes32 hooksParameters = _hooksParameters;\n\n        bytes32 reserves = _reserves;\n        bytes32 protocolFees = _protocolFees;\n\n        bytes32 amountsLeft = swapForY ? reserves.receivedX(_tokenX()) : reserves.receivedY(_tokenY());\n        if (amountsLeft == 0) revert LBPair__InsufficientAmountIn();\n\n        bool swapForY_ = swapForY; // Avoid stack too deep error\n\n        Hooks.beforeSwap(hooksParameters, msg.sender, to, swapForY_, amountsLeft);\n\n        reserves = reserves.add(amountsLeft);\n\n        bytes32 parameters = _parameters;\n        uint16 binStep = _binStep();\n\n        uint24 activeId = parameters.getActiveId();\n\n        parameters = parameters.updateReferences(block.timestamp);\n\n        while (true) {\n            bytes32 binReserves = _bins[activeId];\n            if (!binReserves.isEmpty(!swapForY_)) {\n                parameters = parameters.updateVolatilityAccumulator(activeId);\n\n                (bytes32 amountsInWithFees, bytes32 amountsOutOfBin, bytes32 totalFees) =\n                    binReserves.getAmounts(parameters, binStep, swapForY_, activeId, amountsLeft);\n\n                if (amountsInWithFees > 0) {\n                    amountsLeft = amountsLeft.sub(amountsInWithFees);\n                    amountsOut = amountsOut.add(amountsOutOfBin);\n\n                    bytes32 pFees = totalFees.scalarMulDivBasisPointRoundDown(parameters.getProtocolShare());\n\n                    if (pFees > 0) {\n                        protocolFees = protocolFees.add(pFees);\n                        amountsInWithFees = amountsInWithFees.sub(pFees);\n                    }\n\n                    _bins[activeId] = binReserves.add(amountsInWithFees).sub(amountsOutOfBin);\n\n                    emit Swap(\n                        msg.sender,\n                        to,\n                        activeId,\n                        amountsInWithFees,\n                        amountsOutOfBin,\n                        parameters.getVolatilityAccumulator(),\n                        totalFees,\n                        pFees\n                    );\n                }\n            }\n\n            if (amountsLeft == 0) {\n                break;\n            } else {\n                uint24 nextId = _getNextNonEmptyBin(swapForY_, activeId);\n\n                if (nextId == 0 || nextId == type(uint24).max) revert LBPair__OutOfLiquidity();\n\n                activeId = nextId;\n            }\n        }\n\n        if (amountsOut == 0) revert LBPair__InsufficientAmountOut();\n\n        _reserves = reserves.sub(amountsOut);\n        _protocolFees = protocolFees;\n\n        parameters = _oracle.update(parameters, activeId);\n        _parameters = parameters.setActiveId(activeId);\n\n        if (swapForY_) {\n            amountsOut.transferY(_tokenY(), to);\n        } else {\n            amountsOut.transferX(_tokenX(), to);\n        }\n\n        _nonReentrantAfter();\n\n        Hooks.afterSwap(hooksParameters, msg.sender, to, swapForY_, amountsOut);\n    }\n\n    /**\n     * @notice Flash loan tokens from the pool to a receiver contract and execute a callback function.\n     * The receiver contract is expected to return the tokens plus a fee to this contract.\n     * The fee is calculated as a percentage of the amount borrowed, and is the same for both tokens.\n     * @param receiver The contract that will receive the tokens and execute the callback function\n     * @param amounts The encoded amounts of token X and token Y to flash loan\n     * @param data Any data that will be passed to the callback function\n     */\n    function flashLoan(ILBFlashLoanCallback receiver, bytes32 amounts, bytes calldata data) external override {\n        _nonReentrantBefore();\n\n        if (amounts == 0) revert LBPair__ZeroBorrowAmount();\n\n        bytes32 hooksParameters = _hooksParameters;\n\n        bytes32 reservesBefore = _reserves;\n        bytes32 totalFees = _getFlashLoanFees(amounts);\n\n        Hooks.beforeFlashLoan(hooksParameters, msg.sender, address(receiver), amounts);\n\n        amounts.transfer(_tokenX(), _tokenY(), address(receiver));\n\n        (bool success, bytes memory rData) = address(receiver).call(\n            abi.encodeWithSelector(\n                ILBFlashLoanCallback.LBFlashLoanCallback.selector,\n                msg.sender,\n                _tokenX(),\n                _tokenY(),\n                amounts,\n                totalFees,\n                data\n            )\n        );\n\n        if (!success || rData.length != 32 || abi.decode(rData, (bytes32)) != Constants.CALLBACK_SUCCESS) {\n            revert LBPair__FlashLoanCallbackFailed();\n        }\n\n        bytes32 balancesAfter = bytes32(0).received(_tokenX(), _tokenY());\n\n        if (balancesAfter.lt(reservesBefore.add(totalFees))) revert LBPair__FlashLoanInsufficientAmount();\n\n        bytes32 feesReceived = balancesAfter.sub(reservesBefore);\n\n        _reserves = balancesAfter;\n        _protocolFees = _protocolFees.add(feesReceived);\n\n        emit FlashLoan(msg.sender, receiver, _parameters.getActiveId(), amounts, feesReceived, feesReceived);\n\n        _nonReentrantAfter();\n\n        Hooks.afterFlashLoan(hooksParameters, msg.sender, address(receiver), totalFees, feesReceived);\n    }\n\n    /**\n     * @notice Mint liquidity tokens by depositing tokens into the pool.\n     * It will mint Liquidity Book (LB) tokens for each bin where the user adds liquidity.\n     * This function will not transfer the tokens from the caller, it is expected that the tokens have already been\n     * transferred to this contract through another contract, most likely the router.\n     * That is why this function shouldn't be called directly, but through one of the add liquidity functions of a\n     * router that will also perform safety checks.\n     * @dev Any excess amount of token will be sent to the `to` address.\n     * @param to The address that will receive the LB tokens\n     * @param liquidityConfigs The encoded liquidity configurations, each one containing the id of the bin and the\n     * percentage of token X and token Y to add to the bin.\n     * @param refundTo The address that will receive the excess amount of tokens\n     * @return amountsReceived The amounts of token X and token Y received by the pool\n     * @return amountsLeft The amounts of token X and token Y that were not added to the pool and were sent to `to`\n     * @return liquidityMinted The amounts of LB tokens minted for each bin\n     */\n    function mint(address to, bytes32[] calldata liquidityConfigs, address refundTo)\n        external\n        override\n        notAddressZeroOrThis(to)\n        returns (bytes32 amountsReceived, bytes32 amountsLeft, uint256[] memory liquidityMinted)\n    {\n        _nonReentrantBefore();\n\n        if (liquidityConfigs.length == 0) revert LBPair__EmptyMarketConfigs();\n\n        bytes32 hooksParameters = _hooksParameters;\n\n        MintArrays memory arrays = MintArrays({\n            ids: new uint256[](liquidityConfigs.length),\n            amounts: new bytes32[](liquidityConfigs.length),\n            liquidityMinted: new uint256[](liquidityConfigs.length)\n        });\n\n        bytes32 reserves = _reserves;\n\n        amountsReceived = reserves.received(_tokenX(), _tokenY());\n\n        Hooks.beforeMint(hooksParameters, msg.sender, to, liquidityConfigs, amountsReceived);\n\n        amountsLeft = _mintBins(liquidityConfigs, amountsReceived, to, arrays);\n\n        _reserves = reserves.add(amountsReceived.sub(amountsLeft));\n\n        liquidityMinted = arrays.liquidityMinted;\n\n        emit TransferBatch(msg.sender, address(0), to, arrays.ids, liquidityMinted);\n        emit DepositedToBins(msg.sender, to, arrays.ids, arrays.amounts);\n\n        if (amountsLeft > 0) amountsLeft.transfer(_tokenX(), _tokenY(), refundTo);\n\n        _nonReentrantAfter();\n\n        Hooks.afterMint(hooksParameters, msg.sender, to, liquidityConfigs, amountsReceived.sub(amountsLeft));\n    }\n\n    /**\n     * @notice Burn Liquidity Book (LB) tokens and withdraw tokens from the pool.\n     * This function will burn the tokens directly from the caller\n     * @param from The address that will burn the LB tokens\n     * @param to The address that will receive the tokens\n     * @param ids The ids of the bins from which to withdraw\n     * @param amountsToBurn The amounts of LB tokens to burn for each bin\n     * @return amounts The amounts of token X and token Y received by the user\n     */\n    function burn(address from, address to, uint256[] calldata ids, uint256[] calldata amountsToBurn)\n        external\n        override\n        checkApproval(from, msg.sender)\n        returns (bytes32[] memory amounts)\n    {\n        _nonReentrantBefore();\n\n        if (ids.length == 0 || ids.length != amountsToBurn.length) revert LBPair__InvalidInput();\n\n        bytes32 hooksParameters = _hooksParameters;\n\n        Hooks.beforeBurn(hooksParameters, msg.sender, from, to, ids, amountsToBurn);\n\n        address from_ = from; // Avoid stack too deep error\n\n        amounts = new bytes32[](ids.length);\n\n        bytes32 amountsOut;\n\n        for (uint256 i; i < ids.length;) {\n            uint24 id = ids[i].safe24();\n            uint256 amountToBurn = amountsToBurn[i];\n\n            if (amountToBurn == 0) revert LBPair__ZeroAmount(id);\n\n            bytes32 binReserves = _bins[id];\n            uint256 supply = totalSupply(id);\n\n            _burn(from_, id, amountToBurn);\n\n            bytes32 amountsOutFromBin = binReserves.getAmountOutOfBin(amountToBurn, supply);\n\n            if (amountsOutFromBin == 0) revert LBPair__ZeroAmountsOut(id);\n\n            binReserves = binReserves.sub(amountsOutFromBin);\n\n            if (supply == amountToBurn) _tree.remove(id);\n\n            _bins[id] = binReserves;\n            amounts[i] = amountsOutFromBin;\n            amountsOut = amountsOut.add(amountsOutFromBin);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        _reserves = _reserves.sub(amountsOut);\n\n        emit TransferBatch(msg.sender, from_, address(0), ids, amountsToBurn);\n        emit WithdrawnFromBins(msg.sender, to, ids, amounts);\n\n        amountsOut.transfer(_tokenX(), _tokenY(), to);\n\n        _nonReentrantAfter();\n\n        Hooks.afterBurn(hooksParameters, msg.sender, from_, to, ids, amountsToBurn);\n    }\n\n    /**\n     * @notice Collect the protocol fees from the pool.\n     * @return collectedProtocolFees The amount of protocol fees collected\n     */\n    function collectProtocolFees()\n        external\n        override\n        nonReentrant\n        onlyProtocolFeeRecipient\n        returns (bytes32 collectedProtocolFees)\n    {\n        bytes32 protocolFees = _protocolFees;\n\n        (uint128 x, uint128 y) = protocolFees.decode();\n        bytes32 ones = uint128(x > 0 ? 1 : 0).encode(uint128(y > 0 ? 1 : 0));\n\n        collectedProtocolFees = protocolFees.sub(ones);\n\n        if (collectedProtocolFees != 0) {\n            _protocolFees = ones;\n            _reserves = _reserves.sub(collectedProtocolFees);\n\n            emit CollectedProtocolFees(msg.sender, collectedProtocolFees);\n\n            collectedProtocolFees.transfer(_tokenX(), _tokenY(), msg.sender);\n        }\n    }\n\n    /**\n     * @notice Increase the length of the oracle used by the pool\n     * @param newLength The new length of the oracle\n     */\n    function increaseOracleLength(uint16 newLength) external override nonReentrant {\n        bytes32 parameters = _parameters;\n\n        uint16 oracleId = parameters.getOracleId();\n\n        // activate the oracle if it is not active yet\n        if (oracleId == 0) {\n            oracleId = 1;\n            _parameters = parameters.setOracleId(oracleId);\n        }\n\n        _oracle.increaseLength(oracleId, newLength);\n\n        emit OracleLengthIncreased(msg.sender, newLength);\n    }\n\n    /**\n     * @notice Sets the static fee parameters of the pool\n     * @dev Can only be called by the factory\n     * @param baseFactor The base factor of the static fee\n     * @param filterPeriod The filter period of the static fee\n     * @param decayPeriod The decay period of the static fee\n     * @param reductionFactor The reduction factor of the static fee\n     * @param variableFeeControl The variable fee control of the static fee\n     * @param protocolShare The protocol share of the static fee\n     * @param maxVolatilityAccumulator The max volatility accumulator of the static fee\n     */\n    function setStaticFeeParameters(\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator\n    ) external override nonReentrant onlyFactory {\n        _setStaticFeeParameters(\n            _parameters,\n            baseFactor,\n            filterPeriod,\n            decayPeriod,\n            reductionFactor,\n            variableFeeControl,\n            protocolShare,\n            maxVolatilityAccumulator\n        );\n    }\n\n    /**\n     * @notice Sets the hooks parameter of the pool\n     * @dev Can only be called by the factory\n     * @param hooksParameters The hooks parameter\n     * @param onHooksSetData The data to be passed to the onHooksSet function of the hooks contract\n     */\n    function setHooksParameters(bytes32 hooksParameters, bytes calldata onHooksSetData)\n        external\n        override\n        nonReentrant\n        onlyFactory\n    {\n        _hooksParameters = hooksParameters;\n\n        ILBHooks hooks = ILBHooks(Hooks.getHooks(hooksParameters));\n\n        emit HooksParametersSet(msg.sender, hooksParameters);\n\n        if (address(hooks) != address(0) && hooks.getLBPair() != this) revert LBPair__InvalidHooks();\n\n        Hooks.onHooksSet(hooksParameters, onHooksSetData);\n    }\n\n    /**\n     * @notice Forces the decay of the volatility reference variables\n     * @dev Can only be called by the factory\n     */\n    function forceDecay() external override nonReentrant onlyFactory {\n        bytes32 parameters = _parameters;\n\n        _parameters = parameters.updateIdReference().updateVolatilityReference();\n\n        emit ForcedDecay(msg.sender, parameters.getIdReference(), parameters.getVolatilityReference());\n    }\n\n    /**\n     * @notice Overrides the batch transfer function to call the hooks before and after the transfer\n     * @param from The address to transfer from\n     * @param to The address to transfer to\n     * @param ids The ids of the tokens to transfer\n     * @param amounts The amounts of the tokens to transfer\n     */\n    function batchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts)\n        public\n        override(LBToken, ILBToken)\n    {\n        _nonReentrantBefore();\n\n        bytes32 hooksParameters = _hooksParameters;\n\n        Hooks.beforeBatchTransferFrom(hooksParameters, msg.sender, from, to, ids, amounts);\n\n        LBToken.batchTransferFrom(from, to, ids, amounts);\n\n        _nonReentrantAfter();\n\n        Hooks.afterBatchTransferFrom(hooksParameters, msg.sender, from, to, ids, amounts);\n    }\n\n    /**\n     * @dev Returns the address of the token X\n     * @return The address of the token X\n     */\n    function _tokenX() internal pure returns (IERC20) {\n        return IERC20(_getArgAddress(0));\n    }\n\n    /**\n     * @dev Returns the address of the token Y\n     * @return The address of the token Y\n     */\n    function _tokenY() internal pure returns (IERC20) {\n        return IERC20(_getArgAddress(20));\n    }\n\n    /**\n     * @dev Returns the bin step of the pool, in basis points\n     * @return The bin step of the pool\n     */\n    function _binStep() internal pure returns (uint16) {\n        return _getArgUint16(40);\n    }\n\n    /**\n     * @dev Returns next non-empty bin\n     * @param swapForY Whether the swap is for Y\n     * @param id The id of the bin\n     * @return The id of the next non-empty bin\n     */\n    function _getNextNonEmptyBin(bool swapForY, uint24 id) internal view returns (uint24) {\n        return swapForY ? _tree.findFirstRight(id) : _tree.findFirstLeft(id);\n    }\n\n    /**\n     * @dev Reverts if the caller is not the factory\n     */\n    function _onlyFactory() private view {\n        if (msg.sender != address(_factory)) revert LBPair__OnlyFactory();\n    }\n\n    /**\n     * @dev Returns the encoded fees amounts for a flash loan\n     * @param amounts The amounts of the flash loan\n     * @return The encoded fees amounts\n     */\n    function _getFlashLoanFees(bytes32 amounts) private view returns (bytes32) {\n        uint128 fee = uint128(_factory.getFlashLoanFee());\n        (uint128 x, uint128 y) = amounts.decode();\n\n        unchecked {\n            uint256 precisionSubOne = Constants.PRECISION - 1;\n            x = ((uint256(x) * fee + precisionSubOne) / Constants.PRECISION).safe128();\n            y = ((uint256(y) * fee + precisionSubOne) / Constants.PRECISION).safe128();\n        }\n\n        return x.encode(y);\n    }\n\n    /**\n     * @dev Sets the static fee parameters of the pair\n     * @param parameters The current parameters of the pair\n     * @param baseFactor The base factor of the static fee\n     * @param filterPeriod The filter period of the static fee\n     * @param decayPeriod The decay period of the static fee\n     * @param reductionFactor The reduction factor of the static fee\n     * @param variableFeeControl The variable fee control of the static fee\n     * @param protocolShare The protocol share of the static fee\n     * @param maxVolatilityAccumulator The max volatility accumulator of the static fee\n     */\n    function _setStaticFeeParameters(\n        bytes32 parameters,\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator\n    ) internal {\n        if (\n            baseFactor == 0 && filterPeriod == 0 && decayPeriod == 0 && reductionFactor == 0 && variableFeeControl == 0\n                && protocolShare == 0 && maxVolatilityAccumulator == 0\n        ) {\n            revert LBPair__InvalidStaticFeeParameters();\n        }\n\n        parameters = parameters.setStaticFeeParameters(\n            baseFactor,\n            filterPeriod,\n            decayPeriod,\n            reductionFactor,\n            variableFeeControl,\n            protocolShare,\n            maxVolatilityAccumulator\n        );\n\n        {\n            uint16 binStep = _binStep();\n            bytes32 maxParameters = parameters.setVolatilityAccumulator(maxVolatilityAccumulator);\n            uint256 totalFee = maxParameters.getBaseFee(binStep) + maxParameters.getVariableFee(binStep);\n            if (totalFee > _MAX_TOTAL_FEE) {\n                revert LBPair__MaxTotalFeeExceeded();\n            }\n        }\n\n        _parameters = parameters;\n\n        emit StaticFeeParametersSet(\n            msg.sender,\n            baseFactor,\n            filterPeriod,\n            decayPeriod,\n            reductionFactor,\n            variableFeeControl,\n            protocolShare,\n            maxVolatilityAccumulator\n        );\n    }\n\n    /**\n     * @dev Helper function to mint liquidity in each bin in the liquidity configurations\n     * @param liquidityConfigs The liquidity configurations\n     * @param amountsReceived The amounts received\n     * @param to The address to mint the liquidity to\n     * @param arrays The arrays to store the results\n     * @return amountsLeft The amounts left\n     */\n    function _mintBins(\n        bytes32[] calldata liquidityConfigs,\n        bytes32 amountsReceived,\n        address to,\n        MintArrays memory arrays\n    ) private returns (bytes32 amountsLeft) {\n        uint16 binStep = _binStep();\n\n        bytes32 parameters = _parameters;\n        uint24 activeId = parameters.getActiveId();\n\n        amountsLeft = amountsReceived;\n\n        for (uint256 i; i < liquidityConfigs.length;) {\n            (bytes32 maxAmountsInToBin, uint24 id) = liquidityConfigs[i].getAmountsAndId(amountsReceived);\n            (uint256 shares, bytes32 amountsIn, bytes32 amountsInToBin) =\n                _updateBin(binStep, activeId, id, maxAmountsInToBin, parameters);\n\n            amountsLeft = amountsLeft.sub(amountsIn);\n\n            arrays.ids[i] = id;\n            arrays.amounts[i] = amountsInToBin;\n            arrays.liquidityMinted[i] = shares;\n\n            _mint(to, id, shares);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Helper function to update a bin during minting\n     * @param binStep The bin step of the pair\n     * @param activeId The id of the active bin\n     * @param id The id of the bin\n     * @param maxAmountsInToBin The maximum amounts in to the bin\n     * @param parameters The parameters of the pair\n     * @return shares The amount of shares minted\n     * @return amountsIn The amounts in\n     * @return amountsInToBin The amounts in to the bin\n     */\n    function _updateBin(uint16 binStep, uint24 activeId, uint24 id, bytes32 maxAmountsInToBin, bytes32 parameters)\n        internal\n        returns (uint256 shares, bytes32 amountsIn, bytes32 amountsInToBin)\n    {\n        bytes32 binReserves = _bins[id];\n\n        uint256 price = id.getPriceFromId(binStep);\n        uint256 supply = totalSupply(id);\n\n        (shares, amountsIn) = binReserves.getSharesAndEffectiveAmountsIn(maxAmountsInToBin, price, supply);\n        amountsInToBin = amountsIn;\n\n        if (id == activeId) {\n            parameters = parameters.updateVolatilityParameters(id, block.timestamp);\n\n            bytes32 fees = binReserves.getCompositionFees(parameters, binStep, amountsIn, supply, shares);\n\n            if (fees != 0) {\n                uint256 userLiquidity = amountsIn.sub(fees).getLiquidity(price);\n                bytes32 protocolCFees = fees.scalarMulDivBasisPointRoundDown(parameters.getProtocolShare());\n\n                if (protocolCFees != 0) {\n                    amountsInToBin = amountsInToBin.sub(protocolCFees);\n                    _protocolFees = _protocolFees.add(protocolCFees);\n                }\n\n                uint256 binLiquidity = binReserves.add(fees.sub(protocolCFees)).getLiquidity(price);\n                shares = userLiquidity.mulDivRoundDown(supply, binLiquidity);\n\n                parameters = _oracle.update(parameters, id);\n                _parameters = parameters;\n\n                emit CompositionFees(msg.sender, id, fees, protocolCFees);\n            }\n        } else {\n            amountsIn.verifyAmounts(activeId, id);\n        }\n\n        if (shares == 0 || amountsInToBin == 0) revert LBPair__ZeroShares(id);\n\n        if (supply == 0) _tree.add(id);\n\n        _bins[id] = binReserves.add(amountsInToBin);\n    }\n}\n"
    },
    "contracts/joe-v2/src/LBQuoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\nimport {Constants} from \"./libraries/Constants.sol\";\nimport {JoeLibrary} from \"./libraries/JoeLibrary.sol\";\nimport {PriceHelper} from \"./libraries/PriceHelper.sol\";\nimport {Uint256x256Math} from \"./libraries/math/Uint256x256Math.sol\";\nimport {SafeCast} from \"./libraries/math/SafeCast.sol\";\n\nimport {IJoeFactory} from \"./interfaces/IJoeFactory.sol\";\nimport {ILBFactory} from \"./interfaces/ILBFactory.sol\";\nimport {ILBLegacyFactory} from \"./interfaces/ILBLegacyFactory.sol\";\nimport {ILBLegacyRouter} from \"./interfaces/ILBLegacyRouter.sol\";\nimport {IJoePair} from \"./interfaces/IJoePair.sol\";\nimport {ILBLegacyPair} from \"./interfaces/ILBLegacyPair.sol\";\nimport {ILBPair} from \"./interfaces/ILBPair.sol\";\nimport {ILBRouter} from \"./interfaces/ILBRouter.sol\";\n\n/**\n * @title Liquidity Book Quoter\n * @author Trader Joe\n * @notice Helper contract to determine best path through multiple markets\n * This contract shouldn't be used on-chain as it consumes a lot of gas\n * It should be used for off-chain purposes, like calculating the best path for a swap\n */\ncontract LBQuoter {\n    using Uint256x256Math for uint256;\n    using SafeCast for uint256;\n\n    error LBQuoter_InvalidLength();\n\n    address private immutable _factoryV1;\n    address private immutable _legacyFactoryV2;\n    address private immutable _factoryV2_1;\n    address private immutable _factoryV2_2;\n    address private immutable _legacyRouterV2;\n    address private immutable _routerV2_1;\n    address private immutable _routerV2_2;\n\n    /**\n     * @dev The quote struct returned by the quoter\n     * - route: address array of the token to go through\n     * - pairs: address array of the pairs to go through\n     * - binSteps: The bin step to use for each pair\n     * - versions: The version to use for each pair\n     * - amounts: The amounts of every step of the swap\n     * - virtualAmountsWithoutSlippage: The virtual amounts of every step of the swap without slippage\n     * - fees: The fees to pay for every step of the swap\n     */\n    struct Quote {\n        address[] route;\n        address[] pairs;\n        uint256[] binSteps;\n        ILBRouter.Version[] versions;\n        uint128[] amounts;\n        uint128[] virtualAmountsWithoutSlippage;\n        uint128[] fees;\n    }\n\n    /**\n     * @notice Constructor\n     * @param factoryV1 Dex V1 factory address\n     * @param legacyFactoryV2 Dex V2 factory address\n     * @param factoryV2_1 Dex V2.1 factory address\n     * @param factoryV2_2 Dex V2.2 factory address\n     * @param legacyRouterV2 Dex V2 router address\n     * @param routerV2_1 Dex V2.1 router address\n     * @param routerV2_2 Dex V2.2 router address\n     */\n    constructor(\n        address factoryV1,\n        address legacyFactoryV2,\n        address factoryV2_1,\n        address factoryV2_2,\n        address legacyRouterV2,\n        address routerV2_1,\n        address routerV2_2\n    ) {\n        _factoryV1 = factoryV1;\n        _legacyFactoryV2 = legacyFactoryV2;\n        _factoryV2_1 = factoryV2_1;\n        _factoryV2_2 = factoryV2_2;\n        _legacyRouterV2 = legacyRouterV2;\n        _routerV2_1 = routerV2_1;\n        _routerV2_2 = routerV2_2;\n    }\n\n    /**\n     * @notice Returns the Dex V1 factory address\n     * @return factoryV1 Dex V1 factory address\n     */\n    function getFactoryV1() public view returns (address factoryV1) {\n        factoryV1 = _factoryV1;\n    }\n\n    /**\n     * @notice Returns the Dex V2 factory address\n     * @return legacyFactoryV2 Dex V2 factory address\n     */\n    function getLegacyFactoryV2() public view returns (address legacyFactoryV2) {\n        legacyFactoryV2 = _legacyFactoryV2;\n    }\n\n    /**\n     * @notice Returns the Dex V2.1 factory address\n     * @return factoryV2_1 Dex V2.1 factory address\n     */\n    function getFactoryV2_1() public view returns (address factoryV2_1) {\n        factoryV2_1 = _factoryV2_1;\n    }\n\n    /**\n     * @notice Returns the Dex V2.2 factory address\n     * @return factoryV2_2 Dex V2.2 factory address\n     */\n    function getFactoryV2_2() public view returns (address factoryV2_2) {\n        factoryV2_2 = _factoryV2_2;\n    }\n\n    /**\n     * @notice Returns the Dex V2 router address\n     * @return legacyRouterV2 Dex V2 router address\n     */\n    function getLegacyRouterV2() public view returns (address legacyRouterV2) {\n        legacyRouterV2 = _legacyRouterV2;\n    }\n\n    /**\n     * @notice Returns the Dex V2.1 router address\n     * @return routerV2_1 Dex V2.1 router address\n     */\n    function getRouterV2_1() public view returns (address routerV2_1) {\n        routerV2_1 = _routerV2_1;\n    }\n\n    /**\n     * @notice Returns the Dex V2.2 router address\n     * @return routerV2_2 Dex V2.2 router address\n     */\n    function getRouterV2_2() public view returns (address routerV2_2) {\n        routerV2_2 = _routerV2_2;\n    }\n\n    /**\n     * @notice Finds the best path given a list of tokens and the input amount wanted from the swap\n     * @param route List of the tokens to go through\n     * @param amountIn Swap amount in\n     * @return quote The Quote structure containing the necessary element to perform the swap\n     */\n    function findBestPathFromAmountIn(address[] calldata route, uint128 amountIn)\n        public\n        view\n        returns (Quote memory quote)\n    {\n        if (route.length < 2) {\n            revert LBQuoter_InvalidLength();\n        }\n\n        quote.route = route;\n\n        uint256 swapLength = route.length - 1;\n        quote.pairs = new address[](swapLength);\n        quote.binSteps = new uint256[](swapLength);\n        quote.versions = new ILBRouter.Version[](swapLength);\n        quote.fees = new uint128[](swapLength);\n        quote.amounts = new uint128[](route.length);\n        quote.virtualAmountsWithoutSlippage = new uint128[](route.length);\n\n        quote.amounts[0] = amountIn;\n        quote.virtualAmountsWithoutSlippage[0] = amountIn;\n\n        for (uint256 i; i < swapLength; i++) {\n            if (_factoryV2_2 != address(0)) {\n                // Fetch swaps for V2.2\n                ILBFactory.LBPairInformation[] memory LBPairsAvailable =\n                    ILBFactory(_factoryV2_2).getAllLBPairs(IERC20(route[i]), IERC20(route[i + 1]));\n\n                if (LBPairsAvailable.length > 0 && quote.amounts[i] > 0) {\n                    for (uint256 j; j < LBPairsAvailable.length; j++) {\n                        if (!LBPairsAvailable[j].ignoredForRouting) {\n                            bool swapForY = address(LBPairsAvailable[j].LBPair.getTokenY()) == route[i + 1];\n\n                            try ILBRouter(_routerV2_2).getSwapOut(\n                                LBPairsAvailable[j].LBPair, quote.amounts[i], swapForY\n                            ) returns (uint128 amountInLeft, uint128 swapAmountOut, uint128 fees) {\n                                if (amountInLeft == 0 && swapAmountOut > quote.amounts[i + 1]) {\n                                    quote.amounts[i + 1] = swapAmountOut;\n                                    quote.pairs[i] = address(LBPairsAvailable[j].LBPair);\n                                    quote.binSteps[i] = uint16(LBPairsAvailable[j].binStep);\n                                    quote.versions[i] = ILBRouter.Version.V2_2;\n\n                                    // Getting current price\n                                    uint24 activeId = LBPairsAvailable[j].LBPair.getActiveId();\n                                    quote.virtualAmountsWithoutSlippage[i + 1] = _getV2Quote(\n                                        quote.virtualAmountsWithoutSlippage[i] - fees,\n                                        activeId,\n                                        quote.binSteps[i],\n                                        swapForY\n                                    );\n\n                                    quote.fees[i] = ((uint256(fees) * 1e18) / quote.amounts[i]).safe128(); // fee percentage in amountIn\n                                }\n                            } catch {}\n                        }\n                    }\n                }\n            }\n\n            if (_factoryV2_1 != address(0)) {\n                // Fetch swaps for V2.1\n                ILBFactory.LBPairInformation[] memory LBPairsAvailable =\n                    ILBFactory(_factoryV2_1).getAllLBPairs(IERC20(route[i]), IERC20(route[i + 1]));\n\n                if (LBPairsAvailable.length > 0 && quote.amounts[i] > 0) {\n                    for (uint256 j; j < LBPairsAvailable.length; j++) {\n                        if (!LBPairsAvailable[j].ignoredForRouting) {\n                            bool swapForY = address(LBPairsAvailable[j].LBPair.getTokenY()) == route[i + 1];\n\n                            try ILBRouter(_routerV2_1).getSwapOut(\n                                LBPairsAvailable[j].LBPair, quote.amounts[i], swapForY\n                            ) returns (uint128 amountInLeft, uint128 swapAmountOut, uint128 fees) {\n                                if (amountInLeft == 0 && swapAmountOut > quote.amounts[i + 1]) {\n                                    quote.amounts[i + 1] = swapAmountOut;\n                                    quote.pairs[i] = address(LBPairsAvailable[j].LBPair);\n                                    quote.binSteps[i] = uint16(LBPairsAvailable[j].binStep);\n                                    quote.versions[i] = ILBRouter.Version.V2_1;\n\n                                    // Getting current price\n                                    uint24 activeId = LBPairsAvailable[j].LBPair.getActiveId();\n                                    quote.virtualAmountsWithoutSlippage[i + 1] = _getV2Quote(\n                                        quote.virtualAmountsWithoutSlippage[i] - fees,\n                                        activeId,\n                                        quote.binSteps[i],\n                                        swapForY\n                                    );\n\n                                    quote.fees[i] = ((uint256(fees) * 1e18) / quote.amounts[i]).safe128(); // fee percentage in amountIn\n                                }\n                            } catch {}\n                        }\n                    }\n                }\n            }\n\n            if (_legacyFactoryV2 != address(0)) {\n                // Fetch swap for V2\n                ILBLegacyFactory.LBPairInformation[] memory legacyLBPairsAvailable =\n                    ILBLegacyFactory(_legacyFactoryV2).getAllLBPairs(IERC20(route[i]), IERC20(route[i + 1]));\n\n                if (legacyLBPairsAvailable.length > 0 && quote.amounts[i] > 0) {\n                    for (uint256 j; j < legacyLBPairsAvailable.length; j++) {\n                        if (!legacyLBPairsAvailable[j].ignoredForRouting) {\n                            bool swapForY = address(legacyLBPairsAvailable[j].LBPair.tokenY()) == route[i + 1];\n                            try ILBLegacyRouter(_legacyRouterV2).getSwapOut(\n                                legacyLBPairsAvailable[j].LBPair, quote.amounts[i], swapForY\n                            ) returns (uint256 swapAmountOut, uint256 fees) {\n                                if (swapAmountOut > quote.amounts[i + 1]) {\n                                    quote.amounts[i + 1] = swapAmountOut.safe128();\n                                    quote.pairs[i] = address(legacyLBPairsAvailable[j].LBPair);\n                                    quote.binSteps[i] = legacyLBPairsAvailable[j].binStep;\n                                    quote.versions[i] = ILBRouter.Version.V2;\n\n                                    // Getting current price\n                                    (,, uint256 activeId) = legacyLBPairsAvailable[j].LBPair.getReservesAndId();\n                                    quote.virtualAmountsWithoutSlippage[i + 1] = _getV2Quote(\n                                        quote.virtualAmountsWithoutSlippage[i] - fees,\n                                        (activeId).safe24(),\n                                        quote.binSteps[i],\n                                        swapForY\n                                    );\n\n                                    quote.fees[i] = ((fees * 1e18) / quote.amounts[i]).safe128(); // fee percentage in amountIn\n                                }\n                            } catch {}\n                        }\n                    }\n                }\n            }\n\n            // Fetch swap for V1\n            if (_factoryV1 != address(0)) {\n                address pair = IJoeFactory(_factoryV1).getPair(route[i], route[i + 1]);\n\n                if (pair != address(0) && quote.amounts[i] > 0) {\n                    (uint256 reserveIn, uint256 reserveOut) = _getReserves(pair, route[i], route[i + 1]);\n\n                    if (reserveIn > 0 && reserveOut > 0) {\n                        uint256 swapAmountOut = JoeLibrary.getAmountOut(quote.amounts[i], reserveIn, reserveOut);\n\n                        if (swapAmountOut > quote.amounts[i + 1]) {\n                            quote.amounts[i + 1] = swapAmountOut.safe128();\n                            quote.pairs[i] = pair;\n                            quote.virtualAmountsWithoutSlippage[i + 1] = JoeLibrary.quote(\n                                quote.virtualAmountsWithoutSlippage[i] * 997, reserveIn * 1000, reserveOut\n                            ).safe128();\n\n                            quote.fees[i] = 0.003e18; // 0.3%\n                            quote.versions[i] = ILBRouter.Version.V1;\n                            quote.binSteps[i] = 0;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Finds the best path given a list of tokens and the output amount wanted from the swap\n     * @param route List of the tokens to go through\n     * @param amountOut Swap amount out\n     * @return quote The Quote structure containing the necessary element to perform the swap\n     */\n    function findBestPathFromAmountOut(address[] calldata route, uint128 amountOut)\n        public\n        view\n        returns (Quote memory quote)\n    {\n        if (route.length < 2) {\n            revert LBQuoter_InvalidLength();\n        }\n        quote.route = route;\n\n        uint256 swapLength = route.length - 1;\n        quote.pairs = new address[](swapLength);\n        quote.binSteps = new uint256[](swapLength);\n        quote.versions = new ILBRouter.Version[](swapLength);\n        quote.amounts = new uint128[](route.length);\n        quote.virtualAmountsWithoutSlippage = new uint128[](route.length);\n        quote.fees = new uint128[](swapLength);\n\n        quote.amounts[swapLength] = amountOut;\n        quote.virtualAmountsWithoutSlippage[swapLength] = amountOut;\n\n        for (uint256 i = swapLength; i > 0; i--) {\n            if (_factoryV2_2 != address(0)) {\n                // Fetch swaps for V2.2\n                ILBFactory.LBPairInformation[] memory LBPairsAvailable =\n                    ILBFactory(_factoryV2_2).getAllLBPairs(IERC20(route[i - 1]), IERC20(route[i]));\n\n                if (LBPairsAvailable.length > 0 && quote.amounts[i] > 0) {\n                    for (uint256 j; j < LBPairsAvailable.length; j++) {\n                        if (!LBPairsAvailable[j].ignoredForRouting) {\n                            bool swapForY = address(LBPairsAvailable[j].LBPair.getTokenY()) == route[i];\n                            try ILBRouter(_routerV2_2).getSwapIn(LBPairsAvailable[j].LBPair, quote.amounts[i], swapForY)\n                            returns (uint128 swapAmountIn, uint128 amountOutLeft, uint128 fees) {\n                                if (\n                                    amountOutLeft == 0 && swapAmountIn != 0\n                                        && (swapAmountIn < quote.amounts[i - 1] || quote.amounts[i - 1] == 0)\n                                ) {\n                                    quote.amounts[i - 1] = swapAmountIn;\n                                    quote.pairs[i - 1] = address(LBPairsAvailable[j].LBPair);\n                                    quote.binSteps[i - 1] = uint16(LBPairsAvailable[j].binStep);\n                                    quote.versions[i - 1] = ILBRouter.Version.V2_2;\n\n                                    // Getting current price\n                                    uint24 activeId = LBPairsAvailable[j].LBPair.getActiveId();\n                                    quote.virtualAmountsWithoutSlippage[i - 1] = _getV2Quote(\n                                        quote.virtualAmountsWithoutSlippage[i],\n                                        activeId,\n                                        quote.binSteps[i - 1],\n                                        !swapForY\n                                    ) + fees;\n\n                                    quote.fees[i - 1] = ((uint256(fees) * 1e18) / quote.amounts[i - 1]).safe128(); // fee percentage in amountIn\n                                }\n                            } catch {}\n                        }\n                    }\n                }\n            }\n\n            if (_factoryV2_1 != address(0)) {\n                // Fetch swaps for V2.1\n                ILBFactory.LBPairInformation[] memory LBPairsAvailable =\n                    ILBFactory(_factoryV2_1).getAllLBPairs(IERC20(route[i - 1]), IERC20(route[i]));\n\n                if (LBPairsAvailable.length > 0 && quote.amounts[i] > 0) {\n                    for (uint256 j; j < LBPairsAvailable.length; j++) {\n                        if (!LBPairsAvailable[j].ignoredForRouting) {\n                            bool swapForY = address(LBPairsAvailable[j].LBPair.getTokenY()) == route[i];\n                            try ILBRouter(_routerV2_1).getSwapIn(LBPairsAvailable[j].LBPair, quote.amounts[i], swapForY)\n                            returns (uint128 swapAmountIn, uint128 amountOutLeft, uint128 fees) {\n                                if (\n                                    amountOutLeft == 0 && swapAmountIn != 0\n                                        && (swapAmountIn < quote.amounts[i - 1] || quote.amounts[i - 1] == 0)\n                                ) {\n                                    quote.amounts[i - 1] = swapAmountIn;\n                                    quote.pairs[i - 1] = address(LBPairsAvailable[j].LBPair);\n                                    quote.binSteps[i - 1] = uint16(LBPairsAvailable[j].binStep);\n                                    quote.versions[i - 1] = ILBRouter.Version.V2_1;\n\n                                    // Getting current price\n                                    uint24 activeId = LBPairsAvailable[j].LBPair.getActiveId();\n                                    quote.virtualAmountsWithoutSlippage[i - 1] = _getV2Quote(\n                                        quote.virtualAmountsWithoutSlippage[i],\n                                        activeId,\n                                        quote.binSteps[i - 1],\n                                        !swapForY\n                                    ) + fees;\n\n                                    quote.fees[i - 1] = ((uint256(fees) * 1e18) / quote.amounts[i - 1]).safe128(); // fee percentage in amountIn\n                                }\n                            } catch {}\n                        }\n                    }\n                }\n            }\n\n            if (_legacyFactoryV2 != address(0)) {\n                // Fetch swaps for V2\n                ILBLegacyFactory.LBPairInformation[] memory legacyLBPairsAvailable =\n                    ILBLegacyFactory(_legacyFactoryV2).getAllLBPairs(IERC20(route[i - 1]), IERC20(route[i]));\n\n                if (legacyLBPairsAvailable.length > 0 && quote.amounts[i] > 0) {\n                    for (uint256 j; j < legacyLBPairsAvailable.length; j++) {\n                        if (!legacyLBPairsAvailable[j].ignoredForRouting) {\n                            bool swapForY = address(legacyLBPairsAvailable[j].LBPair.tokenY()) == route[i];\n                            try ILBLegacyRouter(_legacyRouterV2).getSwapIn(\n                                legacyLBPairsAvailable[j].LBPair, quote.amounts[i], swapForY\n                            ) returns (uint256 swapAmountIn, uint256 fees) {\n                                if (\n                                    swapAmountIn != 0\n                                        && (swapAmountIn < quote.amounts[i - 1] || quote.amounts[i - 1] == 0)\n                                ) {\n                                    quote.amounts[i - 1] = (swapAmountIn).safe128();\n                                    quote.pairs[i - 1] = address(legacyLBPairsAvailable[j].LBPair);\n                                    quote.binSteps[i - 1] = legacyLBPairsAvailable[j].binStep;\n                                    quote.versions[i - 1] = ILBRouter.Version.V2;\n\n                                    // Getting current price\n                                    (,, uint256 activeId) = legacyLBPairsAvailable[j].LBPair.getReservesAndId();\n                                    quote.virtualAmountsWithoutSlippage[i - 1] = _getV2Quote(\n                                        quote.virtualAmountsWithoutSlippage[i],\n                                        uint24(activeId),\n                                        quote.binSteps[i - 1],\n                                        !swapForY\n                                    ) + fees.safe128();\n\n                                    quote.fees[i - 1] = ((fees * 1e18) / quote.amounts[i - 1]).safe128(); // fee percentage in amountIn\n                                }\n                            } catch {}\n                        }\n                    }\n                }\n            }\n\n            if (_factoryV1 != address(0)) {\n                // Fetch swap for V1\n                address pair = IJoeFactory(_factoryV1).getPair(route[i - 1], route[i]);\n                if (pair != address(0) && quote.amounts[i] > 0) {\n                    (uint256 reserveIn, uint256 reserveOut) = _getReserves(pair, route[i - 1], route[i]);\n\n                    if (reserveIn > 0 && reserveOut > quote.amounts[i]) {\n                        uint256 swapAmountIn = JoeLibrary.getAmountIn(quote.amounts[i], reserveIn, reserveOut);\n\n                        if (swapAmountIn < quote.amounts[i - 1] || quote.amounts[i - 1] == 0) {\n                            quote.amounts[i - 1] = swapAmountIn.safe128();\n                            quote.pairs[i - 1] = pair;\n                            quote.virtualAmountsWithoutSlippage[i - 1] = (\n                                JoeLibrary.quote(\n                                    quote.virtualAmountsWithoutSlippage[i] * 1000, reserveOut * 997, reserveIn\n                                ) + 1\n                            ).safe128();\n\n                            quote.fees[i - 1] = 0.003e18; // 0.3%\n                            quote.versions[i - 1] = ILBRouter.Version.V1;\n                            quote.binSteps[i - 1] = 0;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Forked from JoeLibrary\n     * @dev Doesn't rely on the init code hash of the factory\n     * @param pair Address of the pair\n     * @param tokenA Address of token A\n     * @param tokenB Address of token B\n     * @return reserveA Reserve of token A in the pair\n     * @return reserveB Reserve of token B in the pair\n     */\n    function _getReserves(address pair, address tokenA, address tokenB)\n        internal\n        view\n        returns (uint256 reserveA, uint256 reserveB)\n    {\n        (address token0,) = JoeLibrary.sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IJoePair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    /**\n     * @dev Calculates a quote for a V2 pair\n     * @param amount Amount in to consider\n     * @param activeId Current active Id of the considred pair\n     * @param binStep Bin step of the considered pair\n     * @param swapForY Boolean describing if we are swapping from X to Y or the opposite\n     * @return quote Amount Out if _amount was swapped with no slippage and no fees\n     */\n    function _getV2Quote(uint256 amount, uint24 activeId, uint256 binStep, bool swapForY)\n        internal\n        pure\n        returns (uint128 quote)\n    {\n        if (swapForY) {\n            quote = PriceHelper.getPriceFromId(activeId, uint16(binStep)).mulShiftRoundDown(\n                amount, Constants.SCALE_OFFSET\n            ).safe128();\n        } else {\n            quote = amount.shiftDivRoundDown(\n                Constants.SCALE_OFFSET, PriceHelper.getPriceFromId(activeId, uint16(binStep))\n            ).safe128();\n        }\n    }\n}\n"
    },
    "contracts/joe-v2/src/LBRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"../lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\n\nimport {BinHelper} from \"./libraries/BinHelper.sol\";\nimport {Constants} from \"./libraries/Constants.sol\";\nimport {Encoded} from \"./libraries/math/Encoded.sol\";\nimport {FeeHelper} from \"./libraries/FeeHelper.sol\";\nimport {JoeLibrary} from \"./libraries/JoeLibrary.sol\";\nimport {LiquidityConfigurations} from \"./libraries/math/LiquidityConfigurations.sol\";\nimport {PackedUint128Math} from \"./libraries/math/PackedUint128Math.sol\";\nimport {TokenHelper, IERC20} from \"./libraries/TokenHelper.sol\";\nimport {Uint256x256Math} from \"./libraries/math/Uint256x256Math.sol\";\n\nimport {IJoePair} from \"./interfaces/IJoePair.sol\";\nimport {ILBPair} from \"./interfaces/ILBPair.sol\";\nimport {ILBLegacyPair} from \"./interfaces/ILBLegacyPair.sol\";\nimport {ILBToken} from \"./interfaces/ILBToken.sol\";\nimport {ILBRouter} from \"./interfaces/ILBRouter.sol\";\nimport {ILBLegacyRouter} from \"./interfaces/ILBLegacyRouter.sol\";\nimport {IJoeFactory} from \"./interfaces/IJoeFactory.sol\";\nimport {ILBLegacyFactory} from \"./interfaces/ILBLegacyFactory.sol\";\nimport {ILBFactory} from \"./interfaces/ILBFactory.sol\";\nimport {IWNATIVE} from \"./interfaces/IWNATIVE.sol\";\n\n/**\n * @title Liquidity Book Router\n * @author Trader Joe\n * @notice Main contract to interact with to swap and manage liquidity on Joe V2 exchange.\n */\ncontract LBRouter is ILBRouter {\n    using TokenHelper for IERC20;\n    using JoeLibrary for uint256;\n    using PackedUint128Math for bytes32;\n\n    ILBFactory private immutable _factory2_2;\n    ILBFactory private immutable _factory2_1;\n    IJoeFactory private immutable _factoryV1;\n    ILBLegacyFactory private immutable _legacyFactory;\n    ILBLegacyRouter private immutable _legacyRouter;\n    IWNATIVE private immutable _wnative;\n\n    modifier onlyFactoryOwner() {\n        if (msg.sender != Ownable(address(_factory2_2)).owner()) revert LBRouter__NotFactoryOwner();\n        _;\n    }\n\n    modifier ensure(uint256 deadline) {\n        if (block.timestamp > deadline) revert LBRouter__DeadlineExceeded(deadline, block.timestamp);\n        _;\n    }\n\n    modifier verifyPathValidity(Path memory path) {\n        if (\n            path.pairBinSteps.length == 0 || path.versions.length != path.pairBinSteps.length\n                || path.pairBinSteps.length + 1 != path.tokenPath.length\n        ) revert LBRouter__LengthsMismatch();\n        _;\n    }\n\n    /**\n     * @notice Constructor\n     * @param factory2_2 Address of Joe V2.2 factory\n     * @param factory2_1 Address of Joe V2.1 factory\n     * @param factoryV1 Address of Joe V1 factory\n     * @param legacyFactory Address of Joe V2 factory\n     * @param legacyRouter Address of Joe V2 router\n     * @param wnative Address of WNATIVE\n     */\n    constructor(\n        ILBFactory factory2_2,\n        IJoeFactory factoryV1,\n        ILBLegacyFactory legacyFactory,\n        ILBLegacyRouter legacyRouter,\n        ILBFactory factory2_1,\n        IWNATIVE wnative\n    ) {\n        _factory2_2 = factory2_2;\n        _factory2_1 = factory2_1;\n        _factoryV1 = factoryV1;\n        _legacyFactory = legacyFactory;\n        _legacyRouter = legacyRouter;\n        _wnative = wnative;\n    }\n\n    /**\n     * @dev Receive function that only accept NATIVE from the WNATIVE contract\n     */\n    receive() external payable {\n        if (msg.sender != address(_wnative)) revert LBRouter__SenderIsNotWNATIVE();\n    }\n\n    /**\n     * View function to get the factory V2.1 address\n     * @return lbFactory The address of the factory V2.1\n     */\n    function getFactory() external view override returns (ILBFactory lbFactory) {\n        return _factory2_2;\n    }\n\n    /**\n     * View function to get the factory V2.1 address\n     * @return lbFactory The address of the factory V2.1\n     */\n    function getFactoryV2_1() external view override returns (ILBFactory lbFactory) {\n        return _factory2_1;\n    }\n\n    /**\n     * View function to get the factory V2 address\n     * @return legacyLBfactory The address of the factory V2\n     */\n    function getLegacyFactory() external view override returns (ILBLegacyFactory legacyLBfactory) {\n        return _legacyFactory;\n    }\n\n    /**\n     * View function to get the factory V1 address\n     * @return factoryV1 The address of the factory V1\n     */\n    function getV1Factory() external view override returns (IJoeFactory factoryV1) {\n        return _factoryV1;\n    }\n\n    /**\n     * View function to get the router V2 address\n     * @return legacyRouter The address of the router V2\n     */\n    function getLegacyRouter() external view override returns (ILBLegacyRouter legacyRouter) {\n        return _legacyRouter;\n    }\n\n    /**\n     * View function to get the WNATIVE address\n     * @return wnative The address of WNATIVE\n     */\n    function getWNATIVE() external view override returns (IWNATIVE wnative) {\n        return _wnative;\n    }\n\n    /**\n     * @notice Returns the approximate id corresponding to the inputted price.\n     * Warning, the returned id may be inaccurate close to the start price of a bin\n     * @param pair The address of the LBPair\n     * @param price The price of y per x (multiplied by 1e36)\n     * @return The id corresponding to this price\n     */\n    function getIdFromPrice(ILBPair pair, uint256 price) external view override returns (uint24) {\n        return pair.getIdFromPrice(price);\n    }\n\n    /**\n     * @notice Returns the price corresponding to the inputted id\n     * @param pair The address of the LBPair\n     * @param id The id\n     * @return The price corresponding to this id\n     */\n    function getPriceFromId(ILBPair pair, uint24 id) external view override returns (uint256) {\n        return pair.getPriceFromId(id);\n    }\n\n    /**\n     * @notice Simulate a swap in\n     * @param pair The address of the LBPair\n     * @param amountOut The amount of token to receive\n     * @param swapForY Whether you swap X for Y (true), or Y for X (false)\n     * @return amountIn The amount of token to send in order to receive amountOut token\n     * @return amountOutLeft The amount of token Out that can't be returned due to a lack of liquidity\n     * @return fee The amount of fees paid in token sent\n     */\n    function getSwapIn(ILBPair pair, uint128 amountOut, bool swapForY)\n        public\n        view\n        override\n        returns (uint128 amountIn, uint128 amountOutLeft, uint128 fee)\n    {\n        (amountIn, amountOutLeft, fee) = pair.getSwapIn(amountOut, swapForY);\n    }\n\n    /**\n     * @notice Simulate a swap out\n     * @param pair The address of the LBPair\n     * @param amountIn The amount of token sent\n     * @param swapForY Whether you swap X for Y (true), or Y for X (false)\n     * @return amountInLeft The amount of token In that can't be swapped due to a lack of liquidity\n     * @return amountOut The amount of token received if amountIn tokenX are sent\n     * @return fee The amount of fees paid in token sent\n     */\n    function getSwapOut(ILBPair pair, uint128 amountIn, bool swapForY)\n        external\n        view\n        override\n        returns (uint128 amountInLeft, uint128 amountOut, uint128 fee)\n    {\n        (amountInLeft, amountOut, fee) = pair.getSwapOut(amountIn, swapForY);\n    }\n\n    /**\n     * @notice Create a liquidity bin LBPair for tokenX and tokenY using the factory\n     * @param tokenX The address of the first token\n     * @param tokenY The address of the second token\n     * @param activeId The active id of the pair\n     * @param binStep The bin step in basis point, used to calculate log(1 + binStep)\n     * @return pair The address of the newly created LBPair\n     */\n    function createLBPair(IERC20 tokenX, IERC20 tokenY, uint24 activeId, uint16 binStep)\n        external\n        override\n        returns (ILBPair pair)\n    {\n        pair = _factory2_2.createLBPair(tokenX, tokenY, activeId, binStep);\n    }\n\n    /**\n     * @notice Add liquidity while performing safety checks\n     * @dev This function is compliant with fee on transfer tokens\n     * @param liquidityParameters The liquidity parameters\n     * @return amountXAdded The amount of token X added\n     * @return amountYAdded The amount of token Y added\n     * @return amountXLeft The amount of token X left (sent back to liquidityParameters.refundTo)\n     * @return amountYLeft The amount of token Y left (sent back to liquidityParameters.refundTo)\n     * @return depositIds The ids of the deposits\n     * @return liquidityMinted The amount of liquidity minted\n     */\n    function addLiquidity(LiquidityParameters calldata liquidityParameters)\n        external\n        override\n        returns (\n            uint256 amountXAdded,\n            uint256 amountYAdded,\n            uint256 amountXLeft,\n            uint256 amountYLeft,\n            uint256[] memory depositIds,\n            uint256[] memory liquidityMinted\n        )\n    {\n        ILBPair lbPair = ILBPair(\n            _getLBPairInformation(\n                liquidityParameters.tokenX, liquidityParameters.tokenY, liquidityParameters.binStep, Version.V2_2\n            )\n        );\n        if (liquidityParameters.tokenX != lbPair.getTokenX()) revert LBRouter__WrongTokenOrder();\n\n        _safeTransferFrom(liquidityParameters.tokenX, msg.sender, address(lbPair), liquidityParameters.amountX);\n        _safeTransferFrom(liquidityParameters.tokenY, msg.sender, address(lbPair), liquidityParameters.amountY);\n\n        (amountXAdded, amountYAdded, amountXLeft, amountYLeft, depositIds, liquidityMinted) =\n            _addLiquidity(liquidityParameters, lbPair);\n    }\n\n    /**\n     * @notice Add liquidity with NATIVE while performing safety checks\n     * @dev This function is compliant with fee on transfer tokens\n     * @param liquidityParameters The liquidity parameters\n     * @return amountXAdded The amount of token X added\n     * @return amountYAdded The amount of token Y added\n     * @return amountXLeft The amount of token X left (sent back to liquidityParameters.refundTo)\n     * @return amountYLeft The amount of token Y left (sent back to liquidityParameters.refundTo)\n     * @return depositIds The ids of the deposits\n     * @return liquidityMinted The amount of liquidity minted\n     */\n    function addLiquidityNATIVE(LiquidityParameters calldata liquidityParameters)\n        external\n        payable\n        override\n        returns (\n            uint256 amountXAdded,\n            uint256 amountYAdded,\n            uint256 amountXLeft,\n            uint256 amountYLeft,\n            uint256[] memory depositIds,\n            uint256[] memory liquidityMinted\n        )\n    {\n        ILBPair _LBPair = ILBPair(\n            _getLBPairInformation(\n                liquidityParameters.tokenX, liquidityParameters.tokenY, liquidityParameters.binStep, Version.V2_2\n            )\n        );\n        if (liquidityParameters.tokenX != _LBPair.getTokenX()) revert LBRouter__WrongTokenOrder();\n\n        if (liquidityParameters.tokenX == _wnative && liquidityParameters.amountX == msg.value) {\n            _safeTransferFrom(liquidityParameters.tokenY, msg.sender, address(_LBPair), liquidityParameters.amountY);\n            _wNativeDepositAndTransfer(address(_LBPair), msg.value);\n        } else if (liquidityParameters.tokenY == _wnative && liquidityParameters.amountY == msg.value) {\n            _safeTransferFrom(liquidityParameters.tokenX, msg.sender, address(_LBPair), liquidityParameters.amountX);\n            _wNativeDepositAndTransfer(address(_LBPair), msg.value);\n        } else {\n            revert LBRouter__WrongNativeLiquidityParameters(\n                address(liquidityParameters.tokenX),\n                address(liquidityParameters.tokenY),\n                liquidityParameters.amountX,\n                liquidityParameters.amountY,\n                msg.value\n            );\n        }\n\n        (amountXAdded, amountYAdded, amountXLeft, amountYLeft, depositIds, liquidityMinted) =\n            _addLiquidity(liquidityParameters, _LBPair);\n    }\n\n    /**\n     * @notice Remove liquidity while performing safety checks\n     * @dev This function is compliant with fee on transfer tokens\n     * @param tokenX The address of token X\n     * @param tokenY The address of token Y\n     * @param binStep The bin step of the LBPair\n     * @param amountXMin The min amount to receive of token X\n     * @param amountYMin The min amount to receive of token Y\n     * @param ids The list of ids to burn\n     * @param amounts The list of amounts to burn of each id in `_ids`\n     * @param to The address of the recipient\n     * @param deadline The deadline of the tx\n     * @return amountX Amount of token X returned\n     * @return amountY Amount of token Y returned\n     */\n    function removeLiquidity(\n        IERC20 tokenX,\n        IERC20 tokenY,\n        uint16 binStep,\n        uint256 amountXMin,\n        uint256 amountYMin,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        address to,\n        uint256 deadline\n    ) external override ensure(deadline) returns (uint256 amountX, uint256 amountY) {\n        ILBPair _LBPair = ILBPair(_getLBPairInformation(tokenX, tokenY, binStep, Version.V2_2));\n        bool isWrongOrder = tokenX != _LBPair.getTokenX();\n\n        if (isWrongOrder) (amountXMin, amountYMin) = (amountYMin, amountXMin);\n\n        (amountX, amountY) = _removeLiquidity(_LBPair, amountXMin, amountYMin, ids, amounts, to);\n\n        if (isWrongOrder) (amountX, amountY) = (amountY, amountX);\n    }\n\n    /**\n     * @notice Remove NATIVE liquidity while performing safety checks\n     * @dev This function is **NOT** compliant with fee on transfer tokens.\n     * This is wanted as it would make users pays the fee on transfer twice,\n     * use the `removeLiquidity` function to remove liquidity with fee on transfer tokens.\n     * @param token The address of token\n     * @param binStep The bin step of the LBPair\n     * @param amountTokenMin The min amount to receive of token\n     * @param amountNATIVEMin The min amount to receive of NATIVE\n     * @param ids The list of ids to burn\n     * @param amounts The list of amounts to burn of each id in `_ids`\n     * @param to The address of the recipient\n     * @param deadline The deadline of the tx\n     * @return amountToken Amount of token returned\n     * @return amountNATIVE Amount of NATIVE returned\n     */\n    function removeLiquidityNATIVE(\n        IERC20 token,\n        uint16 binStep,\n        uint256 amountTokenMin,\n        uint256 amountNATIVEMin,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        address payable to,\n        uint256 deadline\n    ) external override ensure(deadline) returns (uint256 amountToken, uint256 amountNATIVE) {\n        ILBPair lbPair = ILBPair(_getLBPairInformation(token, IERC20(_wnative), binStep, Version.V2_2));\n\n        {\n            bool isNATIVETokenY = IERC20(_wnative) == lbPair.getTokenY();\n\n            if (!isNATIVETokenY) {\n                (amountTokenMin, amountNATIVEMin) = (amountNATIVEMin, amountTokenMin);\n            }\n\n            (uint256 amountX, uint256 amountY) =\n                _removeLiquidity(lbPair, amountTokenMin, amountNATIVEMin, ids, amounts, address(this));\n\n            (amountToken, amountNATIVE) = isNATIVETokenY ? (amountX, amountY) : (amountY, amountX);\n        }\n\n        _safeTransfer(token, to, amountToken);\n        _wNativeWithdrawAndTransfer(to, amountNATIVE);\n    }\n\n    /**\n     * @notice Swaps exact tokens for tokens while performing safety checks\n     * @param amountIn The amount of token to send\n     * @param amountOutMin The min amount of token to receive\n     * @param path The path of the swap\n     * @param to The address of the recipient\n     * @param deadline The deadline of the tx\n     * @return amountOut Output amount of the swap\n     */\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        Path memory path,\n        address to,\n        uint256 deadline\n    ) external override ensure(deadline) verifyPathValidity(path) returns (uint256 amountOut) {\n        address[] memory pairs = _getPairs(path.pairBinSteps, path.versions, path.tokenPath);\n\n        _safeTransferFrom(path.tokenPath[0], msg.sender, pairs[0], amountIn);\n\n        amountOut = _swapExactTokensForTokens(amountIn, pairs, path.versions, path.tokenPath, to);\n\n        if (amountOutMin > amountOut) revert LBRouter__InsufficientAmountOut(amountOutMin, amountOut);\n    }\n\n    /**\n     * @notice Swaps exact tokens for NATIVE while performing safety checks\n     * @param amountIn The amount of token to send\n     * @param amountOutMinNATIVE The min amount of NATIVE to receive\n     * @param path The path of the swap\n     * @param to The address of the recipient\n     * @param deadline The deadline of the tx\n     * @return amountOut Output amount of the swap\n     */\n    function swapExactTokensForNATIVE(\n        uint256 amountIn,\n        uint256 amountOutMinNATIVE,\n        Path memory path,\n        address payable to,\n        uint256 deadline\n    ) external override ensure(deadline) verifyPathValidity(path) returns (uint256 amountOut) {\n        if (path.tokenPath[path.pairBinSteps.length] != IERC20(_wnative)) {\n            revert LBRouter__InvalidTokenPath(address(path.tokenPath[path.pairBinSteps.length]));\n        }\n\n        address[] memory pairs = _getPairs(path.pairBinSteps, path.versions, path.tokenPath);\n\n        _safeTransferFrom(path.tokenPath[0], msg.sender, pairs[0], amountIn);\n\n        amountOut = _swapExactTokensForTokens(amountIn, pairs, path.versions, path.tokenPath, address(this));\n\n        if (amountOutMinNATIVE > amountOut) revert LBRouter__InsufficientAmountOut(amountOutMinNATIVE, amountOut);\n\n        _wNativeWithdrawAndTransfer(to, amountOut);\n    }\n\n    /**\n     * @notice Swaps exact NATIVE for tokens while performing safety checks\n     * @param amountOutMin The min amount of token to receive\n     * @param path The path of the swap\n     * @param to The address of the recipient\n     * @param deadline The deadline of the tx\n     * @return amountOut Output amount of the swap\n     */\n    function swapExactNATIVEForTokens(uint256 amountOutMin, Path memory path, address to, uint256 deadline)\n        external\n        payable\n        override\n        ensure(deadline)\n        verifyPathValidity(path)\n        returns (uint256 amountOut)\n    {\n        if (path.tokenPath[0] != IERC20(_wnative)) revert LBRouter__InvalidTokenPath(address(path.tokenPath[0]));\n\n        address[] memory pairs = _getPairs(path.pairBinSteps, path.versions, path.tokenPath);\n\n        _wNativeDepositAndTransfer(pairs[0], msg.value);\n\n        amountOut = _swapExactTokensForTokens(msg.value, pairs, path.versions, path.tokenPath, to);\n\n        if (amountOutMin > amountOut) revert LBRouter__InsufficientAmountOut(amountOutMin, amountOut);\n    }\n\n    /**\n     * @notice Swaps tokens for exact tokens while performing safety checks\n     * @param amountOut The amount of token to receive\n     * @param amountInMax The max amount of token to send\n     * @param path The path of the swap\n     * @param to The address of the recipient\n     * @param deadline The deadline of the tx\n     * @return amountsIn Input amounts of the swap\n     */\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        Path memory path,\n        address to,\n        uint256 deadline\n    ) external override ensure(deadline) verifyPathValidity(path) returns (uint256[] memory amountsIn) {\n        address[] memory pairs = _getPairs(path.pairBinSteps, path.versions, path.tokenPath);\n\n        {\n            amountsIn = _getAmountsIn(path.versions, pairs, path.tokenPath, amountOut);\n\n            if (amountsIn[0] > amountInMax) revert LBRouter__MaxAmountInExceeded(amountInMax, amountsIn[0]);\n\n            _safeTransferFrom(path.tokenPath[0], msg.sender, pairs[0], amountsIn[0]);\n\n            uint256 _amountOutReal = _swapTokensForExactTokens(pairs, path.versions, path.tokenPath, amountsIn, to);\n\n            if (_amountOutReal < amountOut) revert LBRouter__InsufficientAmountOut(amountOut, _amountOutReal);\n        }\n    }\n\n    /**\n     * @notice Swaps tokens for exact NATIVE while performing safety checks\n     * @param amountNATIVEOut The amount of NATIVE to receive\n     * @param amountInMax The max amount of token to send\n     * @param path The path of the swap\n     * @param to The address of the recipient\n     * @param deadline The deadline of the tx\n     * @return amountsIn path amounts for every step of the swap\n     */\n    function swapTokensForExactNATIVE(\n        uint256 amountNATIVEOut,\n        uint256 amountInMax,\n        Path memory path,\n        address payable to,\n        uint256 deadline\n    ) external override ensure(deadline) verifyPathValidity(path) returns (uint256[] memory amountsIn) {\n        if (path.tokenPath[path.pairBinSteps.length] != IERC20(_wnative)) {\n            revert LBRouter__InvalidTokenPath(address(path.tokenPath[path.pairBinSteps.length]));\n        }\n\n        address[] memory pairs = _getPairs(path.pairBinSteps, path.versions, path.tokenPath);\n        amountsIn = _getAmountsIn(path.versions, pairs, path.tokenPath, amountNATIVEOut);\n\n        if (amountsIn[0] > amountInMax) revert LBRouter__MaxAmountInExceeded(amountInMax, amountsIn[0]);\n\n        _safeTransferFrom(path.tokenPath[0], msg.sender, pairs[0], amountsIn[0]);\n\n        uint256 _amountOutReal =\n            _swapTokensForExactTokens(pairs, path.versions, path.tokenPath, amountsIn, address(this));\n\n        if (_amountOutReal < amountNATIVEOut) revert LBRouter__InsufficientAmountOut(amountNATIVEOut, _amountOutReal);\n\n        _wNativeWithdrawAndTransfer(to, _amountOutReal);\n    }\n\n    /**\n     * @notice Swaps NATIVE for exact tokens while performing safety checks\n     * @dev Will refund any NATIVE amount sent in excess to `msg.sender`\n     * @param amountOut The amount of tokens to receive\n     * @param path The path of the swap\n     * @param to The address of the recipient\n     * @param deadline The deadline of the tx\n     * @return amountsIn path amounts for every step of the swap\n     */\n    function swapNATIVEForExactTokens(uint256 amountOut, Path memory path, address to, uint256 deadline)\n        external\n        payable\n        override\n        ensure(deadline)\n        verifyPathValidity(path)\n        returns (uint256[] memory amountsIn)\n    {\n        if (path.tokenPath[0] != IERC20(_wnative)) revert LBRouter__InvalidTokenPath(address(path.tokenPath[0]));\n\n        address[] memory pairs = _getPairs(path.pairBinSteps, path.versions, path.tokenPath);\n        amountsIn = _getAmountsIn(path.versions, pairs, path.tokenPath, amountOut);\n\n        if (amountsIn[0] > msg.value) revert LBRouter__MaxAmountInExceeded(msg.value, amountsIn[0]);\n\n        _wNativeDepositAndTransfer(pairs[0], amountsIn[0]);\n\n        uint256 amountOutReal = _swapTokensForExactTokens(pairs, path.versions, path.tokenPath, amountsIn, to);\n\n        if (amountOutReal < amountOut) revert LBRouter__InsufficientAmountOut(amountOut, amountOutReal);\n\n        if (msg.value > amountsIn[0]) _safeTransferNative(msg.sender, msg.value - amountsIn[0]);\n    }\n\n    /**\n     * @notice Swaps exact tokens for tokens while performing safety checks supporting for fee on transfer tokens\n     * @param amountIn The amount of token to send\n     * @param amountOutMin The min amount of token to receive\n     * @param path The path of the swap\n     * @param to The address of the recipient\n     * @param deadline The deadline of the tx\n     * @return amountOut Output amount of the swap\n     */\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        Path memory path,\n        address to,\n        uint256 deadline\n    ) external override ensure(deadline) verifyPathValidity(path) returns (uint256 amountOut) {\n        address[] memory pairs = _getPairs(path.pairBinSteps, path.versions, path.tokenPath);\n\n        IERC20 targetToken = path.tokenPath[pairs.length];\n\n        uint256 balanceBefore = targetToken.balanceOf(to);\n\n        _safeTransferFrom(path.tokenPath[0], msg.sender, pairs[0], amountIn);\n\n        _swapSupportingFeeOnTransferTokens(pairs, path.versions, path.tokenPath, to);\n\n        amountOut = targetToken.balanceOf(to) - balanceBefore;\n        if (amountOutMin > amountOut) revert LBRouter__InsufficientAmountOut(amountOutMin, amountOut);\n    }\n\n    /**\n     * @notice Swaps exact tokens for NATIVE while performing safety checks supporting for fee on transfer tokens\n     * @param amountIn The amount of token to send\n     * @param amountOutMinNATIVE The min amount of NATIVE to receive\n     * @param path The path of the swap\n     * @param to The address of the recipient\n     * @param deadline The deadline of the tx\n     * @return amountOut Output amount of the swap\n     */\n    function swapExactTokensForNATIVESupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMinNATIVE,\n        Path memory path,\n        address payable to,\n        uint256 deadline\n    ) external override ensure(deadline) verifyPathValidity(path) returns (uint256 amountOut) {\n        if (path.tokenPath[path.pairBinSteps.length] != IERC20(_wnative)) {\n            revert LBRouter__InvalidTokenPath(address(path.tokenPath[path.pairBinSteps.length]));\n        }\n\n        address[] memory pairs = _getPairs(path.pairBinSteps, path.versions, path.tokenPath);\n\n        uint256 balanceBefore = _wnative.balanceOf(address(this));\n\n        _safeTransferFrom(path.tokenPath[0], msg.sender, pairs[0], amountIn);\n\n        _swapSupportingFeeOnTransferTokens(pairs, path.versions, path.tokenPath, address(this));\n\n        amountOut = _wnative.balanceOf(address(this)) - balanceBefore;\n        if (amountOutMinNATIVE > amountOut) revert LBRouter__InsufficientAmountOut(amountOutMinNATIVE, amountOut);\n\n        _wNativeWithdrawAndTransfer(to, amountOut);\n    }\n\n    /**\n     * @notice Swaps exact NATIVE for tokens while performing safety checks supporting for fee on transfer tokens\n     * @param amountOutMin The min amount of token to receive\n     * @param path The path of the swap\n     * @param to The address of the recipient\n     * @param deadline The deadline of the tx\n     * @return amountOut Output amount of the swap\n     */\n    function swapExactNATIVEForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        Path memory path,\n        address to,\n        uint256 deadline\n    ) external payable override ensure(deadline) verifyPathValidity(path) returns (uint256 amountOut) {\n        if (path.tokenPath[0] != IERC20(_wnative)) revert LBRouter__InvalidTokenPath(address(path.tokenPath[0]));\n\n        address[] memory pairs = _getPairs(path.pairBinSteps, path.versions, path.tokenPath);\n\n        IERC20 targetToken = path.tokenPath[pairs.length];\n\n        uint256 balanceBefore = targetToken.balanceOf(to);\n\n        _wNativeDepositAndTransfer(pairs[0], msg.value);\n\n        _swapSupportingFeeOnTransferTokens(pairs, path.versions, path.tokenPath, to);\n\n        amountOut = targetToken.balanceOf(to) - balanceBefore;\n        if (amountOutMin > amountOut) revert LBRouter__InsufficientAmountOut(amountOutMin, amountOut);\n    }\n\n    /**\n     * @notice Unstuck tokens that are sent to this contract by mistake\n     * @dev Only callable by the factory owner\n     * @param token The address of the token\n     * @param to The address of the user to send back the tokens\n     * @param amount The amount to send\n     */\n    function sweep(IERC20 token, address to, uint256 amount) external override onlyFactoryOwner {\n        if (address(token) == address(0)) {\n            amount = amount == type(uint256).max ? address(this).balance : amount;\n\n            _safeTransferNative(to, amount);\n        } else {\n            amount = amount == type(uint256).max ? token.balanceOf(address(this)) : amount;\n\n            token.safeTransfer(to, amount);\n        }\n    }\n\n    /**\n     * @notice Unstuck LBTokens that are sent to this contract by mistake\n     * @dev Only callable by the factory owner\n     * @param lbToken The address of the LBToken\n     * @param to The address of the user to send back the tokens\n     * @param ids The list of token ids\n     * @param amounts The list of amounts to send\n     */\n    function sweepLBToken(ILBToken lbToken, address to, uint256[] calldata ids, uint256[] calldata amounts)\n        external\n        override\n        onlyFactoryOwner\n    {\n        lbToken.batchTransferFrom(address(this), to, ids, amounts);\n    }\n\n    /**\n     * @notice Helper function to add liquidity\n     * @param liq The liquidity parameter\n     * @param pair LBPair where liquidity is deposited\n     * @return amountXAdded Amount of token X added\n     * @return amountYAdded Amount of token Y added\n     * @return amountXLeft Amount of token X left\n     * @return amountYLeft Amount of token Y left\n     * @return depositIds The list of deposit ids\n     * @return liquidityMinted The list of liquidity minted\n     */\n    function _addLiquidity(LiquidityParameters calldata liq, ILBPair pair)\n        private\n        ensure(liq.deadline)\n        returns (\n            uint256 amountXAdded,\n            uint256 amountYAdded,\n            uint256 amountXLeft,\n            uint256 amountYLeft,\n            uint256[] memory depositIds,\n            uint256[] memory liquidityMinted\n        )\n    {\n        unchecked {\n            if (liq.deltaIds.length != liq.distributionX.length || liq.deltaIds.length != liq.distributionY.length) {\n                revert LBRouter__LengthsMismatch();\n            }\n\n            if (liq.activeIdDesired > type(uint24).max || liq.idSlippage > type(uint24).max) {\n                revert LBRouter__IdDesiredOverflows(liq.activeIdDesired, liq.idSlippage);\n            }\n\n            bytes32[] memory liquidityConfigs = new bytes32[](liq.deltaIds.length);\n            depositIds = new uint256[](liq.deltaIds.length);\n            {\n                uint256 _activeId = pair.getActiveId();\n                if (\n                    liq.activeIdDesired + liq.idSlippage < _activeId || _activeId + liq.idSlippage < liq.activeIdDesired\n                ) {\n                    revert LBRouter__IdSlippageCaught(liq.activeIdDesired, liq.idSlippage, _activeId);\n                }\n\n                for (uint256 i; i < liquidityConfigs.length; ++i) {\n                    int256 _id = int256(_activeId) + liq.deltaIds[i];\n\n                    if (_id < 0 || uint256(_id) > type(uint24).max) revert LBRouter__IdOverflows(_id);\n                    depositIds[i] = uint256(_id);\n                    liquidityConfigs[i] = LiquidityConfigurations.encodeParams(\n                        uint64(liq.distributionX[i]), uint64(liq.distributionY[i]), uint24(uint256(_id))\n                    );\n                }\n            }\n\n            bytes32 amountsReceived;\n            bytes32 amountsLeft;\n            (amountsReceived, amountsLeft, liquidityMinted) = pair.mint(liq.to, liquidityConfigs, liq.refundTo);\n\n            bytes32 amountsAdded = amountsReceived.sub(amountsLeft);\n\n            amountXAdded = amountsAdded.decodeX();\n            amountYAdded = amountsAdded.decodeY();\n\n            if (amountXAdded < liq.amountXMin || amountYAdded < liq.amountYMin) {\n                revert LBRouter__AmountSlippageCaught(liq.amountXMin, amountXAdded, liq.amountYMin, amountYAdded);\n            }\n\n            amountXLeft = amountsLeft.decodeX();\n            amountYLeft = amountsLeft.decodeY();\n        }\n    }\n\n    /**\n     * @notice Helper function to return the amounts in\n     * @param versions The list of versions (V1, V2, V2_1 or V2_2)\n     * @param pairs The list of pairs\n     * @param tokenPath The swap path\n     * @param amountOut The amount out\n     * @return amountsIn The list of amounts in\n     */\n    function _getAmountsIn(\n        Version[] memory versions,\n        address[] memory pairs,\n        IERC20[] memory tokenPath,\n        uint256 amountOut\n    ) private view returns (uint256[] memory amountsIn) {\n        amountsIn = new uint256[](tokenPath.length);\n        // Avoid doing -1, as `pairs.length == pairBinSteps.length-1`\n        amountsIn[pairs.length] = amountOut;\n\n        for (uint256 i = pairs.length; i != 0; i--) {\n            IERC20 token = tokenPath[i - 1];\n            Version version = versions[i - 1];\n            address pair = pairs[i - 1];\n\n            if (version == Version.V1) {\n                (uint256 reserveIn, uint256 reserveOut,) = IJoePair(pair).getReserves();\n                if (token > tokenPath[i]) {\n                    (reserveIn, reserveOut) = (reserveOut, reserveIn);\n                }\n\n                uint256 amountOut_ = amountsIn[i];\n                amountsIn[i - 1] = uint128(amountOut_.getAmountIn(reserveIn, reserveOut));\n            } else if (version == Version.V2) {\n                (amountsIn[i - 1],) = _legacyRouter.getSwapIn(\n                    ILBLegacyPair(pair), uint128(amountsIn[i]), ILBLegacyPair(pair).tokenX() == token\n                );\n            } else {\n                (amountsIn[i - 1],,) =\n                    getSwapIn(ILBPair(pair), uint128(amountsIn[i]), ILBPair(pair).getTokenX() == token);\n            }\n        }\n    }\n\n    /**\n     * @notice Helper function to remove liquidity\n     * @param pair The address of the LBPair\n     * @param amountXMin The min amount to receive of token X\n     * @param amountYMin The min amount to receive of token Y\n     * @param ids The list of ids to burn\n     * @param amounts The list of amounts to burn of each id in `_ids`\n     * @param to The address of the recipient\n     * @return amountX The amount of token X sent by the pair\n     * @return amountY The amount of token Y sent by the pair\n     */\n    function _removeLiquidity(\n        ILBPair pair,\n        uint256 amountXMin,\n        uint256 amountYMin,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        address to\n    ) private returns (uint256 amountX, uint256 amountY) {\n        (bytes32[] memory amountsBurned) = pair.burn(msg.sender, to, ids, amounts);\n\n        for (uint256 i; i < amountsBurned.length; ++i) {\n            amountX += amountsBurned[i].decodeX();\n            amountY += amountsBurned[i].decodeY();\n        }\n\n        if (amountX < amountXMin || amountY < amountYMin) {\n            revert LBRouter__AmountSlippageCaught(amountXMin, amountX, amountYMin, amountY);\n        }\n    }\n\n    /**\n     * @notice Helper function to swap exact tokens for tokens\n     * @param amountIn The amount of token sent\n     * @param pairs The list of pairs\n     * @param versions The list of versions (V1, V2, V2_1 or V2_2)\n     * @param tokenPath The swap path using the binSteps following `pairBinSteps`\n     * @param to The address of the recipient\n     * @return amountOut The amount of token sent to `to`\n     */\n    function _swapExactTokensForTokens(\n        uint256 amountIn,\n        address[] memory pairs,\n        Version[] memory versions,\n        IERC20[] memory tokenPath,\n        address to\n    ) private returns (uint256 amountOut) {\n        IERC20 token;\n        Version version;\n        address recipient;\n        address pair;\n\n        IERC20 tokenNext = tokenPath[0];\n        amountOut = amountIn;\n\n        unchecked {\n            for (uint256 i; i < pairs.length; ++i) {\n                pair = pairs[i];\n                version = versions[i];\n\n                token = tokenNext;\n                tokenNext = tokenPath[i + 1];\n\n                recipient = i + 1 == pairs.length ? to : pairs[i + 1];\n\n                if (version == Version.V1) {\n                    (uint256 reserve0, uint256 reserve1,) = IJoePair(pair).getReserves();\n\n                    if (token < tokenNext) {\n                        amountOut = amountOut.getAmountOut(reserve0, reserve1);\n                        IJoePair(pair).swap(0, amountOut, recipient, \"\");\n                    } else {\n                        amountOut = amountOut.getAmountOut(reserve1, reserve0);\n                        IJoePair(pair).swap(amountOut, 0, recipient, \"\");\n                    }\n                } else if (version == Version.V2) {\n                    bool swapForY = tokenNext == ILBLegacyPair(pair).tokenY();\n\n                    (uint256 amountXOut, uint256 amountYOut) = ILBLegacyPair(pair).swap(swapForY, recipient);\n\n                    if (swapForY) amountOut = amountYOut;\n                    else amountOut = amountXOut;\n                } else {\n                    bool swapForY = tokenNext == ILBPair(pair).getTokenY();\n\n                    (uint256 amountXOut, uint256 amountYOut) = ILBPair(pair).swap(swapForY, recipient).decode();\n\n                    if (swapForY) amountOut = amountYOut;\n                    else amountOut = amountXOut;\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Helper function to swap tokens for exact tokens\n     * @param pairs The array of pairs\n     * @param versions The list of versions (V1, V2, V2_1 or V2_2)\n     * @param tokenPath The swap path using the binSteps following `pairBinSteps`\n     * @param amountsIn The list of amounts in\n     * @param to The address of the recipient\n     * @return amountOut The amount of token sent to `to`\n     */\n    function _swapTokensForExactTokens(\n        address[] memory pairs,\n        Version[] memory versions,\n        IERC20[] memory tokenPath,\n        uint256[] memory amountsIn,\n        address to\n    ) private returns (uint256 amountOut) {\n        IERC20 token;\n        address recipient;\n        address pair;\n        Version version;\n\n        IERC20 tokenNext = tokenPath[0];\n\n        unchecked {\n            for (uint256 i; i < pairs.length; ++i) {\n                pair = pairs[i];\n                version = versions[i];\n\n                token = tokenNext;\n                tokenNext = tokenPath[i + 1];\n\n                recipient = i + 1 == pairs.length ? to : pairs[i + 1];\n\n                if (version == Version.V1) {\n                    amountOut = amountsIn[i + 1];\n                    if (token < tokenNext) {\n                        IJoePair(pair).swap(0, amountOut, recipient, \"\");\n                    } else {\n                        IJoePair(pair).swap(amountOut, 0, recipient, \"\");\n                    }\n                } else if (version == Version.V2) {\n                    bool swapForY = tokenNext == ILBLegacyPair(pair).tokenY();\n\n                    (uint256 amountXOut, uint256 amountYOut) = ILBLegacyPair(pair).swap(swapForY, recipient);\n\n                    if (swapForY) amountOut = amountYOut;\n                    else amountOut = amountXOut;\n                } else {\n                    bool swapForY = tokenNext == ILBPair(pair).getTokenY();\n\n                    (uint256 amountXOut, uint256 amountYOut) = ILBPair(pair).swap(swapForY, recipient).decode();\n\n                    if (swapForY) amountOut = amountYOut;\n                    else amountOut = amountXOut;\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Helper function to swap exact tokens supporting for fee on transfer tokens\n     * @param pairs The list of pairs\n     * @param versions The list of versions (V1, V2, V2_1 or V2_2)\n     * @param tokenPath The swap path using the binSteps following `pairBinSteps`\n     * @param to The address of the recipient\n     */\n    function _swapSupportingFeeOnTransferTokens(\n        address[] memory pairs,\n        Version[] memory versions,\n        IERC20[] memory tokenPath,\n        address to\n    ) private {\n        IERC20 token;\n        Version version;\n        address recipient;\n        address pair;\n\n        IERC20 tokenNext = tokenPath[0];\n\n        unchecked {\n            for (uint256 i; i < pairs.length; ++i) {\n                pair = pairs[i];\n                version = versions[i];\n\n                token = tokenNext;\n                tokenNext = tokenPath[i + 1];\n\n                recipient = i + 1 == pairs.length ? to : pairs[i + 1];\n\n                if (version == Version.V1) {\n                    (uint256 _reserve0, uint256 _reserve1,) = IJoePair(pair).getReserves();\n                    if (token < tokenNext) {\n                        uint256 amountIn = token.balanceOf(pair) - _reserve0;\n                        uint256 amountOut = amountIn.getAmountOut(_reserve0, _reserve1);\n\n                        IJoePair(pair).swap(0, amountOut, recipient, \"\");\n                    } else {\n                        uint256 amountIn = token.balanceOf(pair) - _reserve1;\n                        uint256 amountOut = amountIn.getAmountOut(_reserve1, _reserve0);\n\n                        IJoePair(pair).swap(amountOut, 0, recipient, \"\");\n                    }\n                } else if (version == Version.V2) {\n                    ILBLegacyPair(pair).swap(tokenNext == ILBLegacyPair(pair).tokenY(), recipient);\n                } else {\n                    ILBPair(pair).swap(tokenNext == ILBPair(pair).getTokenY(), recipient);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Helper function to return the address of the LBPair\n     * @dev Revert if the pair is not created yet\n     * @param tokenX The address of the tokenX\n     * @param tokenY The address of the tokenY\n     * @param binStep The bin step of the LBPair\n     * @param version The version of the LBPair\n     * @return lbPair The address of the LBPair\n     */\n    function _getLBPairInformation(IERC20 tokenX, IERC20 tokenY, uint256 binStep, Version version)\n        private\n        view\n        returns (address lbPair)\n    {\n        if (version == Version.V2) {\n            lbPair = address(_legacyFactory.getLBPairInformation(tokenX, tokenY, binStep).LBPair);\n        } else if (version == Version.V2_1) {\n            lbPair = address(_factory2_1.getLBPairInformation(tokenX, tokenY, binStep).LBPair);\n        } else {\n            lbPair = address(_factory2_2.getLBPairInformation(tokenX, tokenY, binStep).LBPair);\n        }\n\n        if (lbPair == address(0)) {\n            revert LBRouter__PairNotCreated(address(tokenX), address(tokenY), binStep);\n        }\n    }\n\n    /**\n     * @notice Helper function to return the address of the pair (v1 or v2, according to `binStep`)\n     * @dev Revert if the pair is not created yet\n     * @param tokenX The address of the tokenX\n     * @param tokenY The address of the tokenY\n     * @param binStep The bin step of the LBPair\n     * @param version The version of the LBPair\n     * @return pair The address of the pair of binStep `binStep`\n     */\n    function _getPair(IERC20 tokenX, IERC20 tokenY, uint256 binStep, Version version)\n        private\n        view\n        returns (address pair)\n    {\n        if (version == Version.V1) {\n            pair = _factoryV1.getPair(address(tokenX), address(tokenY));\n            if (pair == address(0)) revert LBRouter__PairNotCreated(address(tokenX), address(tokenY), binStep);\n        } else {\n            pair = address(_getLBPairInformation(tokenX, tokenY, binStep, version));\n        }\n    }\n\n    /**\n     * @notice Helper function to return a list of pairs\n     * @param pairBinSteps The list of bin steps\n     * @param versions The list of versions (V1, V2, V2_1 or V2_2)\n     * @param tokenPath The swap path using the binSteps following `pairBinSteps`\n     * @return pairs The list of pairs\n     */\n    function _getPairs(uint256[] memory pairBinSteps, Version[] memory versions, IERC20[] memory tokenPath)\n        private\n        view\n        returns (address[] memory pairs)\n    {\n        pairs = new address[](pairBinSteps.length);\n\n        IERC20 token;\n        IERC20 tokenNext = tokenPath[0];\n        unchecked {\n            for (uint256 i; i < pairs.length; ++i) {\n                token = tokenNext;\n                tokenNext = tokenPath[i + 1];\n\n                pairs[i] = _getPair(token, tokenNext, pairBinSteps[i], versions[i]);\n            }\n        }\n    }\n\n    /**\n     * @notice Helper function to transfer tokens to `to`\n     * @param token The address of the token\n     * @param to The address of the recipient\n     * @param amount The amount to send\n     */\n    function _safeTransfer(IERC20 token, address to, uint256 amount) private {\n        if (amount == 0) return;\n\n        token.safeTransfer(to, amount);\n    }\n\n    /**\n     * @notice Helper function to transfer tokens from `from` to `to`\n     * @param token The address of the token\n     * @param from The address of the sender\n     * @param to The address of the recipient\n     * @param amount The amount to send\n     */\n    function _safeTransferFrom(IERC20 token, address from, address to, uint256 amount) private {\n        if (amount == 0) return;\n\n        token.safeTransferFrom(from, to, amount);\n    }\n\n    /**\n     * @notice Helper function to transfer NATIVE to `to`\n     * @param to The address of the recipient\n     * @param amount The amount to send\n     */\n    function _safeTransferNative(address to, uint256 amount) private {\n        if (amount == 0) return;\n\n        (bool success,) = to.call{value: amount}(\"\");\n        if (!success) revert LBRouter__FailedToSendNATIVE(to, amount);\n    }\n\n    /**\n     * @notice Helper function to deposit and transfer WNative to `to`\n     * @param to The address of the recipient\n     * @param amount The amount to deposit and transfer\n     */\n    function _wNativeDepositAndTransfer(address to, uint256 amount) private {\n        if (amount == 0) return;\n\n        _wnative.deposit{value: amount}();\n        IERC20(_wnative).safeTransfer(to, amount);\n    }\n\n    /**\n     * @notice Helper function to withdraw and transfer WNative to `to`\n     * @param to The address of the recipient\n     * @param amount The amount to withdraw and transfer\n     */\n    function _wNativeWithdrawAndTransfer(address to, uint256 amount) private {\n        if (amount == 0) return;\n\n        _wnative.withdraw(amount);\n        _safeTransferNative(to, amount);\n    }\n}\n"
    },
    "contracts/joe-v2/src/LBToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {ILBToken} from \"./interfaces/ILBToken.sol\";\n\n/**\n * @title Liquidity Book Token\n * @author Trader Joe\n * @notice The LBToken is an implementation of a multi-token.\n * It allows to create multi-ERC20 represented by their ids.\n * Its implementation is really similar to the ERC1155 standard the main difference\n * is that it doesn't do any call to the receiver contract to prevent reentrancy.\n * As it's only for ERC20s, the uri function is not implemented.\n * The contract is made for batch operations.\n */\nabstract contract LBToken is ILBToken {\n    /**\n     * @dev The mapping from account to token id to account balance.\n     */\n    mapping(address => mapping(uint256 => uint256)) private _balances;\n\n    /**\n     * @dev The mapping from token id to total supply.\n     */\n    mapping(uint256 => uint256) private _totalSupplies;\n\n    /**\n     * @dev Mapping from account to spender approvals.\n     */\n    mapping(address => mapping(address => bool)) private _spenderApprovals;\n\n    /**\n     * @dev Modifier to check if the spender is approved for all.\n     */\n    modifier checkApproval(address from, address spender) {\n        if (!_isApprovedForAll(from, spender)) revert LBToken__SpenderNotApproved(from, spender);\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if the address is not zero or the contract itself.\n     */\n    modifier notAddressZeroOrThis(address account) {\n        _notAddressZeroOrThis(account);\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if the length of the arrays are equal.\n     */\n    modifier checkLength(uint256 lengthA, uint256 lengthB) {\n        _checkLength(lengthA, lengthB);\n        _;\n    }\n\n    /**\n     * @notice Returns the name of the token.\n     * @return The name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return \"Liquidity Book Token\";\n    }\n\n    /**\n     * @notice Returns the symbol of the token, usually a shorter version of the name.\n     * @return The symbol of the token.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return \"LBT\";\n    }\n\n    /**\n     * @notice Returns the total supply of token of type `id`.\n     * /**\n     * @dev This is the amount of token of type `id` minted minus the amount burned.\n     * @param id The token id.\n     * @return The total supply of that token id.\n     */\n    function totalSupply(uint256 id) public view virtual override returns (uint256) {\n        return _totalSupplies[id];\n    }\n\n    /**\n     * @notice Returns the amount of tokens of type `id` owned by `account`.\n     * @param account The address of the owner.\n     * @param id The token id.\n     * @return The amount of tokens of type `id` owned by `account`.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        return _balances[account][id];\n    }\n\n    /**\n     * @notice Return the balance of multiple (account/id) pairs.\n     * @param accounts The addresses of the owners.\n     * @param ids The token ids.\n     * @return batchBalances The balance for each (account, id) pair.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        public\n        view\n        virtual\n        override\n        checkLength(accounts.length, ids.length)\n        returns (uint256[] memory batchBalances)\n    {\n        batchBalances = new uint256[](accounts.length);\n\n        unchecked {\n            for (uint256 i; i < accounts.length; ++i) {\n                batchBalances[i] = balanceOf(accounts[i], ids[i]);\n            }\n        }\n    }\n\n    /**\n     * @notice Returns true if `spender` is approved to transfer `owner`'s tokens or if `spender` is the `owner`.\n     * @param owner The address of the owner.\n     * @param spender The address of the spender.\n     * @return True if `spender` is approved to transfer `owner`'s tokens.\n     */\n    function isApprovedForAll(address owner, address spender) public view virtual override returns (bool) {\n        return _isApprovedForAll(owner, spender);\n    }\n\n    /**\n     * @notice Grants or revokes permission to `spender` to transfer the caller's lbTokens, according to `approved`.\n     * @param spender The address of the spender.\n     * @param approved The boolean value to grant or revoke permission.\n     */\n    function approveForAll(address spender, bool approved) public virtual override {\n        _approveForAll(msg.sender, spender, approved);\n    }\n\n    /**\n     * @notice Batch transfers `amounts` of `ids` from `from` to `to`.\n     * @param from The address of the owner.\n     * @param to The address of the recipient.\n     * @param ids The list of token ids.\n     * @param amounts The list of amounts to transfer for each token id in `ids`.\n     */\n    function batchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts)\n        public\n        virtual\n        override\n        checkApproval(from, msg.sender)\n    {\n        _batchTransferFrom(from, to, ids, amounts);\n    }\n\n    /**\n     * @notice Returns true if `spender` is approved to transfer `owner`'s tokens or if `spender` is the `owner`.\n     * @param owner The address of the owner.\n     * @param spender The address of the spender.\n     * @return True if `spender` is approved to transfer `owner`'s tokens.\n     */\n    function _isApprovedForAll(address owner, address spender) internal view returns (bool) {\n        return owner == spender || _spenderApprovals[owner][spender];\n    }\n\n    /**\n     * @dev Mint `amount` of `id` to `account`.\n     * The `account` must not be the zero address.\n     * The event should be emitted by the contract that inherits this contract.\n     * @param account The address of the owner.\n     * @param id The token id.\n     * @param amount The amount to mint.\n     */\n    function _mint(address account, uint256 id, uint256 amount) internal {\n        _totalSupplies[id] += amount;\n\n        unchecked {\n            _balances[account][id] += amount;\n        }\n    }\n\n    /**\n     * @dev Burn `amount` of `id` from `account`.\n     * The `account` must not be the zero address.\n     * The event should be emitted by the contract that inherits this contract.\n     * @param account The address of the owner.\n     * @param id The token id.\n     * @param amount The amount to burn.\n     */\n    function _burn(address account, uint256 id, uint256 amount) internal {\n        mapping(uint256 => uint256) storage accountBalances = _balances[account];\n\n        uint256 balance = accountBalances[id];\n        if (balance < amount) revert LBToken__BurnExceedsBalance(account, id, amount);\n\n        unchecked {\n            _totalSupplies[id] -= amount;\n            accountBalances[id] = balance - amount;\n        }\n    }\n\n    /**\n     * @dev Batch transfers `amounts` of `ids` from `from` to `to`.\n     * The `to` must not be the zero address and the `ids` and `amounts` must have the same length.\n     * @param from The address of the owner.\n     * @param to The address of the recipient.\n     * @param ids The list of token ids.\n     * @param amounts The list of amounts to transfer for each token id in `ids`.\n     */\n    function _batchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts)\n        internal\n        checkLength(ids.length, amounts.length)\n        notAddressZeroOrThis(to)\n    {\n        mapping(uint256 => uint256) storage fromBalances = _balances[from];\n        mapping(uint256 => uint256) storage toBalances = _balances[to];\n\n        for (uint256 i; i < ids.length;) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = fromBalances[id];\n            if (fromBalance < amount) revert LBToken__TransferExceedsBalance(from, id, amount);\n\n            unchecked {\n                fromBalances[id] = fromBalance - amount;\n                toBalances[id] += amount;\n\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n    }\n\n    /**\n     * @notice Grants or revokes permission to `spender` to transfer the caller's tokens, according to `approved`\n     * @param owner The address of the owner\n     * @param spender The address of the spender\n     * @param approved The boolean value to grant or revoke permission\n     */\n    function _approveForAll(address owner, address spender, bool approved) internal notAddressZeroOrThis(owner) {\n        if (owner == spender) revert LBToken__SelfApproval(owner);\n\n        _spenderApprovals[owner][spender] = approved;\n        emit ApprovalForAll(owner, spender, approved);\n    }\n\n    /**\n     * @dev Reverts if the address is the zero address or the contract itself.\n     * @param account The address to check.\n     */\n    function _notAddressZeroOrThis(address account) internal view {\n        if (account == address(0) || account == address(this)) revert LBToken__AddressThisOrZero();\n    }\n\n    /**\n     * @dev Reverts if the length of the arrays are not equal.\n     * @param lengthA The length of the first array.\n     * @param lengthB The length of the second array.\n     */\n    function _checkLength(uint256 lengthA, uint256 lengthB) internal pure {\n        if (lengthA != lengthB) revert LBToken__InvalidLength();\n    }\n}\n"
    },
    "contracts/joe-v2/src/libraries/BinHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {PackedUint128Math} from \"./math/PackedUint128Math.sol\";\nimport {Uint256x256Math} from \"./math/Uint256x256Math.sol\";\nimport {SafeCast} from \"./math/SafeCast.sol\";\nimport {Constants} from \"./Constants.sol\";\nimport {PairParameterHelper} from \"./PairParameterHelper.sol\";\nimport {FeeHelper} from \"./FeeHelper.sol\";\nimport {PriceHelper} from \"./PriceHelper.sol\";\nimport {TokenHelper, IERC20} from \"./TokenHelper.sol\";\n\n/**\n * @title Liquidity Book Bin Helper Library\n * @author Trader Joe\n * @notice This library contains functions to help interaction with bins.\n */\nlibrary BinHelper {\n    using PackedUint128Math for bytes32;\n    using PackedUint128Math for uint128;\n    using Uint256x256Math for uint256;\n    using PriceHelper for uint24;\n    using SafeCast for uint256;\n    using PairParameterHelper for bytes32;\n    using FeeHelper for uint128;\n    using TokenHelper for IERC20;\n\n    error BinHelper__CompositionFactorFlawed(uint24 id);\n    error BinHelper__LiquidityOverflow();\n    error BinHelper__MaxLiquidityPerBinExceeded();\n\n    /**\n     * @dev Returns the amount of tokens that will be received when burning the given amount of liquidity\n     * @param binReserves The reserves of the bin\n     * @param amountToBurn The amount of liquidity to burn\n     * @param totalSupply The total supply of the liquidity book\n     * @return amountsOut The encoded amount of tokens that will be received\n     */\n    function getAmountOutOfBin(bytes32 binReserves, uint256 amountToBurn, uint256 totalSupply)\n        internal\n        pure\n        returns (bytes32 amountsOut)\n    {\n        (uint128 binReserveX, uint128 binReserveY) = binReserves.decode();\n\n        uint128 amountXOutFromBin;\n        uint128 amountYOutFromBin;\n\n        if (binReserveX > 0) {\n            amountXOutFromBin = (amountToBurn.mulDivRoundDown(binReserveX, totalSupply)).safe128();\n        }\n\n        if (binReserveY > 0) {\n            amountYOutFromBin = (amountToBurn.mulDivRoundDown(binReserveY, totalSupply)).safe128();\n        }\n\n        amountsOut = amountXOutFromBin.encode(amountYOutFromBin);\n    }\n\n    /**\n     * @dev Returns the share and the effective amounts in when adding liquidity\n     * @param binReserves The reserves of the bin\n     * @param amountsIn The amounts of tokens to add\n     * @param price The price of the bin\n     * @param totalSupply The total supply of the liquidity book\n     * @return shares The share of the liquidity book that the user will receive\n     * @return effectiveAmountsIn The encoded effective amounts of tokens that the user will add.\n     * This is the amount of tokens that the user will actually add to the liquidity book,\n     * and will always be less than or equal to the amountsIn.\n     */\n    function getSharesAndEffectiveAmountsIn(bytes32 binReserves, bytes32 amountsIn, uint256 price, uint256 totalSupply)\n        internal\n        pure\n        returns (uint256 shares, bytes32 effectiveAmountsIn)\n    {\n        (uint256 x, uint256 y) = amountsIn.decode();\n\n        uint256 userLiquidity = getLiquidity(x, y, price);\n        if (userLiquidity == 0) return (0, 0);\n\n        uint256 binLiquidity = getLiquidity(binReserves, price);\n        if (binLiquidity == 0 || totalSupply == 0) return (userLiquidity.sqrt(), amountsIn);\n\n        shares = userLiquidity.mulDivRoundDown(totalSupply, binLiquidity);\n        uint256 effectiveLiquidity = shares.mulDivRoundUp(binLiquidity, totalSupply);\n\n        if (userLiquidity > effectiveLiquidity) {\n            uint256 deltaLiquidity = userLiquidity - effectiveLiquidity;\n\n            // The other way might be more efficient, but as y is the quote asset, it is more valuable\n            if (deltaLiquidity >= Constants.SCALE) {\n                uint256 deltaY = deltaLiquidity >> Constants.SCALE_OFFSET;\n                deltaY = deltaY > y ? y : deltaY;\n\n                y -= deltaY;\n                deltaLiquidity -= deltaY << Constants.SCALE_OFFSET;\n            }\n\n            if (deltaLiquidity >= price) {\n                uint256 deltaX = deltaLiquidity / price;\n                deltaX = deltaX > x ? x : deltaX;\n\n                x -= deltaX;\n            }\n\n            amountsIn = uint128(x).encode(uint128(y));\n        }\n\n        if (getLiquidity(binReserves.add(amountsIn), price) > Constants.MAX_LIQUIDITY_PER_BIN) {\n            revert BinHelper__MaxLiquidityPerBinExceeded();\n        }\n\n        return (shares, amountsIn);\n    }\n\n    /**\n     * @dev Returns the amount of liquidity following the constant sum formula `L = price * x + y`\n     * @param amounts The amounts of tokens\n     * @param price The price of the bin\n     * @return liquidity The amount of liquidity\n     */\n    function getLiquidity(bytes32 amounts, uint256 price) internal pure returns (uint256 liquidity) {\n        (uint256 x, uint256 y) = amounts.decode();\n        return getLiquidity(x, y, price);\n    }\n\n    /**\n     * @dev Returns the amount of liquidity following the constant sum formula `L = price * x + y`\n     * @param x The amount of the token X\n     * @param y The amount of the token Y\n     * @param price The price of the bin\n     * @return liquidity The amount of liquidity\n     */\n    function getLiquidity(uint256 x, uint256 y, uint256 price) internal pure returns (uint256 liquidity) {\n        if (x > 0) {\n            unchecked {\n                liquidity = price * x;\n                if (liquidity / x != price) revert BinHelper__LiquidityOverflow();\n            }\n        }\n        if (y > 0) {\n            unchecked {\n                y <<= Constants.SCALE_OFFSET;\n                liquidity += y;\n\n                if (liquidity < y) revert BinHelper__LiquidityOverflow();\n            }\n        }\n\n        return liquidity;\n    }\n\n    /**\n     * @dev Verify that the amounts are correct and that the composition factor is not flawed\n     * @param amounts The amounts of tokens\n     * @param activeId The id of the active bin\n     * @param id The id of the bin\n     */\n    function verifyAmounts(bytes32 amounts, uint24 activeId, uint24 id) internal pure {\n        if (id < activeId && (amounts << 128) > 0 || id > activeId && uint256(amounts) > type(uint128).max) {\n            revert BinHelper__CompositionFactorFlawed(id);\n        }\n    }\n\n    /**\n     * @dev Returns the composition fees when adding liquidity to the active bin with a different\n     * composition factor than the bin's one, as it does an implicit swap\n     * @param binReserves The reserves of the bin\n     * @param parameters The parameters of the liquidity book\n     * @param binStep The step of the bin\n     * @param amountsIn The amounts of tokens to add\n     * @param totalSupply The total supply of the liquidity book\n     * @param shares The share of the liquidity book that the user will receive\n     * @return fees The encoded fees that will be charged\n     */\n    function getCompositionFees(\n        bytes32 binReserves,\n        bytes32 parameters,\n        uint16 binStep,\n        bytes32 amountsIn,\n        uint256 totalSupply,\n        uint256 shares\n    ) internal pure returns (bytes32 fees) {\n        if (shares == 0) return 0;\n\n        (uint128 amountX, uint128 amountY) = amountsIn.decode();\n        (uint128 receivedAmountX, uint128 receivedAmountY) =\n            getAmountOutOfBin(binReserves.add(amountsIn), shares, totalSupply + shares).decode();\n\n        if (receivedAmountX > amountX) {\n            uint128 feeY = (amountY - receivedAmountY).getCompositionFee(parameters.getTotalFee(binStep));\n\n            fees = feeY.encodeSecond();\n        } else if (receivedAmountY > amountY) {\n            uint128 feeX = (amountX - receivedAmountX).getCompositionFee(parameters.getTotalFee(binStep));\n\n            fees = feeX.encodeFirst();\n        }\n    }\n\n    /**\n     * @dev Returns whether the bin is empty (true) or not (false)\n     * @param binReserves The reserves of the bin\n     * @param isX Whether the reserve to check is the X reserve (true) or the Y reserve (false)\n     * @return Whether the bin is empty (true) or not (false)\n     */\n    function isEmpty(bytes32 binReserves, bool isX) internal pure returns (bool) {\n        return isX ? binReserves.decodeX() == 0 : binReserves.decodeY() == 0;\n    }\n\n    /**\n     * @dev Returns the amounts of tokens that will be added and removed from the bin during a swap\n     * along with the fees that will be charged\n     * @param binReserves The reserves of the bin\n     * @param parameters The parameters of the liquidity book\n     * @param binStep The step of the bin\n     * @param swapForY Whether the swap is for Y (true) or for X (false)\n     * @param activeId The id of the active bin\n     * @param amountsInLeft The amounts of tokens left to swap\n     * @return amountsInWithFees The encoded amounts of tokens that will be added to the bin, including fees\n     * @return amountsOutOfBin The encoded amounts of tokens that will be removed from the bin\n     * @return totalFees The encoded fees that will be charged\n     */\n    function getAmounts(\n        bytes32 binReserves,\n        bytes32 parameters,\n        uint16 binStep,\n        bool swapForY, // swap `swapForY` and `activeId` to avoid stack too deep\n        uint24 activeId,\n        bytes32 amountsInLeft\n    ) internal pure returns (bytes32 amountsInWithFees, bytes32 amountsOutOfBin, bytes32 totalFees) {\n        uint256 price = activeId.getPriceFromId(binStep);\n\n        {\n            uint128 binReserveOut = binReserves.decode(!swapForY);\n\n            uint128 maxAmountIn = swapForY\n                ? uint256(binReserveOut).shiftDivRoundUp(Constants.SCALE_OFFSET, price).safe128()\n                : uint256(binReserveOut).mulShiftRoundUp(price, Constants.SCALE_OFFSET).safe128();\n\n            uint128 totalFee = parameters.getTotalFee(binStep);\n            uint128 maxFee = maxAmountIn.getFeeAmount(totalFee);\n\n            maxAmountIn += maxFee;\n\n            uint128 amountIn128 = amountsInLeft.decode(swapForY);\n            uint128 fee128;\n            uint128 amountOut128;\n\n            if (amountIn128 >= maxAmountIn) {\n                fee128 = maxFee;\n\n                amountIn128 = maxAmountIn;\n                amountOut128 = binReserveOut;\n            } else {\n                fee128 = amountIn128.getFeeAmountFrom(totalFee);\n\n                uint256 amountIn = amountIn128 - fee128;\n\n                amountOut128 = swapForY\n                    ? uint256(amountIn).mulShiftRoundDown(price, Constants.SCALE_OFFSET).safe128()\n                    : uint256(amountIn).shiftDivRoundDown(Constants.SCALE_OFFSET, price).safe128();\n\n                if (amountOut128 > binReserveOut) amountOut128 = binReserveOut;\n            }\n\n            (amountsInWithFees, amountsOutOfBin, totalFees) = swapForY\n                ? (amountIn128.encodeFirst(), amountOut128.encodeSecond(), fee128.encodeFirst())\n                : (amountIn128.encodeSecond(), amountOut128.encodeFirst(), fee128.encodeSecond());\n        }\n\n        if (\n            getLiquidity(binReserves.add(amountsInWithFees).sub(amountsOutOfBin), price)\n                > Constants.MAX_LIQUIDITY_PER_BIN\n        ) {\n            revert BinHelper__MaxLiquidityPerBinExceeded();\n        }\n    }\n\n    /**\n     * @dev Returns the encoded amounts that were transferred to the contract\n     * @param reserves The reserves\n     * @param tokenX The token X\n     * @param tokenY The token Y\n     * @return amounts The amounts, encoded as follows:\n     * [0 - 128[: amountX\n     * [128 - 256[: amountY\n     */\n    function received(bytes32 reserves, IERC20 tokenX, IERC20 tokenY) internal view returns (bytes32 amounts) {\n        amounts = _balanceOf(tokenX).encode(_balanceOf(tokenY)).sub(reserves);\n    }\n\n    /**\n     * @dev Returns the encoded amounts that were transferred to the contract, only for token X\n     * @param reserves The reserves\n     * @param tokenX The token X\n     * @return amounts The amounts, encoded as follows:\n     * [0 - 128[: amountX\n     * [128 - 256[: empty\n     */\n    function receivedX(bytes32 reserves, IERC20 tokenX) internal view returns (bytes32) {\n        uint128 reserveX = reserves.decodeX();\n        return (_balanceOf(tokenX) - reserveX).encodeFirst();\n    }\n\n    /**\n     * @dev Returns the encoded amounts that were transferred to the contract, only for token Y\n     * @param reserves The reserves\n     * @param tokenY The token Y\n     * @return amounts The amounts, encoded as follows:\n     * [0 - 128[: empty\n     * [128 - 256[: amountY\n     */\n    function receivedY(bytes32 reserves, IERC20 tokenY) internal view returns (bytes32) {\n        uint128 reserveY = reserves.decodeY();\n        return (_balanceOf(tokenY) - reserveY).encodeSecond();\n    }\n\n    /**\n     * @dev Transfers the encoded amounts to the recipient\n     * @param amounts The amounts, encoded as follows:\n     * [0 - 128[: amountX\n     * [128 - 256[: amountY\n     * @param tokenX The token X\n     * @param tokenY The token Y\n     * @param recipient The recipient\n     */\n    function transfer(bytes32 amounts, IERC20 tokenX, IERC20 tokenY, address recipient) internal {\n        (uint128 amountX, uint128 amountY) = amounts.decode();\n\n        if (amountX > 0) tokenX.safeTransfer(recipient, amountX);\n        if (amountY > 0) tokenY.safeTransfer(recipient, amountY);\n    }\n\n    /**\n     * @dev Transfers the encoded amounts to the recipient, only for token X\n     * @param amounts The amounts, encoded as follows:\n     * [0 - 128[: amountX\n     * [128 - 256[: empty\n     * @param tokenX The token X\n     * @param recipient The recipient\n     */\n    function transferX(bytes32 amounts, IERC20 tokenX, address recipient) internal {\n        uint128 amountX = amounts.decodeX();\n\n        if (amountX > 0) tokenX.safeTransfer(recipient, amountX);\n    }\n\n    /**\n     * @dev Transfers the encoded amounts to the recipient, only for token Y\n     * @param amounts The amounts, encoded as follows:\n     * [0 - 128[: empty\n     * [128 - 256[: amountY\n     * @param tokenY The token Y\n     * @param recipient The recipient\n     */\n    function transferY(bytes32 amounts, IERC20 tokenY, address recipient) internal {\n        uint128 amountY = amounts.decodeY();\n\n        if (amountY > 0) tokenY.safeTransfer(recipient, amountY);\n    }\n\n    function _balanceOf(IERC20 token) private view returns (uint128) {\n        return token.balanceOf(address(this)).safe128();\n    }\n}\n"
    },
    "contracts/joe-v2/src/libraries/Clone.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @title Clone\n * @notice Class with helper read functions for clone with immutable args.\n * @author Trader Joe\n * @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Clone.sol)\n * @author Adapted from clones with immutable args by zefram.eth, Saw-mon & Natalie\n * (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)\n */\nabstract contract Clone {\n    /**\n     * @dev Reads an immutable arg with type bytes\n     * @param argOffset The offset of the arg in the immutable args\n     * @param length The length of the arg\n     * @return arg The immutable bytes arg\n     */\n    function _getArgBytes(uint256 argOffset, uint256 length) internal pure returns (bytes memory arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            arg := mload(0x40)\n            // Store the array length.\n            mstore(arg, length)\n            // Copy the array.\n            calldatacopy(add(arg, 0x20), add(offset, argOffset), length)\n            // Allocate the memory, rounded up to the next 32 byte boundary.\n            mstore(0x40, and(add(add(arg, 0x3f), length), not(0x1f)))\n        }\n    }\n\n    /**\n     * @dev Reads an immutable arg with type address\n     * @param argOffset The offset of the arg in the immutable args\n     * @return arg The immutable address arg\n     */\n    function _getArgAddress(uint256 argOffset) internal pure returns (address arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(0x60, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /**\n     * @dev Reads an immutable arg with type uint256\n     * @param argOffset The offset of the arg in the immutable args\n     * @return arg The immutable uint256 arg\n     */\n    function _getArgUint256(uint256 argOffset) internal pure returns (uint256 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := calldataload(add(offset, argOffset))\n        }\n    }\n\n    /**\n     * @dev Reads a uint256 array stored in the immutable args.\n     * @param argOffset The offset of the arg in the immutable args\n     * @param length The length of the arg\n     * @return arg The immutable uint256 array arg\n     */\n    function _getArgUint256Array(uint256 argOffset, uint256 length) internal pure returns (uint256[] memory arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            arg := mload(0x40)\n            // Store the array length.\n            mstore(arg, length)\n            // Copy the array.\n            calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))\n            // Allocate the memory.\n            mstore(0x40, add(add(arg, 0x20), shl(5, length)))\n        }\n    }\n\n    /**\n     * @dev Reads an immutable arg with type uint64\n     * @param argOffset The offset of the arg in the immutable args\n     * @return arg The immutable uint64 arg\n     */\n    function _getArgUint64(uint256 argOffset) internal pure returns (uint64 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(0xc0, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /**\n     * @dev Reads an immutable arg with type uint16\n     * @param argOffset The offset of the arg in the immutable args\n     * @return arg The immutable uint16 arg\n     */\n    function _getArgUint16(uint256 argOffset) internal pure returns (uint16 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(0xf0, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /**\n     * @dev Reads an immutable arg with type uint8\n     * @param argOffset The offset of the arg in the immutable args\n     * @return arg The immutable uint8 arg\n     */\n    function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(0xf8, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /**\n     * @dev Reads the offset of the packed immutable args in calldata.\n     * @return offset The offset of the packed immutable args in calldata.\n     */\n    function _getImmutableArgsOffset() internal pure returns (uint256 offset) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            offset := sub(calldatasize(), shr(0xf0, calldataload(sub(calldatasize(), 2))))\n        }\n    }\n}\n"
    },
    "contracts/joe-v2/src/libraries/Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @title Liquidity Book Constants Library\n * @author Trader Joe\n * @notice Set of constants for Liquidity Book contracts\n */\nlibrary Constants {\n    uint8 internal constant SCALE_OFFSET = 128;\n    uint256 internal constant SCALE = 1 << SCALE_OFFSET;\n\n    uint256 internal constant PRECISION = 1e18;\n    uint256 internal constant SQUARED_PRECISION = PRECISION * PRECISION;\n\n    uint256 internal constant MAX_FEE = 0.1e18; // 10%\n    uint256 internal constant MAX_PROTOCOL_SHARE = 2_500; // 25% of the fee\n\n    uint256 internal constant BASIS_POINT_MAX = 10_000;\n\n    // (2^256 - 1) / (2 * log(2**128) / log(1.0001))\n    uint256 internal constant MAX_LIQUIDITY_PER_BIN =\n        65251743116719673010965625540244653191619923014385985379600384103134737;\n\n    /// @dev The expected return after a successful flash loan\n    bytes32 internal constant CALLBACK_SUCCESS = keccak256(\"LBPair.onFlashLoan\");\n}\n"
    },
    "contracts/joe-v2/src/libraries/FeeHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {Constants} from \"./Constants.sol\";\n\n/**\n * @title Liquidity Book Fee Helper Library\n * @author Trader Joe\n * @notice This library contains functions to calculate fees\n */\nlibrary FeeHelper {\n    error FeeHelper__FeeTooLarge();\n    error FeeHelper__ProtocolShareTooLarge();\n\n    /**\n     * @dev Modifier to check that the fee is not too large\n     * @param fee The fee\n     */\n    modifier verifyFee(uint128 fee) {\n        _verifyFee(fee);\n        _;\n    }\n\n    /**\n     * @dev Modifier to check that the protocol share is not too large\n     * @param protocolShare The protocol share\n     */\n    modifier verifyProtocolShare(uint128 protocolShare) {\n        if (protocolShare > Constants.MAX_PROTOCOL_SHARE) revert FeeHelper__ProtocolShareTooLarge();\n        _;\n    }\n\n    /**\n     * @dev Calculates the fee amount from the amount with fees, rounding up\n     * @param amountWithFees The amount with fees\n     * @param totalFee The total fee\n     * @return feeAmount The fee amount\n     */\n    function getFeeAmountFrom(uint128 amountWithFees, uint128 totalFee)\n        internal\n        pure\n        verifyFee(totalFee)\n        returns (uint128)\n    {\n        unchecked {\n            // Can't overflow, max(result) = (type(uint128).max * 0.1e18 + 1e18 - 1) / 1e18 < 2^128\n            return uint128((uint256(amountWithFees) * totalFee + Constants.PRECISION - 1) / Constants.PRECISION);\n        }\n    }\n\n    /**\n     * @dev Calculates the fee amount that will be charged, rounding up\n     * @param amount The amount\n     * @param totalFee The total fee\n     * @return feeAmount The fee amount\n     */\n    function getFeeAmount(uint128 amount, uint128 totalFee) internal pure verifyFee(totalFee) returns (uint128) {\n        unchecked {\n            uint256 denominator = Constants.PRECISION - totalFee;\n            // Can't overflow, max(result) = (type(uint128).max * 0.1e18 + (1e18 - 1)) / 0.9e18 < 2^128\n            return uint128((uint256(amount) * totalFee + denominator - 1) / denominator);\n        }\n    }\n\n    /**\n     * @dev Calculates the composition fee amount from the amount with fees, rounding down\n     * @param amountWithFees The amount with fees\n     * @param totalFee The total fee\n     * @return The amount with fees\n     */\n    function getCompositionFee(uint128 amountWithFees, uint128 totalFee)\n        internal\n        pure\n        verifyFee(totalFee)\n        returns (uint128)\n    {\n        unchecked {\n            uint256 denominator = Constants.SQUARED_PRECISION;\n            // Can't overflow, max(result) = type(uint128).max * 0.1e18 * 1.1e18 / 1e36 <= 2^128 * 0.11e36 / 1e36 < 2^128\n            return uint128(uint256(amountWithFees) * totalFee * (uint256(totalFee) + Constants.PRECISION) / denominator);\n        }\n    }\n\n    /**\n     * @dev Calculates the protocol fee amount from the fee amount and the protocol share, rounding down\n     * @param feeAmount The fee amount\n     * @param protocolShare The protocol share\n     * @return protocolFeeAmount The protocol fee amount\n     */\n    function getProtocolFeeAmount(uint128 feeAmount, uint128 protocolShare)\n        internal\n        pure\n        verifyProtocolShare(protocolShare)\n        returns (uint128)\n    {\n        unchecked {\n            return uint128(uint256(feeAmount) * protocolShare / Constants.BASIS_POINT_MAX);\n        }\n    }\n\n    /**\n     * @dev Internal function to check that the fee is not too large\n     * @param fee The fee\n     */\n    function _verifyFee(uint128 fee) private pure {\n        if (fee > Constants.MAX_FEE) revert FeeHelper__FeeTooLarge();\n    }\n}\n"
    },
    "contracts/joe-v2/src/libraries/Hooks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {ILBHooks} from \"../interfaces/ILBHooks.sol\";\n\n/**\n * @title Hooks library\n * @notice This library contains functions that should be used to interact with hooks\n */\nlibrary Hooks {\n    error Hooks__CallFailed();\n\n    bytes32 internal constant BEFORE_SWAP_FLAG = bytes32(uint256(1 << 160));\n    bytes32 internal constant AFTER_SWAP_FLAG = bytes32(uint256(1 << 161));\n    bytes32 internal constant BEFORE_FLASH_LOAN_FLAG = bytes32(uint256(1 << 162));\n    bytes32 internal constant AFTER_FLASH_LOAN_FLAG = bytes32(uint256(1 << 163));\n    bytes32 internal constant BEFORE_MINT_FLAG = bytes32(uint256(1 << 164));\n    bytes32 internal constant AFTER_MINT_FLAG = bytes32(uint256(1 << 165));\n    bytes32 internal constant BEFORE_BURN_FLAG = bytes32(uint256(1 << 166));\n    bytes32 internal constant AFTER_BURN_FLAG = bytes32(uint256(1 << 167));\n    bytes32 internal constant BEFORE_TRANSFER_FLAG = bytes32(uint256(1 << 168));\n    bytes32 internal constant AFTER_TRANSFER_FLAG = bytes32(uint256(1 << 169));\n\n    struct Parameters {\n        address hooks;\n        bool beforeSwap;\n        bool afterSwap;\n        bool beforeFlashLoan;\n        bool afterFlashLoan;\n        bool beforeMint;\n        bool afterMint;\n        bool beforeBurn;\n        bool afterBurn;\n        bool beforeBatchTransferFrom;\n        bool afterBatchTransferFrom;\n    }\n\n    /**\n     * @dev Helper function to encode the hooks parameters to a single bytes32 value\n     * @param parameters The hooks parameters\n     * @return hooksParameters The encoded hooks parameters\n     */\n    function encode(Parameters memory parameters) internal pure returns (bytes32 hooksParameters) {\n        hooksParameters = bytes32(uint256(uint160(address(parameters.hooks))));\n\n        if (parameters.beforeSwap) hooksParameters |= BEFORE_SWAP_FLAG;\n        if (parameters.afterSwap) hooksParameters |= AFTER_SWAP_FLAG;\n        if (parameters.beforeFlashLoan) hooksParameters |= BEFORE_FLASH_LOAN_FLAG;\n        if (parameters.afterFlashLoan) hooksParameters |= AFTER_FLASH_LOAN_FLAG;\n        if (parameters.beforeMint) hooksParameters |= BEFORE_MINT_FLAG;\n        if (parameters.afterMint) hooksParameters |= AFTER_MINT_FLAG;\n        if (parameters.beforeBurn) hooksParameters |= BEFORE_BURN_FLAG;\n        if (parameters.afterBurn) hooksParameters |= AFTER_BURN_FLAG;\n        if (parameters.beforeBatchTransferFrom) hooksParameters |= BEFORE_TRANSFER_FLAG;\n        if (parameters.afterBatchTransferFrom) hooksParameters |= AFTER_TRANSFER_FLAG;\n    }\n\n    /**\n     * @dev Helper function to decode the hooks parameters from a single bytes32 value\n     * @param hooksParameters The encoded hooks parameters\n     * @return parameters The hooks parameters\n     */\n    function decode(bytes32 hooksParameters) internal pure returns (Parameters memory parameters) {\n        parameters.hooks = getHooks(hooksParameters);\n\n        parameters.beforeSwap = (hooksParameters & BEFORE_SWAP_FLAG) != 0;\n        parameters.afterSwap = (hooksParameters & AFTER_SWAP_FLAG) != 0;\n        parameters.beforeFlashLoan = (hooksParameters & BEFORE_FLASH_LOAN_FLAG) != 0;\n        parameters.afterFlashLoan = (hooksParameters & AFTER_FLASH_LOAN_FLAG) != 0;\n        parameters.beforeMint = (hooksParameters & BEFORE_MINT_FLAG) != 0;\n        parameters.afterMint = (hooksParameters & AFTER_MINT_FLAG) != 0;\n        parameters.beforeBurn = (hooksParameters & BEFORE_BURN_FLAG) != 0;\n        parameters.afterBurn = (hooksParameters & AFTER_BURN_FLAG) != 0;\n        parameters.beforeBatchTransferFrom = (hooksParameters & BEFORE_TRANSFER_FLAG) != 0;\n        parameters.afterBatchTransferFrom = (hooksParameters & AFTER_TRANSFER_FLAG) != 0;\n    }\n\n    /**\n     * @dev Helper function to get the hooks address from the encoded hooks parameters\n     * @param hooksParameters The encoded hooks parameters\n     * @return hooks The hooks address\n     */\n    function getHooks(bytes32 hooksParameters) internal pure returns (address hooks) {\n        hooks = address(uint160(uint256(hooksParameters)));\n    }\n\n    /**\n     * @dev Helper function to set the hooks address in the encoded hooks parameters\n     * @param hooksParameters The encoded hooks parameters\n     * @param newHooks The new hooks address\n     * @return hooksParameters The updated hooks parameters\n     */\n    function setHooks(bytes32 hooksParameters, address newHooks) internal pure returns (bytes32) {\n        return bytes32(bytes12(hooksParameters)) | bytes32(uint256(uint160(newHooks)));\n    }\n\n    /**\n     * @dev Helper function to get the flags from the encoded hooks parameters\n     * @param hooksParameters The encoded hooks parameters\n     * @return flags The flags\n     */\n    function getFlags(bytes32 hooksParameters) internal pure returns (bytes12 flags) {\n        flags = bytes12(hooksParameters);\n    }\n\n    /**\n     * @dev Helper function call the onHooksSet function on the hooks contract, only if the\n     * hooksParameters is not 0\n     * @param hooksParameters The encoded hooks parameters\n     * @param onHooksSetData The data to pass to the onHooksSet function\n     */\n    function onHooksSet(bytes32 hooksParameters, bytes calldata onHooksSetData) internal {\n        if (hooksParameters != 0) {\n            _safeCall(\n                hooksParameters, abi.encodeWithSelector(ILBHooks.onHooksSet.selector, hooksParameters, onHooksSetData)\n            );\n        }\n    }\n\n    /**\n     * @dev Helper function to call the beforeSwap function on the hooks contract, only if the\n     * BEFORE_SWAP_FLAG is set in the hooksParameters\n     * @param hooksParameters The encoded hooks parameters\n     * @param sender The sender\n     * @param to The recipient\n     * @param swapForY Whether the swap is for Y\n     * @param amountsIn The amounts in\n     */\n    function beforeSwap(bytes32 hooksParameters, address sender, address to, bool swapForY, bytes32 amountsIn)\n        internal\n    {\n        if ((hooksParameters & BEFORE_SWAP_FLAG) != 0) {\n            _safeCall(\n                hooksParameters, abi.encodeWithSelector(ILBHooks.beforeSwap.selector, sender, to, swapForY, amountsIn)\n            );\n        }\n    }\n\n    /**\n     * @dev Helper function to call the afterSwap function on the hooks contract, only if the\n     * AFTER_SWAP_FLAG is set in the hooksParameters\n     * @param hooksParameters The encoded hooks parameters\n     * @param sender The sender\n     * @param to The recipient\n     * @param swapForY Whether the swap is for Y\n     * @param amountsOut The amounts out\n     */\n    function afterSwap(bytes32 hooksParameters, address sender, address to, bool swapForY, bytes32 amountsOut)\n        internal\n    {\n        if ((hooksParameters & AFTER_SWAP_FLAG) != 0) {\n            _safeCall(\n                hooksParameters, abi.encodeWithSelector(ILBHooks.afterSwap.selector, sender, to, swapForY, amountsOut)\n            );\n        }\n    }\n\n    /**\n     * @dev Helper function to call the beforeFlashLoan function on the hooks contract, only if the\n     * BEFORE_FLASH_LOAN_FLAG is set in the hooksParameters\n     * @param hooksParameters The encoded hooks parameters\n     * @param sender The sender\n     * @param to The recipient\n     * @param amounts The amounts\n     */\n    function beforeFlashLoan(bytes32 hooksParameters, address sender, address to, bytes32 amounts) internal {\n        if ((hooksParameters & BEFORE_FLASH_LOAN_FLAG) != 0) {\n            _safeCall(hooksParameters, abi.encodeWithSelector(ILBHooks.beforeFlashLoan.selector, sender, to, amounts));\n        }\n    }\n\n    /**\n     * @dev Helper function to call the afterFlashLoan function on the hooks contract, only if the\n     * AFTER_FLASH_LOAN_FLAG is set in the hooksParameters\n     * @param hooksParameters The encoded hooks parameters\n     * @param sender The sender\n     * @param to The recipient\n     * @param fees The fees\n     * @param feesReceived The fees received\n     */\n    function afterFlashLoan(bytes32 hooksParameters, address sender, address to, bytes32 fees, bytes32 feesReceived)\n        internal\n    {\n        if ((hooksParameters & AFTER_FLASH_LOAN_FLAG) != 0) {\n            _safeCall(\n                hooksParameters,\n                abi.encodeWithSelector(ILBHooks.afterFlashLoan.selector, sender, to, fees, feesReceived)\n            );\n        }\n    }\n\n    /**\n     * @dev Helper function to call the beforeMint function on the hooks contract, only if the\n     * BEFORE_MINT_FLAG is set in the hooksParameters\n     * @param hooksParameters The encoded hooks parameters\n     * @param sender The sender\n     * @param to The recipient\n     * @param liquidityConfigs The liquidity configs\n     * @param amountsReceived The amounts received\n     */\n    function beforeMint(\n        bytes32 hooksParameters,\n        address sender,\n        address to,\n        bytes32[] calldata liquidityConfigs,\n        bytes32 amountsReceived\n    ) internal {\n        if ((hooksParameters & BEFORE_MINT_FLAG) != 0) {\n            _safeCall(\n                hooksParameters,\n                abi.encodeWithSelector(ILBHooks.beforeMint.selector, sender, to, liquidityConfigs, amountsReceived)\n            );\n        }\n    }\n\n    /**\n     * @dev Helper function to call the afterMint function on the hooks contract, only if the\n     * AFTER_MINT_FLAG is set in the hooksParameters\n     * @param hooksParameters The encoded hooks parameters\n     * @param sender The sender\n     * @param to The recipient\n     * @param liquidityConfigs The liquidity configs\n     * @param amountsIn The amounts in\n     */\n    function afterMint(\n        bytes32 hooksParameters,\n        address sender,\n        address to,\n        bytes32[] calldata liquidityConfigs,\n        bytes32 amountsIn\n    ) internal {\n        if ((hooksParameters & AFTER_MINT_FLAG) != 0) {\n            _safeCall(\n                hooksParameters,\n                abi.encodeWithSelector(ILBHooks.afterMint.selector, sender, to, liquidityConfigs, amountsIn)\n            );\n        }\n    }\n\n    /**\n     * @dev Helper function to call the beforeBurn function on the hooks contract, only if the\n     * BEFORE_BURN_FLAG is set in the hooksParameters\n     * @param hooksParameters The encoded hooks parameters\n     * @param sender The sender\n     * @param from The sender\n     * @param to The recipient\n     * @param ids The ids\n     * @param amountsToBurn The amounts to burn\n     */\n    function beforeBurn(\n        bytes32 hooksParameters,\n        address sender,\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amountsToBurn\n    ) internal {\n        if ((hooksParameters & BEFORE_BURN_FLAG) != 0) {\n            _safeCall(\n                hooksParameters,\n                abi.encodeWithSelector(ILBHooks.beforeBurn.selector, sender, from, to, ids, amountsToBurn)\n            );\n        }\n    }\n\n    /**\n     * @dev Helper function to call the afterBurn function on the hooks contract, only if the\n     * AFTER_BURN_FLAG is set in the hooksParameters\n     * @param hooksParameters The encoded hooks parameters\n     * @param sender The sender\n     * @param from The sender\n     * @param to The recipient\n     * @param ids The ids\n     * @param amountsToBurn The amounts to burn\n     */\n    function afterBurn(\n        bytes32 hooksParameters,\n        address sender,\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amountsToBurn\n    ) internal {\n        if ((hooksParameters & AFTER_BURN_FLAG) != 0) {\n            _safeCall(\n                hooksParameters,\n                abi.encodeWithSelector(ILBHooks.afterBurn.selector, sender, from, to, ids, amountsToBurn)\n            );\n        }\n    }\n\n    /**\n     * @dev Helper function to call the beforeTransferFrom function on the hooks contract, only if the\n     * BEFORE_TRANSFER_FLAG is set in the hooksParameters\n     * @param hooksParameters The encoded hooks parameters\n     * @param sender The sender\n     * @param from The sender\n     * @param to The recipient\n     * @param ids The list of ids\n     * @param amounts The list of amounts\n     */\n    function beforeBatchTransferFrom(\n        bytes32 hooksParameters,\n        address sender,\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) internal {\n        if ((hooksParameters & BEFORE_TRANSFER_FLAG) != 0) {\n            _safeCall(\n                hooksParameters,\n                abi.encodeWithSelector(ILBHooks.beforeBatchTransferFrom.selector, sender, from, to, ids, amounts)\n            );\n        }\n    }\n\n    /**\n     * @dev Helper function to call the afterTransferFrom function on the hooks contract, only if the\n     * AFTER_TRANSFER_FLAG is set in the hooksParameters\n     * @param hooksParameters The encoded hooks parameters\n     * @param sender The sender\n     * @param from The sender\n     * @param to The recipient\n     * @param ids The list of ids\n     * @param amounts The list of amounts\n     */\n    function afterBatchTransferFrom(\n        bytes32 hooksParameters,\n        address sender,\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) internal {\n        if ((hooksParameters & AFTER_TRANSFER_FLAG) != 0) {\n            _safeCall(\n                hooksParameters,\n                abi.encodeWithSelector(ILBHooks.afterBatchTransferFrom.selector, sender, from, to, ids, amounts)\n            );\n        }\n    }\n\n    /**\n     * @dev Helper function to call the hooks contract and verify the call was successful\n     * by matching the expected selector with the returned data\n     * @param hooksParameters The encoded hooks parameters\n     * @param data The data to pass to the hooks contract\n     */\n    function _safeCall(bytes32 hooksParameters, bytes memory data) private {\n        bool success;\n\n        address hooks = getHooks(hooksParameters);\n\n        assembly {\n            let expectedSelector := shr(224, mload(add(data, 0x20)))\n\n            success := call(gas(), hooks, 0, add(data, 0x20), mload(data), 0, 0x20)\n\n            if and(iszero(success), iszero(iszero(returndatasize()))) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n\n            success := and(success, and(gt(returndatasize(), 0x1f), eq(shr(224, mload(0)), expectedSelector)))\n        }\n\n        if (!success) revert Hooks__CallFailed();\n    }\n}\n"
    },
    "contracts/joe-v2/src/libraries/ImmutableClone.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @title Liquidity Book Immutable Clone Library\n * @notice Minimal immutable proxy library.\n * @author Trader Joe\n * @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)\n * @author Minimal proxy by 0age (https://github.com/0age)\n * @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie\n * (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)\n * @dev Minimal proxy:\n * Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,\n * it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,\n * which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.\n * @dev Clones with immutable args (CWIA):\n * The implementation of CWIA here doesn't implements a `receive()` as it is not needed for LB.\n */\nlibrary ImmutableClone {\n    error DeploymentFailed();\n    error PackedDataTooBig();\n\n    /**\n     * @dev Deploys a deterministic clone of `implementation` using immutable arguments encoded in `data`, with `salt`\n     * @param implementation The address of the implementation\n     * @param data The encoded immutable arguments\n     * @param salt The salt\n     */\n    function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        assembly {\n            // Compute the boundaries of the data and cache the memory slots around it.\n            let mBefore2 := mload(sub(data, 0x40))\n            let mBefore1 := mload(sub(data, 0x20))\n            let dataLength := mload(data)\n            let dataEnd := add(add(data, 0x20), dataLength)\n            let mAfter1 := mload(dataEnd)\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n            // The `creationSize` is `extraLength + 63`\n            // The `runSize` is `creationSize - 10`.\n\n            // if `extraLength` is greater than `0xffca` revert as the `creationSize` would be greater than `0xffff`.\n            if gt(extraLength, 0xffca) {\n                // Store the function selector of `PackedDataTooBig()`.\n                mstore(0x00, 0xc8c78139)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            /**\n             * ---------------------------------------------------------------------------------------------------+\n             * CREATION (10 bytes)                                                                                |\n             * ---------------------------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                                                |\n             * ---------------------------------------------------------------------------------------------------|\n             * 61 runSize | PUSH2 runSize     | r         |                                                       |\n             * 3d         | RETURNDATASIZE    | 0 r       |                                                       |\n             * 81         | DUP2              | r 0 r     |                                                       |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                                                       |\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                                                       |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code                            |\n             * f3         | RETURN            |           | [0..runSize): runtime code                            |\n             * ---------------------------------------------------------------------------------------------------|\n             * RUNTIME (98 bytes + extraLength)                                                                   |\n             * ---------------------------------------------------------------------------------------------------|\n             * Opcode   | Mnemonic       | Stack                    | Memory                                      |\n             * ---------------------------------------------------------------------------------------------------|\n             *                                                                                                    |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds                      |                                             |\n             * 3d       | RETURNDATASIZE | 0 cds                    |                                             |\n             * 3d       | RETURNDATASIZE | 0 0 cds                  |                                             |\n             * 37       | CALLDATACOPY   |                          | [0..cds): calldata                          |\n             *                                                                                                    |\n             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d       | RETURNDATASIZE | 0                        | [0..cds): calldata                          |\n             * 3d       | RETURNDATASIZE | 0 0                      | [0..cds): calldata                          |\n             * 3d       | RETURNDATASIZE | 0 0 0                    | [0..cds): calldata                          |\n             * 3d       | RETURNDATASIZE | 0 0 0 0                  | [0..cds): calldata                          |\n             * 61 extra | PUSH2 extra    | e 0 0 0 0                | [0..cds): calldata                          |\n             *                                                                                                    |\n             * ::: copy extra data to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 80       | DUP1           | e e 0 0 0 0              | [0..cds): calldata                          |\n             * 60 0x35  | PUSH1 0x35     | 0x35 e e 0 0 0 0         | [0..cds): calldata                          |\n             * 36       | CALLDATASIZE   | cds 0x35 e e 0 0 0 0     | [0..cds): calldata                          |\n             * 39       | CODECOPY       | e 0 0 0 0                | [0..cds): calldata, [cds..cds+e): extraData |\n             *                                                                                                    |\n             * ::: delegate call to the implementation contract ::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\n             * 01       | ADD            | cds+e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\n             * 3d       | RETURNDATASIZE | 0 cds+e 0 0 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\n             * 73 addr  | PUSH20 addr    | addr 0 cds+e 0 0 0 0     | [0..cds): calldata, [cds..cds+e): extraData |\n             * 5a       | GAS            | gas addr 0 cds+e 0 0 0 0 | [0..cds): calldata, [cds..cds+e): extraData |\n             * f4       | DELEGATECALL   | success 0 0              | [0..cds): calldata, [cds..cds+e): extraData |\n             *                                                                                                    |\n             * ::: copy return data to memory ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d       | RETURNDATASIZE | rds success 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\n             * 3d       | RETURNDATASIZE | rds rds success 0 0      | [0..cds): calldata, [cds..cds+e): extraData |\n             * 93       | SWAP4          | 0 rds success 0 rds      | [0..cds): calldata, [cds..cds+e): extraData |\n             * 80       | DUP1           | 0 0 rds success 0 rds    | [0..cds): calldata, [cds..cds+e): extraData |\n             * 3e       | RETURNDATACOPY | success 0 rds            | [0..rds): returndata                        |\n             *                                                                                                    |\n             * 60 0x33  | PUSH1 0x33     | 0x33 success 0 rds       | [0..rds): returndata                        |\n             * 57       | JUMPI          | 0 rds                    | [0..rds): returndata                        |\n             *                                                                                                    |\n             * ::: revert ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * fd       | REVERT         |                          | [0..rds): returndata                        |\n             *                                                                                                    |\n             * ::: return ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b       | JUMPDEST       | 0 rds                    | [0..rds): returndata                        |\n             * f3       | RETURN         |                          | [0..rds): returndata                        |\n             * ---------------------------------------------------------------------------------------------------+\n             */\n            // Write the bytecode before the data.\n            mstore(data, 0x5af43d3d93803e603357fd5bf3)\n            // Write the address of the implementation.\n            mstore(sub(data, 0x0d), implementation)\n            mstore(\n                sub(data, 0x21),\n                or(\n                    shl(0xd8, add(extraLength, 0x35)),\n                    or(shl(0x48, extraLength), 0x6100003d81600a3d39f3363d3d373d3d3d3d610000806035363936013d73)\n                )\n            )\n            mstore(dataEnd, shl(0xf0, extraLength))\n\n            // Create the instance.\n            instance := create2(0, sub(data, 0x1f), add(extraLength, 0x3f), salt)\n\n            // If `instance` is zero, revert.\n            if iszero(instance) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Restore the overwritten memory surrounding `data`.\n            mstore(dataEnd, mAfter1)\n            mstore(data, dataLength)\n            mstore(sub(data, 0x20), mBefore1)\n            mstore(sub(data, 0x40), mBefore2)\n        }\n    }\n\n    /**\n     * @dev Returns the initialization code hash of the clone of `implementation`\n     * using immutable arguments encoded in `data`.\n     * Used for mining vanity addresses with create2crunch.\n     * @param implementation The address of the implementation contract.\n     * @param data The encoded immutable arguments.\n     * @return hash The initialization code hash.\n     */\n    function initCodeHash(address implementation, bytes memory data) internal pure returns (bytes32 hash) {\n        assembly {\n            // Compute the boundaries of the data and cache the memory slots around it.\n            let mBefore2 := mload(sub(data, 0x40))\n            let mBefore1 := mload(sub(data, 0x20))\n            let dataLength := mload(data)\n            let dataEnd := add(add(data, 0x20), dataLength)\n            let mAfter1 := mload(dataEnd)\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n            // The `creationSize` is `extraLength + 63`\n            // The `runSize` is `creationSize - 10`.\n\n            // if `extraLength` is greater than `0xffca` revert as the `creationSize` would be greater than `0xffff`.\n            if gt(extraLength, 0xffca) {\n                // Store the function selector of `PackedDataTooBig()`.\n                mstore(0x00, 0xc8c78139)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Write the bytecode before the data.\n            mstore(data, 0x5af43d3d93803e603357fd5bf3)\n            // Write the address of the implementation.\n            mstore(sub(data, 0x0d), implementation)\n            mstore(\n                sub(data, 0x21),\n                or(\n                    shl(0xd8, add(extraLength, 0x35)),\n                    or(shl(0x48, extraLength), 0x6100003d81600a3d39f3363d3d373d3d3d3d610000806035363936013d73)\n                )\n            )\n            mstore(dataEnd, shl(0xf0, extraLength))\n\n            // Create the instance.\n            hash := keccak256(sub(data, 0x1f), add(extraLength, 0x3f))\n\n            // Restore the overwritten memory surrounding `data`.\n            mstore(dataEnd, mAfter1)\n            mstore(data, dataLength)\n            mstore(sub(data, 0x20), mBefore1)\n            mstore(sub(data, 0x40), mBefore2)\n        }\n    }\n\n    /**\n     * @dev Returns the address of the deterministic clone of\n     * `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.\n     * @param implementation The address of the implementation.\n     * @param data The immutable arguments of the implementation.\n     * @param salt The salt used to compute the address.\n     * @param deployer The address of the deployer.\n     * @return predicted The predicted address.\n     */\n    function predictDeterministicAddress(address implementation, bytes memory data, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        bytes32 hash = initCodeHash(implementation, data);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /**\n     * @dev Returns the address when a contract with initialization code hash,\n     * `hash`, is deployed with `salt`, by `deployer`.\n     * @param hash The initialization code hash.\n     * @param salt The salt used to compute the address.\n     * @param deployer The address of the deployer.\n     * @return predicted The predicted address.\n     */\n    function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the boundaries of the data and cache the memory slots around it.\n            let mBefore := mload(0x35)\n\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x35, mBefore)\n        }\n    }\n}\n"
    },
    "contracts/joe-v2/src/libraries/JoeLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\n/**\n * @title Liquidity Book Joe Library Helper Library\n * @author Trader Joe\n * @notice Helper contract used for Joe V1 related calculations\n */\nlibrary JoeLibrary {\n    error JoeLibrary__AddressZero();\n    error JoeLibrary__IdenticalAddresses();\n    error JoeLibrary__InsufficientAmount();\n    error JoeLibrary__InsufficientLiquidity();\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        if (tokenA == tokenB) revert JoeLibrary__IdenticalAddresses();\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        if (token0 == address(0)) revert JoeLibrary__AddressZero();\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) internal pure returns (uint256 amountB) {\n        if (amountA == 0) revert JoeLibrary__InsufficientAmount();\n        if (reserveA == 0 || reserveB == 0) revert JoeLibrary__InsufficientLiquidity();\n        amountB = (amountA * reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (amountIn == 0) revert JoeLibrary__InsufficientAmount();\n        if (reserveIn == 0 || reserveOut == 0) revert JoeLibrary__InsufficientLiquidity();\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (amountOut == 0) revert JoeLibrary__InsufficientAmount();\n        if (reserveIn == 0 || reserveOut == 0) revert JoeLibrary__InsufficientLiquidity();\n        uint256 numerator = reserveIn * amountOut * 1000;\n        uint256 denominator = (reserveOut - amountOut) * 997;\n        amountIn = numerator / denominator + 1;\n    }\n}\n"
    },
    "contracts/joe-v2/src/libraries/math/BitMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @title Liquidity Book Bit Math Library\n * @author Trader Joe\n * @notice Helper contract used for bit calculations\n */\nlibrary BitMath {\n    /**\n     * @dev Returns the index of the closest bit on the right of x that is non null\n     * @param x The value as a uint256\n     * @param bit The index of the bit to start searching at\n     * @return id The index of the closest non null bit on the right of x.\n     * If there is no closest bit, it returns max(uint256)\n     */\n    function closestBitRight(uint256 x, uint8 bit) internal pure returns (uint256 id) {\n        unchecked {\n            uint256 shift = 255 - bit;\n            x <<= shift;\n\n            // can't overflow as it's non-zero and we shifted it by `_shift`\n            return (x == 0) ? type(uint256).max : mostSignificantBit(x) - shift;\n        }\n    }\n\n    /**\n     * @dev Returns the index of the closest bit on the left of x that is non null\n     * @param x The value as a uint256\n     * @param bit The index of the bit to start searching at\n     * @return id The index of the closest non null bit on the left of x.\n     * If there is no closest bit, it returns max(uint256)\n     */\n    function closestBitLeft(uint256 x, uint8 bit) internal pure returns (uint256 id) {\n        unchecked {\n            x >>= bit;\n\n            return (x == 0) ? type(uint256).max : leastSignificantBit(x) + bit;\n        }\n    }\n\n    /**\n     * @dev Returns the index of the most significant bit of x\n     * This function returns 0 if x is 0\n     * @param x The value as a uint256\n     * @return msb The index of the most significant bit of x\n     */\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 msb) {\n        assembly {\n            if gt(x, 0xffffffffffffffffffffffffffffffff) {\n                x := shr(128, x)\n                msb := 128\n            }\n            if gt(x, 0xffffffffffffffff) {\n                x := shr(64, x)\n                msb := add(msb, 64)\n            }\n            if gt(x, 0xffffffff) {\n                x := shr(32, x)\n                msb := add(msb, 32)\n            }\n            if gt(x, 0xffff) {\n                x := shr(16, x)\n                msb := add(msb, 16)\n            }\n            if gt(x, 0xff) {\n                x := shr(8, x)\n                msb := add(msb, 8)\n            }\n            if gt(x, 0xf) {\n                x := shr(4, x)\n                msb := add(msb, 4)\n            }\n            if gt(x, 0x3) {\n                x := shr(2, x)\n                msb := add(msb, 2)\n            }\n            if gt(x, 0x1) { msb := add(msb, 1) }\n        }\n    }\n\n    /**\n     * @dev Returns the index of the least significant bit of x\n     * This function returns 255 if x is 0\n     * @param x The value as a uint256\n     * @return lsb The index of the least significant bit of x\n     */\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 lsb) {\n        assembly {\n            let sx := shl(128, x)\n            if iszero(iszero(sx)) {\n                lsb := 128\n                x := sx\n            }\n            sx := shl(64, x)\n            if iszero(iszero(sx)) {\n                x := sx\n                lsb := add(lsb, 64)\n            }\n            sx := shl(32, x)\n            if iszero(iszero(sx)) {\n                x := sx\n                lsb := add(lsb, 32)\n            }\n            sx := shl(16, x)\n            if iszero(iszero(sx)) {\n                x := sx\n                lsb := add(lsb, 16)\n            }\n            sx := shl(8, x)\n            if iszero(iszero(sx)) {\n                x := sx\n                lsb := add(lsb, 8)\n            }\n            sx := shl(4, x)\n            if iszero(iszero(sx)) {\n                x := sx\n                lsb := add(lsb, 4)\n            }\n            sx := shl(2, x)\n            if iszero(iszero(sx)) {\n                x := sx\n                lsb := add(lsb, 2)\n            }\n            if iszero(iszero(shl(1, x))) { lsb := add(lsb, 1) }\n\n            lsb := sub(255, lsb)\n        }\n    }\n}\n"
    },
    "contracts/joe-v2/src/libraries/math/Encoded.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @title Liquidity Book Encoded Library\n * @author Trader Joe\n * @notice Helper contract used for decoding bytes32 sample\n */\nlibrary Encoded {\n    uint256 internal constant MASK_UINT1 = 0x1;\n    uint256 internal constant MASK_UINT8 = 0xff;\n    uint256 internal constant MASK_UINT12 = 0xfff;\n    uint256 internal constant MASK_UINT14 = 0x3fff;\n    uint256 internal constant MASK_UINT16 = 0xffff;\n    uint256 internal constant MASK_UINT20 = 0xfffff;\n    uint256 internal constant MASK_UINT24 = 0xffffff;\n    uint256 internal constant MASK_UINT40 = 0xffffffffff;\n    uint256 internal constant MASK_UINT64 = 0xffffffffffffffff;\n    uint256 internal constant MASK_UINT128 = 0xffffffffffffffffffffffffffffffff;\n\n    /**\n     * @notice Internal function to set a value in an encoded bytes32 using a mask and offset\n     * @dev This function can overflow\n     * @param encoded The previous encoded value\n     * @param value The value to encode\n     * @param mask The mask\n     * @param offset The offset\n     * @return newEncoded The new encoded value\n     */\n    function set(bytes32 encoded, uint256 value, uint256 mask, uint256 offset)\n        internal\n        pure\n        returns (bytes32 newEncoded)\n    {\n        assembly {\n            newEncoded := and(encoded, not(shl(offset, mask)))\n            newEncoded := or(newEncoded, shl(offset, and(value, mask)))\n        }\n    }\n\n    /**\n     * @notice Internal function to set a bool in an encoded bytes32 using an offset\n     * @dev This function can overflow\n     * @param encoded The previous encoded value\n     * @param boolean The bool to encode\n     * @param offset The offset\n     * @return newEncoded The new encoded value\n     */\n    function setBool(bytes32 encoded, bool boolean, uint256 offset) internal pure returns (bytes32 newEncoded) {\n        return set(encoded, boolean ? 1 : 0, MASK_UINT1, offset);\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample using a mask and offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param mask The mask\n     * @param offset The offset\n     * @return value The decoded value\n     */\n    function decode(bytes32 encoded, uint256 mask, uint256 offset) internal pure returns (uint256 value) {\n        assembly {\n            value := and(shr(offset, encoded), mask)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a bool using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return boolean The decoded value as a bool\n     */\n    function decodeBool(bytes32 encoded, uint256 offset) internal pure returns (bool boolean) {\n        assembly {\n            boolean := and(shr(offset, encoded), MASK_UINT1)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint8 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value\n     */\n    function decodeUint8(bytes32 encoded, uint256 offset) internal pure returns (uint8 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT8)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint12 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value as a uint16, since uint12 is not supported\n     */\n    function decodeUint12(bytes32 encoded, uint256 offset) internal pure returns (uint16 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT12)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint14 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value as a uint16, since uint14 is not supported\n     */\n    function decodeUint14(bytes32 encoded, uint256 offset) internal pure returns (uint16 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT14)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint16 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value\n     */\n    function decodeUint16(bytes32 encoded, uint256 offset) internal pure returns (uint16 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT16)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint20 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value as a uint24, since uint20 is not supported\n     */\n    function decodeUint20(bytes32 encoded, uint256 offset) internal pure returns (uint24 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT20)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint24 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value\n     */\n    function decodeUint24(bytes32 encoded, uint256 offset) internal pure returns (uint24 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT24)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint40 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value\n     */\n    function decodeUint40(bytes32 encoded, uint256 offset) internal pure returns (uint40 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT40)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint64 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value\n     */\n    function decodeUint64(bytes32 encoded, uint256 offset) internal pure returns (uint64 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT64)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint128 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value\n     */\n    function decodeUint128(bytes32 encoded, uint256 offset) internal pure returns (uint128 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT128)\n        }\n    }\n}\n"
    },
    "contracts/joe-v2/src/libraries/math/LiquidityConfigurations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {PackedUint128Math} from \"./PackedUint128Math.sol\";\nimport {Encoded} from \"./Encoded.sol\";\n\n/**\n * @title Liquidity Book Liquidity Configurations Library\n * @author Trader Joe\n * @notice This library contains functions to encode and decode the config of a pool and interact with the encoded bytes32.\n */\nlibrary LiquidityConfigurations {\n    using PackedUint128Math for bytes32;\n    using PackedUint128Math for uint128;\n    using Encoded for bytes32;\n\n    error LiquidityConfigurations__InvalidConfig();\n\n    uint256 private constant OFFSET_ID = 0;\n    uint256 private constant OFFSET_DISTRIBUTION_Y = 24;\n    uint256 private constant OFFSET_DISTRIBUTION_X = 88;\n\n    uint256 private constant PRECISION = 1e18;\n\n    /**\n     * @dev Encode the distributionX, distributionY and id into a single bytes32\n     * @param distributionX The distribution of the first token\n     * @param distributionY The distribution of the second token\n     * @param id The id of the pool\n     * @return config The encoded config as follows:\n     * [0 - 24[: id\n     * [24 - 88[: distributionY\n     * [88 - 152[: distributionX\n     * [152 - 256[: empty\n     */\n    function encodeParams(uint64 distributionX, uint64 distributionY, uint24 id)\n        internal\n        pure\n        returns (bytes32 config)\n    {\n        config = config.set(distributionX, Encoded.MASK_UINT64, OFFSET_DISTRIBUTION_X);\n        config = config.set(distributionY, Encoded.MASK_UINT64, OFFSET_DISTRIBUTION_Y);\n        config = config.set(id, Encoded.MASK_UINT24, OFFSET_ID);\n    }\n\n    /**\n     * @dev Decode the distributionX, distributionY and id from a single bytes32\n     * @param config The encoded config as follows:\n     * [0 - 24[: id\n     * [24 - 88[: distributionY\n     * [88 - 152[: distributionX\n     * [152 - 256[: empty\n     * @return distributionX The distribution of the first token\n     * @return distributionY The distribution of the second token\n     * @return id The id of the bin to add the liquidity to\n     */\n    function decodeParams(bytes32 config)\n        internal\n        pure\n        returns (uint64 distributionX, uint64 distributionY, uint24 id)\n    {\n        distributionX = config.decodeUint64(OFFSET_DISTRIBUTION_X);\n        distributionY = config.decodeUint64(OFFSET_DISTRIBUTION_Y);\n        id = config.decodeUint24(OFFSET_ID);\n\n        if (uint256(config) > type(uint152).max || distributionX > PRECISION || distributionY > PRECISION) {\n            revert LiquidityConfigurations__InvalidConfig();\n        }\n    }\n\n    /**\n     * @dev Get the amounts and id from a config and amountsIn\n     * @param config The encoded config as follows:\n     * [0 - 24[: id\n     * [24 - 88[: distributionY\n     * [88 - 152[: distributionX\n     * [152 - 256[: empty\n     * @param amountsIn The amounts to distribute as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @return amounts The distributed amounts as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @return id The id of the bin to add the liquidity to\n     */\n    function getAmountsAndId(bytes32 config, bytes32 amountsIn) internal pure returns (bytes32, uint24) {\n        (uint64 distributionX, uint64 distributionY, uint24 id) = decodeParams(config);\n\n        (uint128 x1, uint128 x2) = amountsIn.decode();\n\n        assembly {\n            x1 := div(mul(x1, distributionX), PRECISION)\n            x2 := div(mul(x2, distributionY), PRECISION)\n        }\n\n        return (x1.encode(x2), id);\n    }\n}\n"
    },
    "contracts/joe-v2/src/libraries/math/PackedUint128Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {Constants} from \"../Constants.sol\";\n\n/**\n * @title Liquidity Book Packed Uint128 Math Library\n * @author Trader Joe\n * @notice This library contains functions to encode and decode two uint128 into a single bytes32\n * and interact with the encoded bytes32.\n */\nlibrary PackedUint128Math {\n    error PackedUint128Math__AddOverflow();\n    error PackedUint128Math__SubUnderflow();\n    error PackedUint128Math__MultiplierTooLarge();\n\n    uint256 private constant OFFSET = 128;\n    uint256 private constant MASK_128 = 0xffffffffffffffffffffffffffffffff;\n    uint256 private constant MASK_128_PLUS_ONE = MASK_128 + 1;\n\n    /**\n     * @dev Encodes two uint128 into a single bytes32\n     * @param x1 The first uint128\n     * @param x2 The second uint128\n     * @return z The encoded bytes32 as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     */\n    function encode(uint128 x1, uint128 x2) internal pure returns (bytes32 z) {\n        assembly {\n            z := or(and(x1, MASK_128), shl(OFFSET, x2))\n        }\n    }\n\n    /**\n     * @dev Encodes a uint128 into a single bytes32 as the first uint128\n     * @param x1 The uint128\n     * @return z The encoded bytes32 as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: empty\n     */\n    function encodeFirst(uint128 x1) internal pure returns (bytes32 z) {\n        assembly {\n            z := and(x1, MASK_128)\n        }\n    }\n\n    /**\n     * @dev Encodes a uint128 into a single bytes32 as the second uint128\n     * @param x2 The uint128\n     * @return z The encoded bytes32 as follows:\n     * [0 - 128[: empty\n     * [128 - 256[: x2\n     */\n    function encodeSecond(uint128 x2) internal pure returns (bytes32 z) {\n        assembly {\n            z := shl(OFFSET, x2)\n        }\n    }\n\n    /**\n     * @dev Encodes a uint128 into a single bytes32 as the first or second uint128\n     * @param x The uint128\n     * @param first Whether to encode as the first or second uint128\n     * @return z The encoded bytes32 as follows:\n     * if first:\n     * [0 - 128[: x\n     * [128 - 256[: empty\n     * else:\n     * [0 - 128[: empty\n     * [128 - 256[: x\n     */\n    function encode(uint128 x, bool first) internal pure returns (bytes32 z) {\n        return first ? encodeFirst(x) : encodeSecond(x);\n    }\n\n    /**\n     * @dev Decodes a bytes32 into two uint128\n     * @param z The encoded bytes32 as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @return x1 The first uint128\n     * @return x2 The second uint128\n     */\n    function decode(bytes32 z) internal pure returns (uint128 x1, uint128 x2) {\n        assembly {\n            x1 := and(z, MASK_128)\n            x2 := shr(OFFSET, z)\n        }\n    }\n\n    /**\n     * @dev Decodes a bytes32 into a uint128 as the first uint128\n     * @param z The encoded bytes32 as follows:\n     * [0 - 128[: x\n     * [128 - 256[: any\n     * @return x The first uint128\n     */\n    function decodeX(bytes32 z) internal pure returns (uint128 x) {\n        assembly {\n            x := and(z, MASK_128)\n        }\n    }\n\n    /**\n     * @dev Decodes a bytes32 into a uint128 as the second uint128\n     * @param z The encoded bytes32 as follows:\n     * [0 - 128[: any\n     * [128 - 256[: y\n     * @return y The second uint128\n     */\n    function decodeY(bytes32 z) internal pure returns (uint128 y) {\n        assembly {\n            y := shr(OFFSET, z)\n        }\n    }\n\n    /**\n     * @dev Decodes a bytes32 into a uint128 as the first or second uint128\n     * @param z The encoded bytes32 as follows:\n     * if first:\n     * [0 - 128[: x1\n     * [128 - 256[: empty\n     * else:\n     * [0 - 128[: empty\n     * [128 - 256[: x2\n     * @param first Whether to decode as the first or second uint128\n     * @return x The decoded uint128\n     */\n    function decode(bytes32 z, bool first) internal pure returns (uint128 x) {\n        return first ? decodeX(z) : decodeY(z);\n    }\n\n    /**\n     * @dev Adds two encoded bytes32, reverting on overflow on any of the uint128\n     * @param x The first bytes32 encoded as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @param y The second bytes32 encoded as follows:\n     * [0 - 128[: y1\n     * [128 - 256[: y2\n     * @return z The sum of x and y encoded as follows:\n     * [0 - 128[: x1 + y1\n     * [128 - 256[: x2 + y2\n     */\n    function add(bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        assembly {\n            z := add(x, y)\n        }\n\n        if (z < x || uint128(uint256(z)) < uint128(uint256(x))) {\n            revert PackedUint128Math__AddOverflow();\n        }\n    }\n\n    /**\n     * @dev Adds an encoded bytes32 and two uint128, reverting on overflow on any of the uint128\n     * @param x The bytes32 encoded as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @param y1 The first uint128\n     * @param y2 The second uint128\n     * @return z The sum of x and y encoded as follows:\n     * [0 - 128[: x1 + y1\n     * [128 - 256[: x2 + y2\n     */\n    function add(bytes32 x, uint128 y1, uint128 y2) internal pure returns (bytes32) {\n        return add(x, encode(y1, y2));\n    }\n\n    /**\n     * @dev Subtracts two encoded bytes32, reverting on underflow on any of the uint128\n     * @param x The first bytes32 encoded as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @param y The second bytes32 encoded as follows:\n     * [0 - 128[: y1\n     * [128 - 256[: y2\n     * @return z The difference of x and y encoded as follows:\n     * [0 - 128[: x1 - y1\n     * [128 - 256[: x2 - y2\n     */\n    function sub(bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        assembly {\n            z := sub(x, y)\n        }\n\n        if (z > x || uint128(uint256(z)) > uint128(uint256(x))) {\n            revert PackedUint128Math__SubUnderflow();\n        }\n    }\n\n    /**\n     * @dev Subtracts an encoded bytes32 and two uint128, reverting on underflow on any of the uint128\n     * @param x The bytes32 encoded as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @param y1 The first uint128\n     * @param y2 The second uint128\n     * @return z The difference of x and y encoded as follows:\n     * [0 - 128[: x1 - y1\n     * [128 - 256[: x2 - y2\n     */\n    function sub(bytes32 x, uint128 y1, uint128 y2) internal pure returns (bytes32) {\n        return sub(x, encode(y1, y2));\n    }\n\n    /**\n     * @dev Returns whether any of the uint128 of x is strictly greater than the corresponding uint128 of y\n     * @param x The first bytes32 encoded as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @param y The second bytes32 encoded as follows:\n     * [0 - 128[: y1\n     * [128 - 256[: y2\n     * @return x1 < y1 || x2 < y2\n     */\n    function lt(bytes32 x, bytes32 y) internal pure returns (bool) {\n        (uint128 x1, uint128 x2) = decode(x);\n        (uint128 y1, uint128 y2) = decode(y);\n\n        return x1 < y1 || x2 < y2;\n    }\n\n    /**\n     * @dev Returns whether any of the uint128 of x is strictly greater than the corresponding uint128 of y\n     * @param x The first bytes32 encoded as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @param y The second bytes32 encoded as follows:\n     * [0 - 128[: y1\n     * [128 - 256[: y2\n     * @return x1 < y1 || x2 < y2\n     */\n    function gt(bytes32 x, bytes32 y) internal pure returns (bool) {\n        (uint128 x1, uint128 x2) = decode(x);\n        (uint128 y1, uint128 y2) = decode(y);\n\n        return x1 > y1 || x2 > y2;\n    }\n\n    /**\n     * @dev Multiplies an encoded bytes32 by a uint128 then divides the result by 10_000, rounding down\n     * The result can't overflow as the multiplier needs to be smaller or equal to 10_000\n     * @param x The bytes32 encoded as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @param multiplier The uint128 to multiply by (must be smaller or equal to 10_000)\n     * @return z The product of x and multiplier encoded as follows:\n     * [0 - 128[: floor((x1 * multiplier) / 10_000)\n     * [128 - 256[: floor((x2 * multiplier) / 10_000)\n     */\n    function scalarMulDivBasisPointRoundDown(bytes32 x, uint128 multiplier) internal pure returns (bytes32 z) {\n        if (multiplier == 0) return 0;\n\n        uint256 BASIS_POINT_MAX = Constants.BASIS_POINT_MAX;\n        if (multiplier > BASIS_POINT_MAX) revert PackedUint128Math__MultiplierTooLarge();\n\n        (uint128 x1, uint128 x2) = decode(x);\n\n        assembly {\n            x1 := div(mul(x1, multiplier), BASIS_POINT_MAX)\n            x2 := div(mul(x2, multiplier), BASIS_POINT_MAX)\n        }\n\n        return encode(x1, x2);\n    }\n}\n"
    },
    "contracts/joe-v2/src/libraries/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @title Liquidity Book Safe Cast Library\n * @author Trader Joe\n * @notice This library contains functions to safely cast uint256 to different uint types.\n */\nlibrary SafeCast {\n    error SafeCast__Exceeds248Bits();\n    error SafeCast__Exceeds240Bits();\n    error SafeCast__Exceeds232Bits();\n    error SafeCast__Exceeds224Bits();\n    error SafeCast__Exceeds216Bits();\n    error SafeCast__Exceeds208Bits();\n    error SafeCast__Exceeds200Bits();\n    error SafeCast__Exceeds192Bits();\n    error SafeCast__Exceeds184Bits();\n    error SafeCast__Exceeds176Bits();\n    error SafeCast__Exceeds168Bits();\n    error SafeCast__Exceeds160Bits();\n    error SafeCast__Exceeds152Bits();\n    error SafeCast__Exceeds144Bits();\n    error SafeCast__Exceeds136Bits();\n    error SafeCast__Exceeds128Bits();\n    error SafeCast__Exceeds120Bits();\n    error SafeCast__Exceeds112Bits();\n    error SafeCast__Exceeds104Bits();\n    error SafeCast__Exceeds96Bits();\n    error SafeCast__Exceeds88Bits();\n    error SafeCast__Exceeds80Bits();\n    error SafeCast__Exceeds72Bits();\n    error SafeCast__Exceeds64Bits();\n    error SafeCast__Exceeds56Bits();\n    error SafeCast__Exceeds48Bits();\n    error SafeCast__Exceeds40Bits();\n    error SafeCast__Exceeds32Bits();\n    error SafeCast__Exceeds24Bits();\n    error SafeCast__Exceeds16Bits();\n    error SafeCast__Exceeds8Bits();\n\n    /**\n     * @dev Returns x on uint248 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint248\n     */\n    function safe248(uint256 x) internal pure returns (uint248 y) {\n        if ((y = uint248(x)) != x) revert SafeCast__Exceeds248Bits();\n    }\n\n    /**\n     * @dev Returns x on uint240 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint240\n     */\n    function safe240(uint256 x) internal pure returns (uint240 y) {\n        if ((y = uint240(x)) != x) revert SafeCast__Exceeds240Bits();\n    }\n\n    /**\n     * @dev Returns x on uint232 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint232\n     */\n    function safe232(uint256 x) internal pure returns (uint232 y) {\n        if ((y = uint232(x)) != x) revert SafeCast__Exceeds232Bits();\n    }\n\n    /**\n     * @dev Returns x on uint224 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint224\n     */\n    function safe224(uint256 x) internal pure returns (uint224 y) {\n        if ((y = uint224(x)) != x) revert SafeCast__Exceeds224Bits();\n    }\n\n    /**\n     * @dev Returns x on uint216 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint216\n     */\n    function safe216(uint256 x) internal pure returns (uint216 y) {\n        if ((y = uint216(x)) != x) revert SafeCast__Exceeds216Bits();\n    }\n\n    /**\n     * @dev Returns x on uint208 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint208\n     */\n    function safe208(uint256 x) internal pure returns (uint208 y) {\n        if ((y = uint208(x)) != x) revert SafeCast__Exceeds208Bits();\n    }\n\n    /**\n     * @dev Returns x on uint200 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint200\n     */\n    function safe200(uint256 x) internal pure returns (uint200 y) {\n        if ((y = uint200(x)) != x) revert SafeCast__Exceeds200Bits();\n    }\n\n    /**\n     * @dev Returns x on uint192 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint192\n     */\n    function safe192(uint256 x) internal pure returns (uint192 y) {\n        if ((y = uint192(x)) != x) revert SafeCast__Exceeds192Bits();\n    }\n\n    /**\n     * @dev Returns x on uint184 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint184\n     */\n    function safe184(uint256 x) internal pure returns (uint184 y) {\n        if ((y = uint184(x)) != x) revert SafeCast__Exceeds184Bits();\n    }\n\n    /**\n     * @dev Returns x on uint176 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint176\n     */\n    function safe176(uint256 x) internal pure returns (uint176 y) {\n        if ((y = uint176(x)) != x) revert SafeCast__Exceeds176Bits();\n    }\n\n    /**\n     * @dev Returns x on uint168 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint168\n     */\n    function safe168(uint256 x) internal pure returns (uint168 y) {\n        if ((y = uint168(x)) != x) revert SafeCast__Exceeds168Bits();\n    }\n\n    /**\n     * @dev Returns x on uint160 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint160\n     */\n    function safe160(uint256 x) internal pure returns (uint160 y) {\n        if ((y = uint160(x)) != x) revert SafeCast__Exceeds160Bits();\n    }\n\n    /**\n     * @dev Returns x on uint152 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint152\n     */\n    function safe152(uint256 x) internal pure returns (uint152 y) {\n        if ((y = uint152(x)) != x) revert SafeCast__Exceeds152Bits();\n    }\n\n    /**\n     * @dev Returns x on uint144 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint144\n     */\n    function safe144(uint256 x) internal pure returns (uint144 y) {\n        if ((y = uint144(x)) != x) revert SafeCast__Exceeds144Bits();\n    }\n\n    /**\n     * @dev Returns x on uint136 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint136\n     */\n    function safe136(uint256 x) internal pure returns (uint136 y) {\n        if ((y = uint136(x)) != x) revert SafeCast__Exceeds136Bits();\n    }\n\n    /**\n     * @dev Returns x on uint128 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint128\n     */\n    function safe128(uint256 x) internal pure returns (uint128 y) {\n        if ((y = uint128(x)) != x) revert SafeCast__Exceeds128Bits();\n    }\n\n    /**\n     * @dev Returns x on uint120 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint120\n     */\n    function safe120(uint256 x) internal pure returns (uint120 y) {\n        if ((y = uint120(x)) != x) revert SafeCast__Exceeds120Bits();\n    }\n\n    /**\n     * @dev Returns x on uint112 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint112\n     */\n    function safe112(uint256 x) internal pure returns (uint112 y) {\n        if ((y = uint112(x)) != x) revert SafeCast__Exceeds112Bits();\n    }\n\n    /**\n     * @dev Returns x on uint104 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint104\n     */\n    function safe104(uint256 x) internal pure returns (uint104 y) {\n        if ((y = uint104(x)) != x) revert SafeCast__Exceeds104Bits();\n    }\n\n    /**\n     * @dev Returns x on uint96 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint96\n     */\n    function safe96(uint256 x) internal pure returns (uint96 y) {\n        if ((y = uint96(x)) != x) revert SafeCast__Exceeds96Bits();\n    }\n\n    /**\n     * @dev Returns x on uint88 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint88\n     */\n    function safe88(uint256 x) internal pure returns (uint88 y) {\n        if ((y = uint88(x)) != x) revert SafeCast__Exceeds88Bits();\n    }\n\n    /**\n     * @dev Returns x on uint80 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint80\n     */\n    function safe80(uint256 x) internal pure returns (uint80 y) {\n        if ((y = uint80(x)) != x) revert SafeCast__Exceeds80Bits();\n    }\n\n    /**\n     * @dev Returns x on uint72 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint72\n     */\n    function safe72(uint256 x) internal pure returns (uint72 y) {\n        if ((y = uint72(x)) != x) revert SafeCast__Exceeds72Bits();\n    }\n\n    /**\n     * @dev Returns x on uint64 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint64\n     */\n    function safe64(uint256 x) internal pure returns (uint64 y) {\n        if ((y = uint64(x)) != x) revert SafeCast__Exceeds64Bits();\n    }\n\n    /**\n     * @dev Returns x on uint56 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint56\n     */\n    function safe56(uint256 x) internal pure returns (uint56 y) {\n        if ((y = uint56(x)) != x) revert SafeCast__Exceeds56Bits();\n    }\n\n    /**\n     * @dev Returns x on uint48 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint48\n     */\n    function safe48(uint256 x) internal pure returns (uint48 y) {\n        if ((y = uint48(x)) != x) revert SafeCast__Exceeds48Bits();\n    }\n\n    /**\n     * @dev Returns x on uint40 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint40\n     */\n    function safe40(uint256 x) internal pure returns (uint40 y) {\n        if ((y = uint40(x)) != x) revert SafeCast__Exceeds40Bits();\n    }\n\n    /**\n     * @dev Returns x on uint32 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint32\n     */\n    function safe32(uint256 x) internal pure returns (uint32 y) {\n        if ((y = uint32(x)) != x) revert SafeCast__Exceeds32Bits();\n    }\n\n    /**\n     * @dev Returns x on uint24 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint24\n     */\n    function safe24(uint256 x) internal pure returns (uint24 y) {\n        if ((y = uint24(x)) != x) revert SafeCast__Exceeds24Bits();\n    }\n\n    /**\n     * @dev Returns x on uint16 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint16\n     */\n    function safe16(uint256 x) internal pure returns (uint16 y) {\n        if ((y = uint16(x)) != x) revert SafeCast__Exceeds16Bits();\n    }\n\n    /**\n     * @dev Returns x on uint8 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint8\n     */\n    function safe8(uint256 x) internal pure returns (uint8 y) {\n        if ((y = uint8(x)) != x) revert SafeCast__Exceeds8Bits();\n    }\n}\n"
    },
    "contracts/joe-v2/src/libraries/math/SampleMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {Encoded} from \"./Encoded.sol\";\n\n/**\n * @title Liquidity Book Sample Math Library\n * @author Trader Joe\n * @notice This library contains functions to encode and decode a sample into a single bytes32\n * and interact with the encoded bytes32\n * The sample is encoded as follows:\n * 0 - 16: oracle length (16 bits)\n * 16 - 80: cumulative id (64 bits)\n * 80 - 144: cumulative volatility accumulator (64 bits)\n * 144 - 208: cumulative bin crossed (64 bits)\n * 208 - 216: sample lifetime (8 bits)\n * 216 - 256: sample creation timestamp (40 bits)\n */\nlibrary SampleMath {\n    using Encoded for bytes32;\n\n    uint256 internal constant OFFSET_ORACLE_LENGTH = 0;\n    uint256 internal constant OFFSET_CUMULATIVE_ID = 16;\n    uint256 internal constant OFFSET_CUMULATIVE_VOLATILITY = 80;\n    uint256 internal constant OFFSET_CUMULATIVE_BIN_CROSSED = 144;\n    uint256 internal constant OFFSET_SAMPLE_LIFETIME = 208;\n    uint256 internal constant OFFSET_SAMPLE_CREATION = 216;\n\n    /**\n     * @dev Encodes a sample\n     * @param oracleLength The oracle length\n     * @param cumulativeId The cumulative id\n     * @param cumulativeVolatility The cumulative volatility\n     * @param cumulativeBinCrossed The cumulative bin crossed\n     * @param sampleLifetime The sample lifetime\n     * @param createdAt The sample creation timestamp\n     * @return sample The encoded sample\n     */\n    function encode(\n        uint16 oracleLength,\n        uint64 cumulativeId,\n        uint64 cumulativeVolatility,\n        uint64 cumulativeBinCrossed,\n        uint8 sampleLifetime,\n        uint40 createdAt\n    ) internal pure returns (bytes32 sample) {\n        sample = sample.set(oracleLength, Encoded.MASK_UINT16, OFFSET_ORACLE_LENGTH);\n        sample = sample.set(cumulativeId, Encoded.MASK_UINT64, OFFSET_CUMULATIVE_ID);\n        sample = sample.set(cumulativeVolatility, Encoded.MASK_UINT64, OFFSET_CUMULATIVE_VOLATILITY);\n        sample = sample.set(cumulativeBinCrossed, Encoded.MASK_UINT64, OFFSET_CUMULATIVE_BIN_CROSSED);\n        sample = sample.set(sampleLifetime, Encoded.MASK_UINT8, OFFSET_SAMPLE_LIFETIME);\n        sample = sample.set(createdAt, Encoded.MASK_UINT40, OFFSET_SAMPLE_CREATION);\n    }\n\n    /**\n     * @dev Gets the oracle length from an encoded sample\n     * @param sample The encoded sample as follows:\n     * [0 - 16[: oracle length (16 bits)\n     * [16 - 256[: any (240 bits)\n     * @return length The oracle length\n     */\n    function getOracleLength(bytes32 sample) internal pure returns (uint16 length) {\n        return sample.decodeUint16(0);\n    }\n\n    /**\n     * @dev Gets the cumulative id from an encoded sample\n     * @param sample The encoded sample as follows:\n     * [0 - 16[: any (16 bits)\n     * [16 - 80[: cumulative id (64 bits)\n     * [80 - 256[: any (176 bits)\n     * @return id The cumulative id\n     */\n    function getCumulativeId(bytes32 sample) internal pure returns (uint64 id) {\n        return sample.decodeUint64(OFFSET_CUMULATIVE_ID);\n    }\n\n    /**\n     * @dev Gets the cumulative volatility accumulator from an encoded sample\n     * @param sample The encoded sample as follows:\n     * [0 - 80[: any (80 bits)\n     * [80 - 144[: cumulative volatility accumulator (64 bits)\n     * [144 - 256[: any (112 bits)\n     * @return volatilityAccumulator The cumulative volatility\n     */\n    function getCumulativeVolatility(bytes32 sample) internal pure returns (uint64 volatilityAccumulator) {\n        return sample.decodeUint64(OFFSET_CUMULATIVE_VOLATILITY);\n    }\n\n    /**\n     * @dev Gets the cumulative bin crossed from an encoded sample\n     * @param sample The encoded sample as follows:\n     * [0 - 144[: any (144 bits)\n     * [144 - 208[: cumulative bin crossed (64 bits)\n     * [208 - 256[: any (48 bits)\n     * @return binCrossed The cumulative bin crossed\n     */\n    function getCumulativeBinCrossed(bytes32 sample) internal pure returns (uint64 binCrossed) {\n        return sample.decodeUint64(OFFSET_CUMULATIVE_BIN_CROSSED);\n    }\n\n    /**\n     * @dev Gets the sample lifetime from an encoded sample\n     * @param sample The encoded sample as follows:\n     * [0 - 208[: any (208 bits)\n     * [208 - 216[: sample lifetime (8 bits)\n     * [216 - 256[: any (40 bits)\n     * @return lifetime The sample lifetime\n     */\n    function getSampleLifetime(bytes32 sample) internal pure returns (uint8 lifetime) {\n        return sample.decodeUint8(OFFSET_SAMPLE_LIFETIME);\n    }\n\n    /**\n     * @dev Gets the sample creation timestamp from an encoded sample\n     * @param sample The encoded sample as follows:\n     * [0 - 216[: any (216 bits)\n     * [216 - 256[: sample creation timestamp (40 bits)\n     * @return creation The sample creation timestamp\n     */\n    function getSampleCreation(bytes32 sample) internal pure returns (uint40 creation) {\n        return sample.decodeUint40(OFFSET_SAMPLE_CREATION);\n    }\n\n    /**\n     * @dev Gets the sample last update timestamp from an encoded sample\n     * @param sample The encoded sample as follows:\n     * [0 - 216[: any (216 bits)\n     * [216 - 256[: sample creation timestamp (40 bits)\n     * @return lastUpdate The sample last update timestamp\n     */\n    function getSampleLastUpdate(bytes32 sample) internal pure returns (uint40 lastUpdate) {\n        lastUpdate = getSampleCreation(sample) + getSampleLifetime(sample);\n    }\n\n    /**\n     * @dev Gets the weighted average of two samples and their respective weights\n     * @param sample1 The first encoded sample\n     * @param sample2 The second encoded sample\n     * @param weight1 The weight of the first sample\n     * @param weight2 The weight of the second sample\n     * @return weightedAverageId The weighted average id\n     * @return weightedAverageVolatility The weighted average volatility\n     * @return weightedAverageBinCrossed The weighted average bin crossed\n     */\n    function getWeightedAverage(bytes32 sample1, bytes32 sample2, uint40 weight1, uint40 weight2)\n        internal\n        pure\n        returns (uint64 weightedAverageId, uint64 weightedAverageVolatility, uint64 weightedAverageBinCrossed)\n    {\n        uint256 cId1 = getCumulativeId(sample1);\n        uint256 cVolatility1 = getCumulativeVolatility(sample1);\n        uint256 cBinCrossed1 = getCumulativeBinCrossed(sample1);\n\n        if (weight2 == 0) return (uint64(cId1), uint64(cVolatility1), uint64(cBinCrossed1));\n\n        uint256 cId2 = getCumulativeId(sample2);\n        uint256 cVolatility2 = getCumulativeVolatility(sample2);\n        uint256 cBinCrossed2 = getCumulativeBinCrossed(sample2);\n\n        if (weight1 == 0) return (uint64(cId2), uint64(cVolatility2), uint64(cBinCrossed2));\n\n        uint256 totalWeight = uint256(weight1) + weight2;\n\n        unchecked {\n            weightedAverageId = uint64((cId1 * weight1 + cId2 * weight2) / totalWeight);\n            weightedAverageVolatility = uint64((cVolatility1 * weight1 + cVolatility2 * weight2) / totalWeight);\n            weightedAverageBinCrossed = uint64((cBinCrossed1 * weight1 + cBinCrossed2 * weight2) / totalWeight);\n        }\n    }\n\n    /**\n     * @dev Updates a sample with the given values\n     * @param sample The encoded sample\n     * @param deltaTime The time elapsed since the last update\n     * @param activeId The active id\n     * @param volatilityAccumulator The volatility accumulator\n     * @param binCrossed The bin crossed\n     * @return cumulativeId The cumulative id\n     * @return cumulativeVolatility The cumulative volatility\n     * @return cumulativeBinCrossed The cumulative bin crossed\n     */\n    function update(bytes32 sample, uint40 deltaTime, uint24 activeId, uint24 volatilityAccumulator, uint24 binCrossed)\n        internal\n        pure\n        returns (uint64 cumulativeId, uint64 cumulativeVolatility, uint64 cumulativeBinCrossed)\n    {\n        unchecked {\n            cumulativeId = uint64(activeId) * deltaTime;\n            cumulativeVolatility = uint64(volatilityAccumulator) * deltaTime;\n            cumulativeBinCrossed = uint64(binCrossed) * deltaTime;\n        }\n\n        cumulativeId += getCumulativeId(sample);\n        cumulativeVolatility += getCumulativeVolatility(sample);\n        cumulativeBinCrossed += getCumulativeBinCrossed(sample);\n    }\n}\n"
    },
    "contracts/joe-v2/src/libraries/math/TreeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {BitMath} from \"./BitMath.sol\";\n\n/**\n * @title Liquidity Book Tree Math Library\n * @author Trader Joe\n * @notice This library contains functions to interact with a tree of TreeUint24.\n */\nlibrary TreeMath {\n    using BitMath for uint256;\n\n    struct TreeUint24 {\n        bytes32 level0;\n        mapping(bytes32 => bytes32) level1;\n        mapping(bytes32 => bytes32) level2;\n    }\n\n    /**\n     * @dev Returns true if the tree contains the id\n     * @param tree The tree\n     * @param id The id\n     * @return True if the tree contains the id\n     */\n    function contains(TreeUint24 storage tree, uint24 id) internal view returns (bool) {\n        bytes32 leaf2 = bytes32(uint256(id) >> 8);\n\n        return tree.level2[leaf2] & bytes32(1 << (id & type(uint8).max)) != 0;\n    }\n\n    /**\n     * @dev Adds the id to the tree and returns true if the id was not already in the tree\n     * It will also propagate the change to the parent levels.\n     * @param tree The tree\n     * @param id The id\n     * @return True if the id was not already in the tree\n     */\n    function add(TreeUint24 storage tree, uint24 id) internal returns (bool) {\n        bytes32 key2 = bytes32(uint256(id) >> 8);\n\n        bytes32 leaves = tree.level2[key2];\n        bytes32 newLeaves = leaves | bytes32(1 << (id & type(uint8).max));\n\n        if (leaves != newLeaves) {\n            tree.level2[key2] = newLeaves;\n\n            if (leaves == 0) {\n                bytes32 key1 = key2 >> 8;\n                leaves = tree.level1[key1];\n\n                tree.level1[key1] = leaves | bytes32(1 << (uint256(key2) & type(uint8).max));\n\n                if (leaves == 0) tree.level0 |= bytes32(1 << (uint256(key1) & type(uint8).max));\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @dev Removes the id from the tree and returns true if the id was in the tree.\n     * It will also propagate the change to the parent levels.\n     * @param tree The tree\n     * @param id The id\n     * @return True if the id was in the tree\n     */\n    function remove(TreeUint24 storage tree, uint24 id) internal returns (bool) {\n        bytes32 key2 = bytes32(uint256(id) >> 8);\n\n        bytes32 leaves = tree.level2[key2];\n        bytes32 newLeaves = leaves & ~bytes32(1 << (id & type(uint8).max));\n\n        if (leaves != newLeaves) {\n            tree.level2[key2] = newLeaves;\n\n            if (newLeaves == 0) {\n                bytes32 key1 = key2 >> 8;\n                newLeaves = tree.level1[key1] & ~bytes32(1 << (uint256(key2) & type(uint8).max));\n\n                tree.level1[key1] = newLeaves;\n\n                if (newLeaves == 0) tree.level0 &= ~bytes32(1 << (uint256(key1) & type(uint8).max));\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @dev Returns the first id in the tree that is lower than or equal to the given id.\n     * It will return type(uint24).max if there is no such id.\n     * @param tree The tree\n     * @param id The id\n     * @return The first id in the tree that is lower than the given id\n     */\n    function findFirstRight(TreeUint24 storage tree, uint24 id) internal view returns (uint24) {\n        bytes32 leaves;\n\n        bytes32 key2 = bytes32(uint256(id) >> 8);\n        uint8 bit = uint8(id & type(uint8).max);\n\n        if (bit != 0) {\n            leaves = tree.level2[key2];\n            uint256 closestBit = _closestBitRight(leaves, bit);\n\n            if (closestBit != type(uint256).max) return uint24(uint256(key2) << 8 | closestBit);\n        }\n\n        bytes32 key1 = key2 >> 8;\n        bit = uint8(uint256(key2) & type(uint8).max);\n\n        if (bit != 0) {\n            leaves = tree.level1[key1];\n            uint256 closestBit = _closestBitRight(leaves, bit);\n\n            if (closestBit != type(uint256).max) {\n                key2 = bytes32(uint256(key1) << 8 | closestBit);\n                leaves = tree.level2[key2];\n\n                return uint24(uint256(key2) << 8 | uint256(leaves).mostSignificantBit());\n            }\n        }\n\n        bit = uint8(uint256(key1) & type(uint8).max);\n\n        if (bit != 0) {\n            leaves = tree.level0;\n            uint256 closestBit = _closestBitRight(leaves, bit);\n\n            if (closestBit != type(uint256).max) {\n                key1 = bytes32(closestBit);\n                leaves = tree.level1[key1];\n\n                key2 = bytes32(uint256(key1) << 8 | uint256(leaves).mostSignificantBit());\n                leaves = tree.level2[key2];\n\n                return uint24(uint256(key2) << 8 | uint256(leaves).mostSignificantBit());\n            }\n        }\n\n        return type(uint24).max;\n    }\n\n    /**\n     * @dev Returns the first id in the tree that is higher than or equal to the given id.\n     * It will return 0 if there is no such id.\n     * @param tree The tree\n     * @param id The id\n     * @return The first id in the tree that is higher than the given id\n     */\n    function findFirstLeft(TreeUint24 storage tree, uint24 id) internal view returns (uint24) {\n        bytes32 leaves;\n\n        bytes32 key2 = bytes32(uint256(id) >> 8);\n        uint8 bit = uint8(id & type(uint8).max);\n\n        if (bit != type(uint8).max) {\n            leaves = tree.level2[key2];\n            uint256 closestBit = _closestBitLeft(leaves, bit);\n\n            if (closestBit != type(uint256).max) return uint24(uint256(key2) << 8 | closestBit);\n        }\n\n        bytes32 key1 = key2 >> 8;\n        bit = uint8(uint256(key2) & type(uint8).max);\n\n        if (bit != type(uint8).max) {\n            leaves = tree.level1[key1];\n            uint256 closestBit = _closestBitLeft(leaves, bit);\n\n            if (closestBit != type(uint256).max) {\n                key2 = bytes32(uint256(key1) << 8 | closestBit);\n                leaves = tree.level2[key2];\n\n                return uint24(uint256(key2) << 8 | uint256(leaves).leastSignificantBit());\n            }\n        }\n\n        bit = uint8(uint256(key1) & type(uint8).max);\n\n        if (bit != type(uint8).max) {\n            leaves = tree.level0;\n            uint256 closestBit = _closestBitLeft(leaves, bit);\n\n            if (closestBit != type(uint256).max) {\n                key1 = bytes32(closestBit);\n                leaves = tree.level1[key1];\n\n                key2 = bytes32(uint256(key1) << 8 | uint256(leaves).leastSignificantBit());\n                leaves = tree.level2[key2];\n\n                return uint24(uint256(key2) << 8 | uint256(leaves).leastSignificantBit());\n            }\n        }\n\n        return 0;\n    }\n\n    /**\n     * @dev Returns the first bit in the given leaves that is strictly lower than the given bit.\n     * It will return type(uint256).max if there is no such bit.\n     * @param leaves The leaves\n     * @param bit The bit\n     * @return The first bit in the given leaves that is strictly lower than the given bit\n     */\n    function _closestBitRight(bytes32 leaves, uint8 bit) private pure returns (uint256) {\n        unchecked {\n            return uint256(leaves).closestBitRight(bit - 1);\n        }\n    }\n\n    /**\n     * @dev Returns the first bit in the given leaves that is strictly higher than the given bit.\n     * It will return type(uint256).max if there is no such bit.\n     * @param leaves The leaves\n     * @param bit The bit\n     * @return The first bit in the given leaves that is strictly higher than the given bit\n     */\n    function _closestBitLeft(bytes32 leaves, uint8 bit) private pure returns (uint256) {\n        unchecked {\n            return uint256(leaves).closestBitLeft(bit + 1);\n        }\n    }\n}\n"
    },
    "contracts/joe-v2/src/libraries/math/Uint128x128Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {Constants} from \"../Constants.sol\";\nimport {BitMath} from \"./BitMath.sol\";\n\n/**\n * @title Liquidity Book Uint128x128 Math Library\n * @author Trader Joe\n * @notice Helper contract used for power and log calculations\n */\nlibrary Uint128x128Math {\n    using BitMath for uint256;\n\n    error Uint128x128Math__LogUnderflow();\n    error Uint128x128Math__PowUnderflow(uint256 x, int256 y);\n\n    uint256 constant LOG_SCALE_OFFSET = 127;\n    uint256 constant LOG_SCALE = 1 << LOG_SCALE_OFFSET;\n    uint256 constant LOG_SCALE_SQUARED = LOG_SCALE * LOG_SCALE;\n\n    /**\n     * @notice Calculates the binary logarithm of x.\n     * @dev Based on the iterative approximation algorithm.\n     * https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n     * Requirements:\n     * - x must be greater than zero.\n     * Caveats:\n     * - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation\n     * Also because x is converted to an unsigned 129.127-binary fixed-point number during the operation to optimize the multiplication\n     * @param x The unsigned 128.128-binary fixed-point number for which to calculate the binary logarithm.\n     * @return result The binary logarithm as a signed 128.128-binary fixed-point number.\n     */\n    function log2(uint256 x) internal pure returns (int256 result) {\n        // Convert x to a unsigned 129.127-binary fixed-point number to optimize the multiplication.\n        // If we use an offset of 128 bits, y would need 129 bits and y**2 would would overflow and we would have to\n        // use mulDiv, by reducing x to 129.127-binary fixed-point number we assert that y will use 128 bits, and we\n        // can use the regular multiplication\n\n        if (x == 1) return -128;\n        if (x == 0) revert Uint128x128Math__LogUnderflow();\n\n        x >>= 1;\n\n        unchecked {\n            // This works because log2(x) = -log2(1/x).\n            int256 sign;\n            if (x >= LOG_SCALE) {\n                sign = 1;\n            } else {\n                sign = -1;\n                // Do the fixed-point inversion inline to save gas\n                x = LOG_SCALE_SQUARED / x;\n            }\n\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\n            uint256 n = (x >> LOG_SCALE_OFFSET).mostSignificantBit();\n\n            // The integer part of the logarithm as a signed 129.127-binary fixed-point number. The operation can't overflow\n            // because n is maximum 255, LOG_SCALE_OFFSET is 127 bits and sign is either 1 or -1.\n            result = int256(n) << LOG_SCALE_OFFSET;\n\n            // This is y = x * 2^(-n).\n            uint256 y = x >> n;\n\n            // If y = 1, the fractional part is zero.\n            if (y != LOG_SCALE) {\n                // Calculate the fractional part via the iterative approximation.\n                // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\n                for (int256 delta = int256(1 << (LOG_SCALE_OFFSET - 1)); delta > 0; delta >>= 1) {\n                    y = (y * y) >> LOG_SCALE_OFFSET;\n\n                    // Is y^2 > 2 and so in the range [2,4)?\n                    if (y >= 1 << (LOG_SCALE_OFFSET + 1)) {\n                        // Add the 2^(-m) factor to the logarithm.\n                        result += delta;\n\n                        // Corresponds to z/2 on Wikipedia.\n                        y >>= 1;\n                    }\n                }\n            }\n            // Convert x back to unsigned 128.128-binary fixed-point number\n            result = (result * sign) << 1;\n        }\n    }\n\n    /**\n     * @notice Returns the value of x^y. It calculates `1 / x^abs(y)` if x is bigger than 2^128.\n     * At the end of the operations, we invert the result if needed.\n     * @param x The unsigned 128.128-binary fixed-point number for which to calculate the power\n     * @param y A relative number without any decimals, needs to be between ]-2^21; 2^21[\n     */\n    function pow(uint256 x, int256 y) internal pure returns (uint256 result) {\n        bool invert;\n        uint256 absY;\n\n        if (y == 0) return Constants.SCALE;\n\n        assembly {\n            absY := y\n            if slt(absY, 0) {\n                absY := sub(0, absY)\n                invert := iszero(invert)\n            }\n        }\n\n        if (absY < 0x100000) {\n            result = Constants.SCALE;\n            assembly {\n                let squared := x\n                if gt(x, 0xffffffffffffffffffffffffffffffff) {\n                    squared := div(not(0), squared)\n                    invert := iszero(invert)\n                }\n\n                if and(absY, 0x1) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x2) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x4) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x8) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x10) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x20) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x40) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x80) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x100) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x200) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x400) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x800) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x1000) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x2000) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x4000) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x8000) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x10000) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x20000) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x40000) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x80000) { result := shr(128, mul(result, squared)) }\n            }\n        }\n\n        // revert if y is too big or if x^y underflowed\n        if (result == 0) revert Uint128x128Math__PowUnderflow(x, y);\n\n        return invert ? type(uint256).max / result : result;\n    }\n}\n"
    },
    "contracts/joe-v2/src/libraries/math/Uint256x256Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {BitMath} from \"./BitMath.sol\";\n\n/**\n * @title Liquidity Book Uint256x256 Math Library\n * @author Trader Joe\n * @notice Helper contract used for full precision calculations\n */\nlibrary Uint256x256Math {\n    error Uint256x256Math__MulShiftOverflow();\n    error Uint256x256Math__MulDivOverflow();\n\n    /**\n     * @notice Calculates floor(x*y/denominator) with full precision\n     * The result will be rounded down\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The denominator cannot be zero\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @param denominator The divisor as an uint256\n     * @return result The result as an uint256\n     */\n    function mulDivRoundDown(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        (uint256 prod0, uint256 prod1) = _getMulProds(x, y);\n\n        return _getEndOfDivRoundDown(x, y, denominator, prod0, prod1);\n    }\n\n    /**\n     * @notice Calculates ceil(x*y/denominator) with full precision\n     * The result will be rounded up\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The denominator cannot be zero\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @param denominator The divisor as an uint256\n     * @return result The result as an uint256\n     */\n    function mulDivRoundUp(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        result = mulDivRoundDown(x, y, denominator);\n        if (mulmod(x, y, denominator) != 0) result += 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / 2**offset) with full precision\n     * The result will be rounded down\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The offset needs to be strictly lower than 256\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @param offset The offset as an uint256, can't be greater than 256\n     * @return result The result as an uint256\n     */\n    function mulShiftRoundDown(uint256 x, uint256 y, uint8 offset) internal pure returns (uint256 result) {\n        (uint256 prod0, uint256 prod1) = _getMulProds(x, y);\n\n        if (prod0 != 0) result = prod0 >> offset;\n        if (prod1 != 0) {\n            // Make sure the result is less than 2^256.\n            if (prod1 >= 1 << offset) revert Uint256x256Math__MulShiftOverflow();\n\n            unchecked {\n                result += prod1 << (256 - offset);\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates floor(x * y / 2**offset) with full precision\n     * The result will be rounded down\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The offset needs to be strictly lower than 256\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @param offset The offset as an uint256, can't be greater than 256\n     * @return result The result as an uint256\n     */\n    function mulShiftRoundUp(uint256 x, uint256 y, uint8 offset) internal pure returns (uint256 result) {\n        result = mulShiftRoundDown(x, y, offset);\n        if (mulmod(x, y, 1 << offset) != 0) result += 1;\n    }\n\n    /**\n     * @notice Calculates floor(x << offset / y) with full precision\n     * The result will be rounded down\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The offset needs to be strictly lower than 256\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param offset The number of bit to shift x as an uint256\n     * @param denominator The divisor as an uint256\n     * @return result The result as an uint256\n     */\n    function shiftDivRoundDown(uint256 x, uint8 offset, uint256 denominator) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n\n        prod0 = x << offset; // Least significant 256 bits of the product\n        unchecked {\n            prod1 = x >> (256 - offset); // Most significant 256 bits of the product\n        }\n\n        return _getEndOfDivRoundDown(x, 1 << offset, denominator, prod0, prod1);\n    }\n\n    /**\n     * @notice Calculates ceil(x << offset / y) with full precision\n     * The result will be rounded up\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The offset needs to be strictly lower than 256\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param offset The number of bit to shift x as an uint256\n     * @param denominator The divisor as an uint256\n     * @return result The result as an uint256\n     */\n    function shiftDivRoundUp(uint256 x, uint8 offset, uint256 denominator) internal pure returns (uint256 result) {\n        result = shiftDivRoundDown(x, offset, denominator);\n        if (mulmod(x, 1 << offset, denominator) != 0) result += 1;\n    }\n\n    /**\n     * @notice Helper function to return the result of `x * y` as 2 uint256\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @return prod0 The least significant 256 bits of the product\n     * @return prod1 The most significant 256 bits of the product\n     */\n    function _getMulProds(uint256 x, uint256 y) private pure returns (uint256 prod0, uint256 prod1) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n    }\n\n    /**\n     * @notice Helper function to return the result of `x * y / denominator` with full precision\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @param denominator The divisor as an uint256\n     * @param prod0 The least significant 256 bits of the product\n     * @param prod1 The most significant 256 bits of the product\n     * @return result The result as an uint256\n     */\n    function _getEndOfDivRoundDown(uint256 x, uint256 y, uint256 denominator, uint256 prod0, uint256 prod1)\n        private\n        pure\n        returns (uint256 result)\n    {\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n        } else {\n            // Make sure the result is less than 2^256. Also prevents denominator == 0\n            if (prod1 >= denominator) revert Uint256x256Math__MulDivOverflow();\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1\n            // See https://cs.stackexchange.com/q/138556/92363\n            unchecked {\n                // Does not overflow because the denominator cannot be zero at this stage in the function\n                uint256 lpotdod = denominator & (~denominator + 1);\n                assembly {\n                    // Divide denominator by lpotdod.\n                    denominator := div(denominator, lpotdod)\n\n                    // Divide [prod1 prod0] by lpotdod.\n                    prod0 := div(prod0, lpotdod)\n\n                    // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one\n                    lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n                }\n\n                // Shift in bits from prod1 into prod0\n                prod0 |= prod1 * lpotdod;\n\n                // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n                // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n                // four bits. That is, denominator * inv = 1 mod 2^4\n                uint256 inverse = (3 * denominator) ^ 2;\n\n                // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n                // in modular arithmetic, doubling the correct bits in each step\n                inverse *= 2 - denominator * inverse; // inverse mod 2^8\n                inverse *= 2 - denominator * inverse; // inverse mod 2^16\n                inverse *= 2 - denominator * inverse; // inverse mod 2^32\n                inverse *= 2 - denominator * inverse; // inverse mod 2^64\n                inverse *= 2 - denominator * inverse; // inverse mod 2^128\n                inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n                // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n                // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n                // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n                // is no longer required.\n                result = prod0 * inverse;\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates the square root of x\n     * @dev Credit to OpenZeppelin's Math library under MIT license\n     */\n    function sqrt(uint256 x) internal pure returns (uint256 sqrtX) {\n        if (x == 0) return 0;\n\n        uint256 msb = BitMath.mostSignificantBit(x);\n\n        assembly {\n            sqrtX := shl(shr(1, msb), 1)\n\n            sqrtX := shr(1, add(sqrtX, div(x, sqrtX)))\n            sqrtX := shr(1, add(sqrtX, div(x, sqrtX)))\n            sqrtX := shr(1, add(sqrtX, div(x, sqrtX)))\n            sqrtX := shr(1, add(sqrtX, div(x, sqrtX)))\n            sqrtX := shr(1, add(sqrtX, div(x, sqrtX)))\n            sqrtX := shr(1, add(sqrtX, div(x, sqrtX)))\n            sqrtX := shr(1, add(sqrtX, div(x, sqrtX)))\n\n            x := div(x, sqrtX)\n        }\n\n        return sqrtX < x ? sqrtX : x;\n    }\n}\n"
    },
    "contracts/joe-v2/src/libraries/OracleHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {SampleMath} from \"./math/SampleMath.sol\";\nimport {SafeCast} from \"./math/SafeCast.sol\";\nimport {PairParameterHelper} from \"./PairParameterHelper.sol\";\n\n/**\n * @title Liquidity Book Oracle Helper Library\n * @author Trader Joe\n * @notice This library contains functions to manage the oracle\n * The oracle samples are stored in a single bytes32 array.\n * Each sample is encoded as follows:\n * 0 - 16: oracle length (16 bits)\n * 16 - 80: cumulative id (64 bits)\n * 80 - 144: cumulative volatility accumulator (64 bits)\n * 144 - 208: cumulative bin crossed (64 bits)\n * 208 - 216: sample lifetime (8 bits)\n * 216 - 256: sample creation timestamp (40 bits)\n */\nlibrary OracleHelper {\n    using SampleMath for bytes32;\n    using SafeCast for uint256;\n    using PairParameterHelper for bytes32;\n\n    error OracleHelper__InvalidOracleId();\n    error OracleHelper__NewLengthTooSmall();\n    error OracleHelper__LookUpTimestampTooOld();\n\n    struct Oracle {\n        bytes32[65535] samples;\n    }\n\n    uint256 internal constant _MAX_SAMPLE_LIFETIME = 120 seconds;\n\n    /**\n     * @dev Modifier to check that the oracle id is valid\n     * @param oracleId The oracle id\n     */\n    modifier checkOracleId(uint16 oracleId) {\n        _checkOracleId(oracleId);\n        _;\n    }\n\n    /**\n     * @dev Returns the sample at the given oracleId\n     * @param oracle The oracle\n     * @param oracleId The oracle id\n     * @return sample The sample\n     */\n    function getSample(Oracle storage oracle, uint16 oracleId)\n        internal\n        view\n        checkOracleId(oracleId)\n        returns (bytes32 sample)\n    {\n        unchecked {\n            sample = oracle.samples[oracleId - 1];\n        }\n    }\n\n    /**\n     * @dev Returns the active sample and the active size of the oracle\n     * @param oracle The oracle\n     * @param oracleId The oracle id\n     * @return activeSample The active sample\n     * @return activeSize The active size of the oracle\n     */\n    function getActiveSampleAndSize(Oracle storage oracle, uint16 oracleId)\n        internal\n        view\n        returns (bytes32 activeSample, uint16 activeSize)\n    {\n        activeSample = getSample(oracle, oracleId);\n        activeSize = activeSample.getOracleLength();\n\n        if (oracleId != activeSize) {\n            activeSize = getSample(oracle, activeSize).getOracleLength();\n            activeSize = oracleId > activeSize ? oracleId : activeSize;\n        }\n    }\n\n    /**\n     * @dev Returns the sample at the given timestamp. If the timestamp is not in the oracle, it returns the closest sample\n     * @param oracle The oracle\n     * @param oracleId The oracle id\n     * @param lookUpTimestamp The timestamp to look up\n     * @return lastUpdate The last update timestamp\n     * @return cumulativeId The cumulative id\n     * @return cumulativeVolatility The cumulative volatility\n     * @return cumulativeBinCrossed The cumulative bin crossed\n     */\n    function getSampleAt(Oracle storage oracle, uint16 oracleId, uint40 lookUpTimestamp)\n        internal\n        view\n        returns (uint40 lastUpdate, uint64 cumulativeId, uint64 cumulativeVolatility, uint64 cumulativeBinCrossed)\n    {\n        (bytes32 activeSample, uint16 activeSize) = getActiveSampleAndSize(oracle, oracleId);\n\n        if (oracle.samples[oracleId % activeSize].getSampleLastUpdate() > lookUpTimestamp) {\n            revert OracleHelper__LookUpTimestampTooOld();\n        }\n\n        lastUpdate = activeSample.getSampleLastUpdate();\n        if (lastUpdate <= lookUpTimestamp) {\n            return (\n                lastUpdate,\n                activeSample.getCumulativeId(),\n                activeSample.getCumulativeVolatility(),\n                activeSample.getCumulativeBinCrossed()\n            );\n        } else {\n            lastUpdate = lookUpTimestamp;\n        }\n        (bytes32 prevSample, bytes32 nextSample) = binarySearch(oracle, oracleId, lookUpTimestamp, activeSize);\n        uint40 weightPrev = nextSample.getSampleLastUpdate() - lookUpTimestamp;\n        uint40 weightNext = lookUpTimestamp - prevSample.getSampleLastUpdate();\n\n        (cumulativeId, cumulativeVolatility, cumulativeBinCrossed) =\n            prevSample.getWeightedAverage(nextSample, weightPrev, weightNext);\n    }\n\n    /**\n     * @dev Binary search to find the 2 samples surrounding the given timestamp\n     * @param oracle The oracle\n     * @param oracleId The oracle id\n     * @param lookUpTimestamp The timestamp to look up\n     * @param length The oracle length\n     * @return prevSample The previous sample\n     * @return nextSample The next sample\n     */\n    function binarySearch(Oracle storage oracle, uint16 oracleId, uint40 lookUpTimestamp, uint16 length)\n        internal\n        view\n        returns (bytes32, bytes32)\n    {\n        uint256 low = 0;\n        uint256 high = length - 1;\n\n        bytes32 sample;\n        uint40 sampleLastUpdate;\n\n        uint256 startId = oracleId; // oracleId is 1-based\n        while (low <= high) {\n            uint256 mid = (low + high) >> 1;\n\n            assembly {\n                oracleId := addmod(startId, mid, length)\n            }\n\n            sample = oracle.samples[oracleId];\n            sampleLastUpdate = sample.getSampleLastUpdate();\n\n            if (sampleLastUpdate > lookUpTimestamp) {\n                high = mid - 1;\n            } else if (sampleLastUpdate < lookUpTimestamp) {\n                low = mid + 1;\n            } else {\n                return (sample, sample);\n            }\n        }\n\n        if (lookUpTimestamp < sampleLastUpdate) {\n            unchecked {\n                if (oracleId == 0) {\n                    oracleId = length;\n                }\n\n                return (oracle.samples[oracleId - 1], sample);\n            }\n        } else {\n            assembly {\n                oracleId := addmod(oracleId, 1, length)\n            }\n\n            return (sample, oracle.samples[oracleId]);\n        }\n    }\n\n    /**\n     * @dev Sets the sample at the given oracleId\n     * @param oracle The oracle\n     * @param oracleId The oracle id\n     * @param sample The sample\n     */\n    function setSample(Oracle storage oracle, uint16 oracleId, bytes32 sample) internal checkOracleId(oracleId) {\n        unchecked {\n            oracle.samples[oracleId - 1] = sample;\n        }\n    }\n\n    /**\n     * @dev Updates the oracle\n     * @param oracle The oracle\n     * @param parameters The parameters\n     * @param activeId The active id\n     * @return The updated parameters\n     */\n    function update(Oracle storage oracle, bytes32 parameters, uint24 activeId) internal returns (bytes32) {\n        uint16 oracleId = parameters.getOracleId();\n        if (oracleId == 0) return parameters;\n\n        bytes32 sample = getSample(oracle, oracleId);\n\n        uint40 createdAt = sample.getSampleCreation();\n        uint40 lastUpdatedAt = createdAt + sample.getSampleLifetime();\n\n        if (block.timestamp.safe40() > lastUpdatedAt) {\n            unchecked {\n                (uint64 cumulativeId, uint64 cumulativeVolatility, uint64 cumulativeBinCrossed) = sample.update(\n                    uint40(block.timestamp - lastUpdatedAt),\n                    parameters.getActiveId(),\n                    parameters.getVolatilityAccumulator(),\n                    parameters.getDeltaId(activeId)\n                );\n\n                uint16 length = sample.getOracleLength();\n                uint256 lifetime = block.timestamp - createdAt;\n\n                if (lifetime > _MAX_SAMPLE_LIFETIME) {\n                    assembly {\n                        oracleId := add(mod(oracleId, length), 1)\n                    }\n\n                    lifetime = 0;\n                    createdAt = uint40(block.timestamp);\n\n                    parameters = parameters.setOracleId(oracleId);\n                }\n\n                sample = SampleMath.encode(\n                    length, cumulativeId, cumulativeVolatility, cumulativeBinCrossed, uint8(lifetime), createdAt\n                );\n            }\n\n            setSample(oracle, oracleId, sample);\n        }\n\n        return parameters;\n    }\n\n    /**\n     * @dev Increases the oracle length\n     * @param oracle The oracle\n     * @param oracleId The oracle id\n     * @param newLength The new length\n     */\n    function increaseLength(Oracle storage oracle, uint16 oracleId, uint16 newLength) internal {\n        bytes32 sample = getSample(oracle, oracleId);\n        uint16 length = sample.getOracleLength();\n\n        if (length >= newLength) revert OracleHelper__NewLengthTooSmall();\n\n        bytes32 lastSample = length == oracleId ? sample : length == 0 ? bytes32(0) : getSample(oracle, length);\n\n        uint256 activeSize = lastSample.getOracleLength();\n        activeSize = oracleId > activeSize ? oracleId : activeSize;\n\n        for (uint256 i = length; i < newLength;) {\n            oracle.samples[i] = bytes32(uint256(activeSize));\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        setSample(oracle, oracleId, (sample ^ bytes32(uint256(length))) | bytes32(uint256(newLength)));\n    }\n\n    /**\n     * @dev Checks that the oracle id is valid\n     * @param oracleId The oracle id\n     */\n    function _checkOracleId(uint16 oracleId) private pure {\n        if (oracleId == 0) revert OracleHelper__InvalidOracleId();\n    }\n}\n"
    },
    "contracts/joe-v2/src/libraries/PairParameterHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {Constants} from \"./Constants.sol\";\nimport {SafeCast} from \"./math/SafeCast.sol\";\nimport {Encoded} from \"./math/Encoded.sol\";\n\n/**\n * @title Liquidity Book Pair Parameter Helper Library\n * @author Trader Joe\n * @dev This library contains functions to get and set parameters of a pair\n * The parameters are stored in a single bytes32 variable in the following format:\n * [0 - 16[: base factor (16 bits)\n * [16 - 28[: filter period (12 bits)\n * [28 - 40[: decay period (12 bits)\n * [40 - 54[: reduction factor (14 bits)\n * [54 - 78[: variable fee control (24 bits)\n * [78 - 92[: protocol share (14 bits)\n * [92 - 112[: max volatility accumulator (20 bits)\n * [112 - 132[: volatility accumulator (20 bits)\n * [132 - 152[: volatility reference (20 bits)\n * [152 - 176[: index reference (24 bits)\n * [176 - 216[: time of last update (40 bits)\n * [216 - 232[: oracle index (16 bits)\n * [232 - 256[: active index (24 bits)\n */\nlibrary PairParameterHelper {\n    using SafeCast for uint256;\n    using Encoded for bytes32;\n\n    error PairParametersHelper__InvalidParameter();\n\n    uint256 internal constant OFFSET_BASE_FACTOR = 0;\n    uint256 internal constant OFFSET_FILTER_PERIOD = 16;\n    uint256 internal constant OFFSET_DECAY_PERIOD = 28;\n    uint256 internal constant OFFSET_REDUCTION_FACTOR = 40;\n    uint256 internal constant OFFSET_VAR_FEE_CONTROL = 54;\n    uint256 internal constant OFFSET_PROTOCOL_SHARE = 78;\n    uint256 internal constant OFFSET_MAX_VOL_ACC = 92;\n    uint256 internal constant OFFSET_VOL_ACC = 112;\n    uint256 internal constant OFFSET_VOL_REF = 132;\n    uint256 internal constant OFFSET_ID_REF = 152;\n    uint256 internal constant OFFSET_TIME_LAST_UPDATE = 176;\n    uint256 internal constant OFFSET_ORACLE_ID = 216;\n    uint256 internal constant OFFSET_ACTIVE_ID = 232;\n\n    uint256 internal constant MASK_STATIC_PARAMETER = 0xffffffffffffffffffffffffffff;\n\n    /**\n     * @dev Get the base factor from the encoded pair parameters\n     * @param params The encoded pair parameters, as follows:\n     * [0 - 16[: base factor (16 bits)\n     * [16 - 256[: other parameters\n     * @return baseFactor The base factor\n     */\n    function getBaseFactor(bytes32 params) internal pure returns (uint16 baseFactor) {\n        baseFactor = params.decodeUint16(OFFSET_BASE_FACTOR);\n    }\n\n    /**\n     * @dev Get the filter period from the encoded pair parameters\n     * @param params The encoded pair parameters, as follows:\n     * [0 - 16[: other parameters\n     * [16 - 28[: filter period (12 bits)\n     * [28 - 256[: other parameters\n     * @return filterPeriod The filter period\n     */\n    function getFilterPeriod(bytes32 params) internal pure returns (uint16 filterPeriod) {\n        filterPeriod = params.decodeUint12(OFFSET_FILTER_PERIOD);\n    }\n\n    /**\n     * @dev Get the decay period from the encoded pair parameters\n     * @param params The encoded pair parameters, as follows:\n     * [0 - 28[: other parameters\n     * [28 - 40[: decay period (12 bits)\n     * [40 - 256[: other parameters\n     * @return decayPeriod The decay period\n     */\n    function getDecayPeriod(bytes32 params) internal pure returns (uint16 decayPeriod) {\n        decayPeriod = params.decodeUint12(OFFSET_DECAY_PERIOD);\n    }\n\n    /**\n     * @dev Get the reduction factor from the encoded pair parameters\n     * @param params The encoded pair parameters, as follows:\n     * [0 - 40[: other parameters\n     * [40 - 54[: reduction factor (14 bits)\n     * [54 - 256[: other parameters\n     * @return reductionFactor The reduction factor\n     */\n    function getReductionFactor(bytes32 params) internal pure returns (uint16 reductionFactor) {\n        reductionFactor = params.decodeUint14(OFFSET_REDUCTION_FACTOR);\n    }\n\n    /**\n     * @dev Get the variable fee control from the encoded pair parameters\n     * @param params The encoded pair parameters, as follows:\n     * [0 - 54[: other parameters\n     * [54 - 78[: variable fee control (24 bits)\n     * [78 - 256[: other parameters\n     * @return variableFeeControl The variable fee control\n     */\n    function getVariableFeeControl(bytes32 params) internal pure returns (uint24 variableFeeControl) {\n        variableFeeControl = params.decodeUint24(OFFSET_VAR_FEE_CONTROL);\n    }\n\n    /**\n     * @dev Get the protocol share from the encoded pair parameters\n     * @param params The encoded pair parameters, as follows:\n     * [0 - 78[: other parameters\n     * [78 - 92[: protocol share (14 bits)\n     * [92 - 256[: other parameters\n     * @return protocolShare The protocol share\n     */\n    function getProtocolShare(bytes32 params) internal pure returns (uint16 protocolShare) {\n        protocolShare = params.decodeUint14(OFFSET_PROTOCOL_SHARE);\n    }\n\n    /**\n     * @dev Get the max volatility accumulator from the encoded pair parameters\n     * @param params The encoded pair parameters, as follows:\n     * [0 - 92[: other parameters\n     * [92 - 112[: max volatility accumulator (20 bits)\n     * [112 - 256[: other parameters\n     * @return maxVolatilityAccumulator The max volatility accumulator\n     */\n    function getMaxVolatilityAccumulator(bytes32 params) internal pure returns (uint24 maxVolatilityAccumulator) {\n        maxVolatilityAccumulator = params.decodeUint20(OFFSET_MAX_VOL_ACC);\n    }\n\n    /**\n     * @dev Get the volatility accumulator from the encoded pair parameters\n     * @param params The encoded pair parameters, as follows:\n     * [0 - 112[: other parameters\n     * [112 - 132[: volatility accumulator (20 bits)\n     * [132 - 256[: other parameters\n     * @return volatilityAccumulator The volatility accumulator\n     */\n    function getVolatilityAccumulator(bytes32 params) internal pure returns (uint24 volatilityAccumulator) {\n        volatilityAccumulator = params.decodeUint20(OFFSET_VOL_ACC);\n    }\n\n    /**\n     * @dev Get the volatility reference from the encoded pair parameters\n     * @param params The encoded pair parameters, as follows:\n     * [0 - 132[: other parameters\n     * [132 - 152[: volatility reference (20 bits)\n     * [152 - 256[: other parameters\n     * @return volatilityReference The volatility reference\n     */\n    function getVolatilityReference(bytes32 params) internal pure returns (uint24 volatilityReference) {\n        volatilityReference = params.decodeUint20(OFFSET_VOL_REF);\n    }\n\n    /**\n     * @dev Get the index reference from the encoded pair parameters\n     * @param params The encoded pair parameters, as follows:\n     * [0 - 152[: other parameters\n     * [152 - 176[: index reference (24 bits)\n     * [176 - 256[: other parameters\n     * @return idReference The index reference\n     */\n    function getIdReference(bytes32 params) internal pure returns (uint24 idReference) {\n        idReference = params.decodeUint24(OFFSET_ID_REF);\n    }\n\n    /**\n     * @dev Get the time of last update from the encoded pair parameters\n     * @param params The encoded pair parameters, as follows:\n     * [0 - 176[: other parameters\n     * [176 - 216[: time of last update (40 bits)\n     * [216 - 256[: other parameters\n     * @return timeOflastUpdate The time of last update\n     */\n    function getTimeOfLastUpdate(bytes32 params) internal pure returns (uint40 timeOflastUpdate) {\n        timeOflastUpdate = params.decodeUint40(OFFSET_TIME_LAST_UPDATE);\n    }\n\n    /**\n     * @dev Get the oracle id from the encoded pair parameters\n     * @param params The encoded pair parameters, as follows:\n     * [0 - 216[: other parameters\n     * [216 - 232[: oracle id (16 bits)\n     * [232 - 256[: other parameters\n     * @return oracleId The oracle id\n     */\n    function getOracleId(bytes32 params) internal pure returns (uint16 oracleId) {\n        oracleId = params.decodeUint16(OFFSET_ORACLE_ID);\n    }\n\n    /**\n     * @dev Get the active index from the encoded pair parameters\n     * @param params The encoded pair parameters, as follows:\n     * [0 - 232[: other parameters\n     * [232 - 256[: active index (24 bits)\n     * @return activeId The active index\n     */\n    function getActiveId(bytes32 params) internal pure returns (uint24 activeId) {\n        activeId = params.decodeUint24(OFFSET_ACTIVE_ID);\n    }\n\n    /**\n     * @dev Get the delta between the current active index and the cached active index\n     * @param params The encoded pair parameters, as follows:\n     * [0 - 232[: other parameters\n     * [232 - 256[: active index (24 bits)\n     * @param activeId The current active index\n     * @return The delta\n     */\n    function getDeltaId(bytes32 params, uint24 activeId) internal pure returns (uint24) {\n        uint24 id = getActiveId(params);\n        unchecked {\n            return activeId > id ? activeId - id : id - activeId;\n        }\n    }\n\n    /**\n     * @dev Calculates the base fee, with 18 decimals\n     * @param params The encoded pair parameters\n     * @param binStep The bin step (in basis points)\n     * @return baseFee The base fee\n     */\n    function getBaseFee(bytes32 params, uint16 binStep) internal pure returns (uint256) {\n        unchecked {\n            // Base factor is in basis points, binStep is in basis points, so we multiply by 1e10\n            return uint256(getBaseFactor(params)) * binStep * 1e10;\n        }\n    }\n\n    /**\n     * @dev Calculates the variable fee\n     * @param params The encoded pair parameters\n     * @param binStep The bin step (in basis points)\n     * @return variableFee The variable fee\n     */\n    function getVariableFee(bytes32 params, uint16 binStep) internal pure returns (uint256 variableFee) {\n        uint256 variableFeeControl = getVariableFeeControl(params);\n\n        if (variableFeeControl != 0) {\n            unchecked {\n                // The volatility accumulator is in basis points, binStep is in basis points,\n                // and the variable fee control is in basis points, so the result is in 100e18th\n                uint256 prod = uint256(getVolatilityAccumulator(params)) * binStep;\n                variableFee = (prod * prod * variableFeeControl + 99) / 100;\n            }\n        }\n    }\n\n    /**\n     * @dev Calculates the total fee, which is the sum of the base fee and the variable fee\n     * @param params The encoded pair parameters\n     * @param binStep The bin step (in basis points)\n     * @return totalFee The total fee\n     */\n    function getTotalFee(bytes32 params, uint16 binStep) internal pure returns (uint128) {\n        unchecked {\n            return (getBaseFee(params, binStep) + getVariableFee(params, binStep)).safe128();\n        }\n    }\n\n    /**\n     * @dev Set the oracle id in the encoded pair parameters\n     * @param params The encoded pair parameters\n     * @param oracleId The oracle id\n     * @return The updated encoded pair parameters\n     */\n    function setOracleId(bytes32 params, uint16 oracleId) internal pure returns (bytes32) {\n        return params.set(oracleId, Encoded.MASK_UINT16, OFFSET_ORACLE_ID);\n    }\n\n    /**\n     * @dev Set the volatility reference in the encoded pair parameters\n     * @param params The encoded pair parameters\n     * @param volRef The volatility reference\n     * @return The updated encoded pair parameters\n     */\n    function setVolatilityReference(bytes32 params, uint24 volRef) internal pure returns (bytes32) {\n        if (volRef > Encoded.MASK_UINT20) revert PairParametersHelper__InvalidParameter();\n\n        return params.set(volRef, Encoded.MASK_UINT20, OFFSET_VOL_REF);\n    }\n\n    /**\n     * @dev Set the volatility accumulator in the encoded pair parameters\n     * @param params The encoded pair parameters\n     * @param volAcc The volatility accumulator\n     * @return The updated encoded pair parameters\n     */\n    function setVolatilityAccumulator(bytes32 params, uint24 volAcc) internal pure returns (bytes32) {\n        if (volAcc > Encoded.MASK_UINT20) revert PairParametersHelper__InvalidParameter();\n\n        return params.set(volAcc, Encoded.MASK_UINT20, OFFSET_VOL_ACC);\n    }\n\n    /**\n     * @dev Set the active id in the encoded pair parameters\n     * @param params The encoded pair parameters\n     * @param activeId The active id\n     * @return newParams The updated encoded pair parameters\n     */\n    function setActiveId(bytes32 params, uint24 activeId) internal pure returns (bytes32 newParams) {\n        return params.set(activeId, Encoded.MASK_UINT24, OFFSET_ACTIVE_ID);\n    }\n\n    /**\n     * @dev Sets the static fee parameters in the encoded pair parameters\n     * @param params The encoded pair parameters\n     * @param baseFactor The base factor\n     * @param filterPeriod The filter period\n     * @param decayPeriod The decay period\n     * @param reductionFactor The reduction factor\n     * @param variableFeeControl The variable fee control\n     * @param protocolShare The protocol share\n     * @param maxVolatilityAccumulator The max volatility accumulator\n     * @return newParams The updated encoded pair parameters\n     */\n    function setStaticFeeParameters(\n        bytes32 params,\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator\n    ) internal pure returns (bytes32 newParams) {\n        if (\n            filterPeriod > decayPeriod || decayPeriod > Encoded.MASK_UINT12\n                || reductionFactor > Constants.BASIS_POINT_MAX || protocolShare > Constants.MAX_PROTOCOL_SHARE\n                || maxVolatilityAccumulator > Encoded.MASK_UINT20\n        ) revert PairParametersHelper__InvalidParameter();\n\n        newParams = newParams.set(baseFactor, Encoded.MASK_UINT16, OFFSET_BASE_FACTOR);\n        newParams = newParams.set(filterPeriod, Encoded.MASK_UINT12, OFFSET_FILTER_PERIOD);\n        newParams = newParams.set(decayPeriod, Encoded.MASK_UINT12, OFFSET_DECAY_PERIOD);\n        newParams = newParams.set(reductionFactor, Encoded.MASK_UINT14, OFFSET_REDUCTION_FACTOR);\n        newParams = newParams.set(variableFeeControl, Encoded.MASK_UINT24, OFFSET_VAR_FEE_CONTROL);\n        newParams = newParams.set(protocolShare, Encoded.MASK_UINT14, OFFSET_PROTOCOL_SHARE);\n        newParams = newParams.set(maxVolatilityAccumulator, Encoded.MASK_UINT20, OFFSET_MAX_VOL_ACC);\n\n        return params.set(uint256(newParams), MASK_STATIC_PARAMETER, 0);\n    }\n\n    /**\n     * @dev Updates the index reference in the encoded pair parameters\n     * @param params The encoded pair parameters\n     * @return newParams The updated encoded pair parameters\n     */\n    function updateIdReference(bytes32 params) internal pure returns (bytes32 newParams) {\n        uint24 activeId = getActiveId(params);\n        return params.set(activeId, Encoded.MASK_UINT24, OFFSET_ID_REF);\n    }\n\n    /**\n     * @dev Updates the time of last update in the encoded pair parameters\n     * @param params The encoded pair parameters\n     * @param timestamp The timestamp\n     * @return newParams The updated encoded pair parameters\n     */\n    function updateTimeOfLastUpdate(bytes32 params, uint256 timestamp) internal pure returns (bytes32 newParams) {\n        uint40 currentTime = timestamp.safe40();\n        return params.set(currentTime, Encoded.MASK_UINT40, OFFSET_TIME_LAST_UPDATE);\n    }\n\n    /**\n     * @dev Updates the volatility reference in the encoded pair parameters\n     * @param params The encoded pair parameters\n     * @return The updated encoded pair parameters\n     */\n    function updateVolatilityReference(bytes32 params) internal pure returns (bytes32) {\n        uint256 volAcc = getVolatilityAccumulator(params);\n        uint256 reductionFactor = getReductionFactor(params);\n\n        uint24 volRef;\n        unchecked {\n            volRef = uint24(volAcc * reductionFactor / Constants.BASIS_POINT_MAX);\n        }\n\n        return setVolatilityReference(params, volRef);\n    }\n\n    /**\n     * @dev Updates the volatility accumulator in the encoded pair parameters\n     * @param params The encoded pair parameters\n     * @param activeId The active id\n     * @return The updated encoded pair parameters\n     */\n    function updateVolatilityAccumulator(bytes32 params, uint24 activeId) internal pure returns (bytes32) {\n        uint256 idReference = getIdReference(params);\n\n        uint256 deltaId;\n        uint256 volAcc;\n\n        unchecked {\n            deltaId = activeId > idReference ? activeId - idReference : idReference - activeId;\n            volAcc = (uint256(getVolatilityReference(params)) + deltaId * Constants.BASIS_POINT_MAX);\n        }\n\n        uint256 maxVolAcc = getMaxVolatilityAccumulator(params);\n\n        volAcc = volAcc > maxVolAcc ? maxVolAcc : volAcc;\n\n        return setVolatilityAccumulator(params, uint24(volAcc));\n    }\n\n    /**\n     * @dev Updates the volatility reference and the volatility accumulator in the encoded pair parameters\n     * @param params The encoded pair parameters\n     * @param timestamp The timestamp\n     * @return The updated encoded pair parameters\n     */\n    function updateReferences(bytes32 params, uint256 timestamp) internal pure returns (bytes32) {\n        uint256 dt = timestamp - getTimeOfLastUpdate(params);\n\n        if (dt >= getFilterPeriod(params)) {\n            params = updateIdReference(params);\n            params = dt < getDecayPeriod(params) ? updateVolatilityReference(params) : setVolatilityReference(params, 0);\n        }\n\n        return updateTimeOfLastUpdate(params, timestamp);\n    }\n\n    /**\n     * @dev Updates the volatility reference and the volatility accumulator in the encoded pair parameters\n     * @param params The encoded pair parameters\n     * @param activeId The active id\n     * @param timestamp The timestamp\n     * @return The updated encoded pair parameters\n     */\n    function updateVolatilityParameters(bytes32 params, uint24 activeId, uint256 timestamp)\n        internal\n        pure\n        returns (bytes32)\n    {\n        params = updateReferences(params, timestamp);\n        return updateVolatilityAccumulator(params, activeId);\n    }\n}\n"
    },
    "contracts/joe-v2/src/libraries/PriceHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {Uint128x128Math} from \"./math/Uint128x128Math.sol\";\nimport {Uint256x256Math} from \"./math/Uint256x256Math.sol\";\nimport {SafeCast} from \"./math/SafeCast.sol\";\nimport {Constants} from \"./Constants.sol\";\n\n/**\n * @title Liquidity Book Price Helper Library\n * @author Trader Joe\n * @notice This library contains functions to calculate prices\n */\nlibrary PriceHelper {\n    using Uint128x128Math for uint256;\n    using Uint256x256Math for uint256;\n    using SafeCast for uint256;\n\n    int256 private constant REAL_ID_SHIFT = 1 << 23;\n\n    /**\n     * @dev Calculates the price from the id and the bin step\n     * @param id The id\n     * @param binStep The bin step\n     * @return price The price as a 128.128-binary fixed-point number\n     */\n    function getPriceFromId(uint24 id, uint16 binStep) internal pure returns (uint256 price) {\n        uint256 base = getBase(binStep);\n        int256 exponent = getExponent(id);\n\n        price = base.pow(exponent);\n    }\n\n    /**\n     * @dev Calculates the id from the price and the bin step\n     * @param price The price as a 128.128-binary fixed-point number\n     * @param binStep The bin step\n     * @return id The id\n     */\n    function getIdFromPrice(uint256 price, uint16 binStep) internal pure returns (uint24 id) {\n        uint256 base = getBase(binStep);\n        int256 realId = price.log2() / base.log2();\n\n        unchecked {\n            id = uint256(REAL_ID_SHIFT + realId).safe24();\n        }\n    }\n\n    /**\n     * @dev Calculates the base from the bin step, which is `1 + binStep / BASIS_POINT_MAX`\n     * @param binStep The bin step\n     * @return base The base\n     */\n    function getBase(uint16 binStep) internal pure returns (uint256) {\n        unchecked {\n            return Constants.SCALE + (uint256(binStep) << Constants.SCALE_OFFSET) / Constants.BASIS_POINT_MAX;\n        }\n    }\n\n    /**\n     * @dev Calculates the exponent from the id, which is `id - REAL_ID_SHIFT`\n     * @param id The id\n     * @return exponent The exponent\n     */\n    function getExponent(uint24 id) internal pure returns (int256) {\n        unchecked {\n            return int256(uint256(id)) - REAL_ID_SHIFT;\n        }\n    }\n\n    /**\n     * @dev Converts a price with 18 decimals to a 128.128-binary fixed-point number\n     * @param price The price with 18 decimals\n     * @return price128x128 The 128.128-binary fixed-point number\n     */\n    function convertDecimalPriceTo128x128(uint256 price) internal pure returns (uint256) {\n        return price.shiftDivRoundDown(Constants.SCALE_OFFSET, Constants.PRECISION);\n    }\n\n    /**\n     * @dev Converts a 128.128-binary fixed-point number to a price with 18 decimals\n     * @param price128x128 The 128.128-binary fixed-point number\n     * @return price The price with 18 decimals\n     */\n    function convert128x128PriceToDecimal(uint256 price128x128) internal pure returns (uint256) {\n        return price128x128.mulShiftRoundDown(Constants.PRECISION, Constants.SCALE_OFFSET);\n    }\n}\n"
    },
    "contracts/joe-v2/src/libraries/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\nimport {Initializable} from \"../../lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev This contract is a fork of the `ReentrancyGuardUpgradeable` contract from OpenZeppelin\n * that has been modified to update the `_nonReentrantBefore` and `_nonReentrantAfter`\n * functions to `internal` visibility.\n *\n * Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ReentrancyGuard\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation =\n        0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() internal {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() internal {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}\n"
    },
    "contracts/joe-v2/src/libraries/TokenHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Liquidity Book Token Helper Library\n * @author Trader Joe\n * @notice Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using TokenHelper for IERC20;` statement to your contract,\n * which allows you to call the safe operation as `token.safeTransfer(...)`\n */\nlibrary TokenHelper {\n    error TokenHelper__TransferFailed();\n\n    /**\n     * @notice Transfers token and reverts if the transfer fails\n     * @param token The address of the token\n     * @param owner The owner of the tokens\n     * @param recipient The address of the recipient\n     * @param amount The amount to send\n     */\n    function safeTransferFrom(IERC20 token, address owner, address recipient, uint256 amount) internal {\n        bytes memory data = abi.encodeWithSelector(token.transferFrom.selector, owner, recipient, amount);\n\n        _callAndCatch(token, data);\n    }\n\n    /**\n     * @notice Transfers token and reverts if the transfer fails\n     * @param token The address of the token\n     * @param recipient The address of the recipient\n     * @param amount The amount to send\n     */\n    function safeTransfer(IERC20 token, address recipient, uint256 amount) internal {\n        bytes memory data = abi.encodeWithSelector(token.transfer.selector, recipient, amount);\n\n        _callAndCatch(token, data);\n    }\n\n    function _callAndCatch(IERC20 token, bytes memory data) internal {\n        bool success;\n\n        assembly {\n            mstore(0x00, 0)\n\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0x00, 0x20)\n\n            switch success\n            case 0 {\n                if returndatasize() {\n                    returndatacopy(0x00, 0x00, returndatasize())\n                    revert(0x00, returndatasize())\n                }\n            }\n            default {\n                switch returndatasize()\n                case 0 { success := iszero(iszero(extcodesize(token))) }\n                default { success := and(success, eq(mload(0x00), 1)) }\n            }\n        }\n\n        if (!success) revert TokenHelper__TransferFailed();\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}