{
  "language": "Solidity",
  "sources": {
    "contracts/citrus-safe-modules/src/GlobalModule.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./interfaces/ISafe.sol\";\n\nerror ExecutionFailed();\nerror InvalidNonce();\n\ncontract GlobalModule {\n    // keccak256(\n    //     \"EIP712Domain(address verifyingContract)\"\n    // );\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH =\n        0x035aff83d86937d35b32e04f0ddc6ff469290eef2f1b692d8a815c89404d4749;\n\n    // keccak256(\n    //     \"SafeTx(address safe, address to,uint256 value,bytes data,uint8 operation,uint256 nonce)\"\n    // );\n    bytes32 private constant SAFE_TX_TYPEHASH = 0x53e4738ea125dc0fa1af119584e8a77584d1a6959a7eb39af54f5a2cbdcb274a;\n\n    mapping(ISafe => uint256) public nonces;\n\n    /**\n     * @notice Executes a `operation` {0: Call, 1: DelegateCall}} transaction to `to` with `value` (Native Currency)\n     * @dev This method doesn't perform any sanity check of the transaction, such as:\n     *      - if the contract at `to` address has code or not\n     *      It is the responsibility of the caller to perform such checks.\n     * @param safe The safe the transaction will be executed on\n     * @param to Destination address of Safe transaction.\n     * @param value Ether value of Safe transaction.\n     * @param data Data payload of Safe transaction.\n     * @param operation Operation type of Safe transaction.\n     * @param signatures Signature data that should be verified.\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\n     * @return success Boolean indicating transaction's success.\n     */\n    function execTransaction(\n        ISafe safe,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        uint8 operation,\n        bytes memory signatures\n    ) public payable virtual returns (bool success) {\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            uint256 nonce = nonces[safe];\n            bytes memory txHashData = encodeTransactionData(\n                safe,\n                // Transaction info\n                to,\n                value,\n                data,\n                operation,\n                // Signature info\n                nonce\n            );\n            // Increase nonce and execute transaction.\n            nonces[safe]++;\n            txHash = keccak256(txHashData);\n            safe.checkSignatures(txHash, txHashData, signatures);\n        }\n\n        if (!safe.execTransactionFromModule(to, value, data, operation)) {\n            revert ExecutionFailed();\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Returns the domain separator for the safe contract, as defined in the EIP-712 standard.\n     * @return bytes32 The domain separator hash.\n     */\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, address(this)));\n    }\n\n    /**\n     * @notice Returns the pre-image of the transaction hash (see getTransactionHash).\n     * @param safe The safe the transaction will be executed on\n     * @param to Destination address.\n     * @param value Ether value.\n     * @param data Data payload.\n     * @param operation Operation type.\n     * @param _nonce Transaction nonce.\n     * @return Transaction hash bytes.\n     */\n    function encodeTransactionData(\n        ISafe safe,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        uint8 operation,\n        uint256 _nonce\n    ) public view returns (bytes memory) {\n        bytes32 safeTxHash =\n            keccak256(abi.encode(SAFE_TX_TYPEHASH, safe, to, value, keccak256(data), operation, _nonce));\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\n    }\n\n    /**\n     * @notice Returns transaction hash to be signed by owners.\n     * @param safe The safe the transaction will be executed on\n     * @param to Destination address.\n     * @param value Ether value.\n     * @param data Data payload.\n     * @param operation Operation type.\n     * @param _nonce Transaction nonce.\n     * @return Transaction hash.\n     */\n    function getTransactionHash(\n        ISafe safe,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        uint8 operation,\n        uint256 _nonce\n    ) public view returns (bytes32) {\n        return keccak256(encodeTransactionData(safe, to, value, data, operation, _nonce));\n    }\n\n    /**\n     * @notice Increment the nonce manually\n     * @dev allows skipping a nonce if for some reason it fails\n     * @param currentNonce The nonce to skip, it needs to be the current nonce\n     */\n    function increaseNonce(uint256 currentNonce) public {\n        if (currentNonce != nonces[ISafe(msg.sender)]) {\n            revert InvalidNonce();\n        }\n\n        nonces[ISafe(msg.sender)]++;\n    }\n}\n"
    },
    "contracts/citrus-safe-modules/src/interfaces/ISafe.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\ninterface ISafe {\n    /**\n     * @notice Sets an initial storage of the Safe contract.\n     * @dev This method can only be called once.\n     *      If a proxy was created without setting up, anyone can call setup and claim the proxy.\n     * @param _owners List of Safe owners.\n     * @param _threshold Number of required confirmations for a Safe transaction.\n     * @param to Contract address for optional delegate call.\n     * @param data Data payload for optional delegate call.\n     * @param fallbackHandler Handler for fallback calls to this contract\n     * @param paymentToken Token that should be used for the payment (0 is ETH)\n     * @param payment Value that should be paid\n     * @param paymentReceiver Address that should receive the payment (or 0 if tx.origin)\n     */\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    ) external;\n\n    /**\n     * @dev Allows a Module to execute a Safe transaction without any further confirmations.\n     * @param to Destination address of module transaction.\n     * @param value Ether value of module transaction.\n     * @param data Data payload of module transaction.\n     * @param operation Operation type of module transaction.\n     */\n    function execTransactionFromModule(address to, uint256 value, bytes memory data, uint8 operation)\n        external\n        returns (bool success);\n\n    /**\n     * @notice Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token) and return data\n     * @param to Destination address of module transaction.\n     * @param value Ether value of module transaction.\n     * @param data Data payload of module transaction.\n     * @param operation Operation type of module transaction.\n     * @return success Boolean flag indicating if the call succeeded.\n     * @return returnData Data returned by the call.\n     */\n    function execTransactionFromModuleReturnData(address to, uint256 value, bytes memory data, uint8 operation)\n        external\n        returns (bool success, bytes memory returnData);\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param data That should be signed (this is passed to an external validator contract)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(bytes32 dataHash, bytes memory data, bytes memory signatures) external view;\n\n    /**\n     * @dev Returns the domain separator for this contract, as defined in the EIP-712 standard.\n     * @return bytes32 The domain separator hash.\n     */\n    function domainSeparator() external view returns (bytes32);\n\n    /**\n     * @dev Returns array of modules.\n     * @param start Start of the page.\n     * @param pageSize Maximum number of modules that should be returned.\n     * @return array Array of modules.\n     * @return next Start of the next page.\n     */\n    function getModulesPaginated(address start, uint256 pageSize)\n        external\n        view\n        returns (address[] memory array, address next);\n\n    /**\n     * @notice Enables the module `module` for the Safe.\n     * @dev This can only be done via a Safe transaction.\n     * @param module Module to be enabled.\n     */\n    function enableModule(address module) external;\n\n    /**\n     * @notice Returns the number of required confirmations for a Safe transaction aka the threshold.\n     * @return Threshold number.\n     */\n    function getThreshold() external view returns (uint256);\n\n    /**\n     * @notice Marks hash `hashToApprove` as approved.\n     * @dev This can be used with a pre-approved hash transaction signature.\n     *      IMPORTANT: The approved hash stays approved forever. There's no revocation mechanism, so it behaves similarly to ECDSA signatures\n     * @param hashToApprove The hash to mark as approved for signatures that are verified by this contract.\n     */\n    function approveHash(bytes32 hashToApprove) external;\n\n    /**\n     * @notice Returns transaction hash to be signed by owners.\n     * @param to Destination address.\n     * @param value Ether value.\n     * @param data Data payload.\n     * @param operation Operation type.\n     * @param safeTxGas Fas that should be used for the safe transaction.\n     * @param baseGas Gas costs for data used to trigger the safe transaction.\n     * @param gasPrice Maximum gas price that should be used for this transaction.\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n     * @param _nonce Transaction nonce.\n     * @return Transaction hash.\n     */\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        uint8 operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) external view returns (bytes32);\n\n    /**\n     * @notice Executes a `operation` {0: Call, 1: DelegateCall}} transaction to `to` with `value` (Native Currency)\n     *          and pays `gasPrice` * `gasLimit` in `gasToken` token to `refundReceiver`.\n     * @dev The fees are always transferred, even if the user transaction fails.\n     *      This method doesn't perform any sanity check of the transaction, such as:\n     *      - if the contract at `to` address has code or not\n     *      - if the `gasToken` is a contract or not\n     *      It is the responsibility of the caller to perform such checks.\n     * @param to Destination address of Safe transaction.\n     * @param value Ether value of Safe transaction.\n     * @param data Data payload of Safe transaction.\n     * @param operation Operation type of Safe transaction.\n     * @param safeTxGas Gas that should be used for the Safe transaction.\n     * @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n     * @param gasPrice Gas price that should be used for the payment calculation.\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n     * @param signatures Signature data that should be verified.\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\n     * @return success Boolean indicating transaction's success.\n     */\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        uint8 operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) external payable returns (bool success);\n}\n"
    },
    "contracts/citrus-safe-modules/src/interfaces/ISafeProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport {ISafe} from \"./ISafe.sol\";\n\ninterface ISafeProxyFactory {\n    function createProxyWithNonce(address _singleton, bytes memory initializer, uint256 saltNonce)\n        external\n        returns (ISafe proxy);\n}\n"
    },
    "contracts/citrus-safe-modules/src/ModuleSetup.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport {ISafe} from \"./interfaces/ISafe.sol\";\n\n/**\n * @title ModuleSetup - A utility contract for setting up a Safe with modules.\n * @dev The Safe `setup` function accepts `to` and `data` parameters for a delegate call during initialization. This\n *      contract can be specified as the `to` with `data` ABI encoding the `enableModules` call so that a Safe is\n *      created with the specified modules.\n */\ncontract ModuleSetup {\n    /**\n     * @notice Enable the specified Safe modules.\n     * @dev This call will only work if used from a Safe via delegatecall. It is intended to be used as part of the\n     *      Safe `setup`, allowing Safes to be created with an initial set of enabled modules.\n     * @param modules The modules to enable.\n     */\n    function enableModules(address[] calldata modules) external {\n        for (uint256 i = 0; i < modules.length; i++) {\n            ISafe(address(this)).enableModule(modules[i]);\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}